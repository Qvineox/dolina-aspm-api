// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: cyclonedx/v16/bom.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Timestamp } from "../../google/protobuf/timestamp";

export const protobufPackage = "dolina.cyclonedx.v16";

export enum Classification {
  /** CLASSIFICATION_NULL - buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified` */
  CLASSIFICATION_NULL = 0,
  /** CLASSIFICATION_APPLICATION - A software application. Refer to https://en.wikipedia.org/wiki/Application_software for information about applications. */
  CLASSIFICATION_APPLICATION = 1,
  /** CLASSIFICATION_FRAMEWORK - A software framework. Refer to https://en.wikipedia.org/wiki/Software_framework for information on how frameworks vary slightly from libraries. */
  CLASSIFICATION_FRAMEWORK = 2,
  /** CLASSIFICATION_LIBRARY - A software library. Refer to https://en.wikipedia.org/wiki/Library_(computing) for information about libraries. All third-party and open source reusable components will likely be a library. If the library also has key features of a framework, then it should be classified as a framework. If not, or is unknown, then specifying library is recommended. */
  CLASSIFICATION_LIBRARY = 3,
  /** CLASSIFICATION_OPERATING_SYSTEM - A software operating system without regard to deployment model (i.e. installed on physical hardware, virtual machine, image, etc) Refer to https://en.wikipedia.org/wiki/Operating_system */
  CLASSIFICATION_OPERATING_SYSTEM = 4,
  /** CLASSIFICATION_DEVICE - A hardware device such as a processor, or chip-set. A hardware device containing firmware should include a component for the physical hardware itself, and another component of type 'firmware' or 'operating-system' (whichever is relevant), describing information about the software running on the device. See also the list of known device properties: https://github.com/CycloneDX/cyclonedx-property-taxonomy/blob/main/cdx/device.md */
  CLASSIFICATION_DEVICE = 5,
  /** CLASSIFICATION_FILE - A computer file. Refer to https://en.wikipedia.org/wiki/Computer_file for information about files. */
  CLASSIFICATION_FILE = 6,
  /** CLASSIFICATION_CONTAINER - A packaging and/or runtime format, not specific to any particular technology, which isolates software inside the container from software outside of a container through virtualization technology. Refer to https://en.wikipedia.org/wiki/OS-level_virtualization */
  CLASSIFICATION_CONTAINER = 7,
  /** CLASSIFICATION_FIRMWARE - A special type of software that provides low-level control over a devices hardware. Refer to https://en.wikipedia.org/wiki/Firmware */
  CLASSIFICATION_FIRMWARE = 8,
  /** CLASSIFICATION_DEVICE_DRIVER - A special type of software that operates or controls a particular type of device. Refer to https://en.wikipedia.org/wiki/Device_driver */
  CLASSIFICATION_DEVICE_DRIVER = 9,
  /** CLASSIFICATION_PLATFORM - A runtime environment which interprets or executes software. This may include runtimes such as those that execute bytecode or low-code/no-code application platforms. */
  CLASSIFICATION_PLATFORM = 10,
  /** CLASSIFICATION_MACHINE_LEARNING_MODEL - A model based on training data that can make predictions or decisions without being explicitly programmed to do so. */
  CLASSIFICATION_MACHINE_LEARNING_MODEL = 11,
  /** CLASSIFICATION_DATA - A collection of discrete values that convey information. */
  CLASSIFICATION_DATA = 12,
  /** CLASSIFICATION_CRYPTOGRAPHIC_ASSET - A cryptographic asset including algorithms, protocols, certificates, keys, tokens, and secrets. */
  CLASSIFICATION_CRYPTOGRAPHIC_ASSET = 13,
  UNRECOGNIZED = -1,
}

export function classificationFromJSON(object: any): Classification {
  switch (object) {
    case 0:
    case "CLASSIFICATION_NULL":
      return Classification.CLASSIFICATION_NULL;
    case 1:
    case "CLASSIFICATION_APPLICATION":
      return Classification.CLASSIFICATION_APPLICATION;
    case 2:
    case "CLASSIFICATION_FRAMEWORK":
      return Classification.CLASSIFICATION_FRAMEWORK;
    case 3:
    case "CLASSIFICATION_LIBRARY":
      return Classification.CLASSIFICATION_LIBRARY;
    case 4:
    case "CLASSIFICATION_OPERATING_SYSTEM":
      return Classification.CLASSIFICATION_OPERATING_SYSTEM;
    case 5:
    case "CLASSIFICATION_DEVICE":
      return Classification.CLASSIFICATION_DEVICE;
    case 6:
    case "CLASSIFICATION_FILE":
      return Classification.CLASSIFICATION_FILE;
    case 7:
    case "CLASSIFICATION_CONTAINER":
      return Classification.CLASSIFICATION_CONTAINER;
    case 8:
    case "CLASSIFICATION_FIRMWARE":
      return Classification.CLASSIFICATION_FIRMWARE;
    case 9:
    case "CLASSIFICATION_DEVICE_DRIVER":
      return Classification.CLASSIFICATION_DEVICE_DRIVER;
    case 10:
    case "CLASSIFICATION_PLATFORM":
      return Classification.CLASSIFICATION_PLATFORM;
    case 11:
    case "CLASSIFICATION_MACHINE_LEARNING_MODEL":
      return Classification.CLASSIFICATION_MACHINE_LEARNING_MODEL;
    case 12:
    case "CLASSIFICATION_DATA":
      return Classification.CLASSIFICATION_DATA;
    case 13:
    case "CLASSIFICATION_CRYPTOGRAPHIC_ASSET":
      return Classification.CLASSIFICATION_CRYPTOGRAPHIC_ASSET;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Classification.UNRECOGNIZED;
  }
}

export function classificationToJSON(object: Classification): string {
  switch (object) {
    case Classification.CLASSIFICATION_NULL:
      return "CLASSIFICATION_NULL";
    case Classification.CLASSIFICATION_APPLICATION:
      return "CLASSIFICATION_APPLICATION";
    case Classification.CLASSIFICATION_FRAMEWORK:
      return "CLASSIFICATION_FRAMEWORK";
    case Classification.CLASSIFICATION_LIBRARY:
      return "CLASSIFICATION_LIBRARY";
    case Classification.CLASSIFICATION_OPERATING_SYSTEM:
      return "CLASSIFICATION_OPERATING_SYSTEM";
    case Classification.CLASSIFICATION_DEVICE:
      return "CLASSIFICATION_DEVICE";
    case Classification.CLASSIFICATION_FILE:
      return "CLASSIFICATION_FILE";
    case Classification.CLASSIFICATION_CONTAINER:
      return "CLASSIFICATION_CONTAINER";
    case Classification.CLASSIFICATION_FIRMWARE:
      return "CLASSIFICATION_FIRMWARE";
    case Classification.CLASSIFICATION_DEVICE_DRIVER:
      return "CLASSIFICATION_DEVICE_DRIVER";
    case Classification.CLASSIFICATION_PLATFORM:
      return "CLASSIFICATION_PLATFORM";
    case Classification.CLASSIFICATION_MACHINE_LEARNING_MODEL:
      return "CLASSIFICATION_MACHINE_LEARNING_MODEL";
    case Classification.CLASSIFICATION_DATA:
      return "CLASSIFICATION_DATA";
    case Classification.CLASSIFICATION_CRYPTOGRAPHIC_ASSET:
      return "CLASSIFICATION_CRYPTOGRAPHIC_ASSET";
    case Classification.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Specifies the flow direction of the data. Valid values are: inbound, outbound, bi-directional, and unknown. Direction is relative to the service. Inbound flow states that data enters the service. Outbound flow states that data leaves the service. Bi-directional states that data flows both ways, and unknown states that the direction is not known.
 * buf:lint:ignore ENUM_VALUE_PREFIX -- Enum value names should be prefixed with "DATA_FLOW_DIRECTION_"
 */
export enum DataFlowDirection {
  /**
   * DATA_FLOW_NULL - Default
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   */
  DATA_FLOW_NULL = 0,
  /** DATA_FLOW_INBOUND - Data that enters a service. */
  DATA_FLOW_INBOUND = 1,
  /** DATA_FLOW_OUTBOUND - Data that exits a service. */
  DATA_FLOW_OUTBOUND = 2,
  /** DATA_FLOW_BI_DIRECTIONAL - Data flows in and out of the service. */
  DATA_FLOW_BI_DIRECTIONAL = 3,
  /** DATA_FLOW_UNKNOWN - The directional flow of data is not known. */
  DATA_FLOW_UNKNOWN = 4,
  UNRECOGNIZED = -1,
}

export function dataFlowDirectionFromJSON(object: any): DataFlowDirection {
  switch (object) {
    case 0:
    case "DATA_FLOW_NULL":
      return DataFlowDirection.DATA_FLOW_NULL;
    case 1:
    case "DATA_FLOW_INBOUND":
      return DataFlowDirection.DATA_FLOW_INBOUND;
    case 2:
    case "DATA_FLOW_OUTBOUND":
      return DataFlowDirection.DATA_FLOW_OUTBOUND;
    case 3:
    case "DATA_FLOW_BI_DIRECTIONAL":
      return DataFlowDirection.DATA_FLOW_BI_DIRECTIONAL;
    case 4:
    case "DATA_FLOW_UNKNOWN":
      return DataFlowDirection.DATA_FLOW_UNKNOWN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataFlowDirection.UNRECOGNIZED;
  }
}

export function dataFlowDirectionToJSON(object: DataFlowDirection): string {
  switch (object) {
    case DataFlowDirection.DATA_FLOW_NULL:
      return "DATA_FLOW_NULL";
    case DataFlowDirection.DATA_FLOW_INBOUND:
      return "DATA_FLOW_INBOUND";
    case DataFlowDirection.DATA_FLOW_OUTBOUND:
      return "DATA_FLOW_OUTBOUND";
    case DataFlowDirection.DATA_FLOW_BI_DIRECTIONAL:
      return "DATA_FLOW_BI_DIRECTIONAL";
    case DataFlowDirection.DATA_FLOW_UNKNOWN:
      return "DATA_FLOW_UNKNOWN";
    case DataFlowDirection.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ExternalReferenceType {
  /**
   * EXTERNAL_REFERENCE_TYPE_OTHER - Use this if no other types accurately describe the purpose of the external reference
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `other` is our fallback, doubling `unspecified`
   */
  EXTERNAL_REFERENCE_TYPE_OTHER = 0,
  /** EXTERNAL_REFERENCE_TYPE_VCS - Version Control System */
  EXTERNAL_REFERENCE_TYPE_VCS = 1,
  /** EXTERNAL_REFERENCE_TYPE_ISSUE_TRACKER - Issue, defect tracking system, or an Application Lifecycle Management (ALM) system */
  EXTERNAL_REFERENCE_TYPE_ISSUE_TRACKER = 2,
  /** EXTERNAL_REFERENCE_TYPE_WEBSITE - Website */
  EXTERNAL_REFERENCE_TYPE_WEBSITE = 3,
  /** EXTERNAL_REFERENCE_TYPE_ADVISORIES - Security advisories */
  EXTERNAL_REFERENCE_TYPE_ADVISORIES = 4,
  /** EXTERNAL_REFERENCE_TYPE_BOM - Bill-of-material document (CycloneDX, SPDX, SWID, etc) */
  EXTERNAL_REFERENCE_TYPE_BOM = 5,
  /** EXTERNAL_REFERENCE_TYPE_MAILING_LIST - Mailing list or discussion group */
  EXTERNAL_REFERENCE_TYPE_MAILING_LIST = 6,
  /** EXTERNAL_REFERENCE_TYPE_SOCIAL - Social media account */
  EXTERNAL_REFERENCE_TYPE_SOCIAL = 7,
  /** EXTERNAL_REFERENCE_TYPE_CHAT - Real-time chat platform */
  EXTERNAL_REFERENCE_TYPE_CHAT = 8,
  /** EXTERNAL_REFERENCE_TYPE_DOCUMENTATION - Documentation, guides, or how-to instructions */
  EXTERNAL_REFERENCE_TYPE_DOCUMENTATION = 9,
  /** EXTERNAL_REFERENCE_TYPE_SUPPORT - Community or commercial support */
  EXTERNAL_REFERENCE_TYPE_SUPPORT = 10,
  /** EXTERNAL_REFERENCE_TYPE_DISTRIBUTION - Direct or repository download location */
  EXTERNAL_REFERENCE_TYPE_DISTRIBUTION = 11,
  /** EXTERNAL_REFERENCE_TYPE_LICENSE - The URL to the license file. If a license URL has been defined in the license node, it should also be defined as an external reference for completeness */
  EXTERNAL_REFERENCE_TYPE_LICENSE = 12,
  /** EXTERNAL_REFERENCE_TYPE_BUILD_META - Build-system specific meta file (i.e. pom.xml, package.json, .nuspec, etc) */
  EXTERNAL_REFERENCE_TYPE_BUILD_META = 13,
  /** EXTERNAL_REFERENCE_TYPE_BUILD_SYSTEM - URL to an automated build system */
  EXTERNAL_REFERENCE_TYPE_BUILD_SYSTEM = 14,
  /** EXTERNAL_REFERENCE_TYPE_SECURITY_CONTACT - Specifies a way to contact the maintainer, supplier, or provider in the event of a security incident. Common URIs include links to a disclosure procedure, a mailto (RFC-2368) that specifies an email address, a tel (RFC-3966) that specifies a phone number, or dns (RFC-4501) that specifies the records containing DNS Security TXT. */
  EXTERNAL_REFERENCE_TYPE_SECURITY_CONTACT = 15,
  /** EXTERNAL_REFERENCE_TYPE_ATTESTATION - Human or machine-readable statements containing facts, evidence, or testimony */
  EXTERNAL_REFERENCE_TYPE_ATTESTATION = 16,
  /** EXTERNAL_REFERENCE_TYPE_THREAT_MODEL - An enumeration of identified weaknesses, threats, and countermeasures, dataflow diagram (DFD), attack tree, and other supporting documentation in human-readable or machine-readable format */
  EXTERNAL_REFERENCE_TYPE_THREAT_MODEL = 17,
  /** EXTERNAL_REFERENCE_TYPE_ADVERSARY_MODEL - The defined assumptions, goals, and capabilities of an adversary. */
  EXTERNAL_REFERENCE_TYPE_ADVERSARY_MODEL = 18,
  /** EXTERNAL_REFERENCE_TYPE_RISK_ASSESSMENT - Identifies and analyzes the potential of future events that may negatively impact individuals, assets, and/or the environment. Risk assessments may also include judgments on the tolerability of each risk. */
  EXTERNAL_REFERENCE_TYPE_RISK_ASSESSMENT = 19,
  /** EXTERNAL_REFERENCE_TYPE_DISTRIBUTION_INTAKE - The location where a component was published. This is often the same as "distribution" but may also include specialized publishing processes that act as an intermediary */
  EXTERNAL_REFERENCE_TYPE_DISTRIBUTION_INTAKE = 20,
  /** EXTERNAL_REFERENCE_TYPE_VULNERABILITY_ASSERTION - A Vulnerability Disclosure Report (VDR) which asserts the known and previously unknown vulnerabilities that affect a component, service, or product including the analysis and findings describing the impact (or lack of impact) that the reported vulnerability has on a component, service, or product */
  EXTERNAL_REFERENCE_TYPE_VULNERABILITY_ASSERTION = 21,
  /** EXTERNAL_REFERENCE_TYPE_EXPLOITABILITY_STATEMENT - A Vulnerability Exploitability eXchange (VEX) asserts the known vulnerabilities that do not affect a product, product family, or organization, and optionally, the ones that do. The VEX should include the analysis and findings describing the impact (or lack of impact) that the reported vulnerability has on the product, product family, or organization */
  EXTERNAL_REFERENCE_TYPE_EXPLOITABILITY_STATEMENT = 22,
  /** EXTERNAL_REFERENCE_TYPE_PENTEST_REPORT - Results from an authorized simulated cyberattack on a component or service, otherwise known as a penetration test */
  EXTERNAL_REFERENCE_TYPE_PENTEST_REPORT = 23,
  /** EXTERNAL_REFERENCE_TYPE_STATIC_ANALYSIS_REPORT - SARIF or proprietary machine or human-readable report for which static analysis has identified code quality, security, and other potential issues with the source code */
  EXTERNAL_REFERENCE_TYPE_STATIC_ANALYSIS_REPORT = 24,
  /** EXTERNAL_REFERENCE_TYPE_DYNAMIC_ANALYSIS_REPORT - Dynamic analysis report that has identified issues such as vulnerabilities and misconfigurations */
  EXTERNAL_REFERENCE_TYPE_DYNAMIC_ANALYSIS_REPORT = 25,
  /** EXTERNAL_REFERENCE_TYPE_RUNTIME_ANALYSIS_REPORT - Report generated by analyzing the call stack of a running application */
  EXTERNAL_REFERENCE_TYPE_RUNTIME_ANALYSIS_REPORT = 26,
  /** EXTERNAL_REFERENCE_TYPE_COMPONENT_ANALYSIS_REPORT - Report generated by Software Composition Analysis (SCA), container analysis, or other forms of component analysis */
  EXTERNAL_REFERENCE_TYPE_COMPONENT_ANALYSIS_REPORT = 27,
  /** EXTERNAL_REFERENCE_TYPE_MATURITY_REPORT - Report containing a formal assessment of an organization, business unit, or team against a maturity model */
  EXTERNAL_REFERENCE_TYPE_MATURITY_REPORT = 28,
  /** EXTERNAL_REFERENCE_TYPE_CERTIFICATION_REPORT - Industry, regulatory, or other certification from an accredited (if applicable) certification body */
  EXTERNAL_REFERENCE_TYPE_CERTIFICATION_REPORT = 29,
  /** EXTERNAL_REFERENCE_TYPE_QUALITY_METRICS - Report or system in which quality metrics can be obtained */
  EXTERNAL_REFERENCE_TYPE_QUALITY_METRICS = 30,
  /** EXTERNAL_REFERENCE_TYPE_CODIFIED_INFRASTRUCTURE - Code or configuration that defines and provisions virtualized infrastructure, commonly referred to as Infrastructure as Code (IaC) */
  EXTERNAL_REFERENCE_TYPE_CODIFIED_INFRASTRUCTURE = 31,
  /** EXTERNAL_REFERENCE_TYPE_MODEL_CARD - A model card describes the intended uses of a machine learning model, potential limitations, biases, ethical considerations, training parameters, datasets used to train the model, performance metrics, and other relevant data useful for ML transparency. */
  EXTERNAL_REFERENCE_TYPE_MODEL_CARD = 32,
  /** EXTERNAL_REFERENCE_TYPE_POAM - Plans of Action and Milestones (POA&M) complement an "attestation" external reference. POA&M is defined by NIST as a "document that identifies tasks needing to be accomplished. It details resources required to accomplish the elements of the plan, any milestones in meeting the tasks and scheduled completion dates for the milestones". */
  EXTERNAL_REFERENCE_TYPE_POAM = 33,
  /** EXTERNAL_REFERENCE_TYPE_LOG - A record of events that occurred in a computer system or application, such as problems, errors, or information on current operations. */
  EXTERNAL_REFERENCE_TYPE_LOG = 34,
  /** EXTERNAL_REFERENCE_TYPE_CONFIGURATION - Parameters or settings that may be used by other components or services. */
  EXTERNAL_REFERENCE_TYPE_CONFIGURATION = 35,
  /** EXTERNAL_REFERENCE_TYPE_EVIDENCE - Information used to substantiate a claim. */
  EXTERNAL_REFERENCE_TYPE_EVIDENCE = 36,
  /** EXTERNAL_REFERENCE_TYPE_FORMULATION - Describes how a component or service was manufactured or deployed. */
  EXTERNAL_REFERENCE_TYPE_FORMULATION = 37,
  /** EXTERNAL_REFERENCE_TYPE_SOURCE_DISTRIBUTION - The location where the source code distributable can be obtained. This is often an archive format such as zip or tar.gz. The source-distribution type complements the use of the version control (vcs) type. */
  EXTERNAL_REFERENCE_TYPE_SOURCE_DISTRIBUTION = 38,
  /** EXTERNAL_REFERENCE_TYPE_ELECTRONIC_SIGNATURE - An e-signature is commonly a scanned representation of a written signature or a stylized script of the person's name. */
  EXTERNAL_REFERENCE_TYPE_ELECTRONIC_SIGNATURE = 39,
  /** EXTERNAL_REFERENCE_TYPE_DIGITAL_SIGNATURE - A signature that leverages cryptography, typically public/private key pairs, which provides strong authenticity verification. */
  EXTERNAL_REFERENCE_TYPE_DIGITAL_SIGNATURE = 40,
  /** EXTERNAL_REFERENCE_TYPE_RFC_9116 - Document that complies with RFC-9116 (A File Format to Aid in Security Vulnerability Disclosure) */
  EXTERNAL_REFERENCE_TYPE_RFC_9116 = 41,
  /** EXTERNAL_REFERENCE_TYPE_RELEASE_NOTES - Reference to release notes */
  EXTERNAL_REFERENCE_TYPE_RELEASE_NOTES = 42,
  UNRECOGNIZED = -1,
}

export function externalReferenceTypeFromJSON(object: any): ExternalReferenceType {
  switch (object) {
    case 0:
    case "EXTERNAL_REFERENCE_TYPE_OTHER":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_OTHER;
    case 1:
    case "EXTERNAL_REFERENCE_TYPE_VCS":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_VCS;
    case 2:
    case "EXTERNAL_REFERENCE_TYPE_ISSUE_TRACKER":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_ISSUE_TRACKER;
    case 3:
    case "EXTERNAL_REFERENCE_TYPE_WEBSITE":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_WEBSITE;
    case 4:
    case "EXTERNAL_REFERENCE_TYPE_ADVISORIES":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_ADVISORIES;
    case 5:
    case "EXTERNAL_REFERENCE_TYPE_BOM":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_BOM;
    case 6:
    case "EXTERNAL_REFERENCE_TYPE_MAILING_LIST":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_MAILING_LIST;
    case 7:
    case "EXTERNAL_REFERENCE_TYPE_SOCIAL":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_SOCIAL;
    case 8:
    case "EXTERNAL_REFERENCE_TYPE_CHAT":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_CHAT;
    case 9:
    case "EXTERNAL_REFERENCE_TYPE_DOCUMENTATION":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_DOCUMENTATION;
    case 10:
    case "EXTERNAL_REFERENCE_TYPE_SUPPORT":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_SUPPORT;
    case 11:
    case "EXTERNAL_REFERENCE_TYPE_DISTRIBUTION":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_DISTRIBUTION;
    case 12:
    case "EXTERNAL_REFERENCE_TYPE_LICENSE":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_LICENSE;
    case 13:
    case "EXTERNAL_REFERENCE_TYPE_BUILD_META":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_BUILD_META;
    case 14:
    case "EXTERNAL_REFERENCE_TYPE_BUILD_SYSTEM":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_BUILD_SYSTEM;
    case 15:
    case "EXTERNAL_REFERENCE_TYPE_SECURITY_CONTACT":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_SECURITY_CONTACT;
    case 16:
    case "EXTERNAL_REFERENCE_TYPE_ATTESTATION":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_ATTESTATION;
    case 17:
    case "EXTERNAL_REFERENCE_TYPE_THREAT_MODEL":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_THREAT_MODEL;
    case 18:
    case "EXTERNAL_REFERENCE_TYPE_ADVERSARY_MODEL":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_ADVERSARY_MODEL;
    case 19:
    case "EXTERNAL_REFERENCE_TYPE_RISK_ASSESSMENT":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_RISK_ASSESSMENT;
    case 20:
    case "EXTERNAL_REFERENCE_TYPE_DISTRIBUTION_INTAKE":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_DISTRIBUTION_INTAKE;
    case 21:
    case "EXTERNAL_REFERENCE_TYPE_VULNERABILITY_ASSERTION":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_VULNERABILITY_ASSERTION;
    case 22:
    case "EXTERNAL_REFERENCE_TYPE_EXPLOITABILITY_STATEMENT":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_EXPLOITABILITY_STATEMENT;
    case 23:
    case "EXTERNAL_REFERENCE_TYPE_PENTEST_REPORT":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_PENTEST_REPORT;
    case 24:
    case "EXTERNAL_REFERENCE_TYPE_STATIC_ANALYSIS_REPORT":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_STATIC_ANALYSIS_REPORT;
    case 25:
    case "EXTERNAL_REFERENCE_TYPE_DYNAMIC_ANALYSIS_REPORT":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_DYNAMIC_ANALYSIS_REPORT;
    case 26:
    case "EXTERNAL_REFERENCE_TYPE_RUNTIME_ANALYSIS_REPORT":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_RUNTIME_ANALYSIS_REPORT;
    case 27:
    case "EXTERNAL_REFERENCE_TYPE_COMPONENT_ANALYSIS_REPORT":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_COMPONENT_ANALYSIS_REPORT;
    case 28:
    case "EXTERNAL_REFERENCE_TYPE_MATURITY_REPORT":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_MATURITY_REPORT;
    case 29:
    case "EXTERNAL_REFERENCE_TYPE_CERTIFICATION_REPORT":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_CERTIFICATION_REPORT;
    case 30:
    case "EXTERNAL_REFERENCE_TYPE_QUALITY_METRICS":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_QUALITY_METRICS;
    case 31:
    case "EXTERNAL_REFERENCE_TYPE_CODIFIED_INFRASTRUCTURE":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_CODIFIED_INFRASTRUCTURE;
    case 32:
    case "EXTERNAL_REFERENCE_TYPE_MODEL_CARD":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_MODEL_CARD;
    case 33:
    case "EXTERNAL_REFERENCE_TYPE_POAM":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_POAM;
    case 34:
    case "EXTERNAL_REFERENCE_TYPE_LOG":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_LOG;
    case 35:
    case "EXTERNAL_REFERENCE_TYPE_CONFIGURATION":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_CONFIGURATION;
    case 36:
    case "EXTERNAL_REFERENCE_TYPE_EVIDENCE":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_EVIDENCE;
    case 37:
    case "EXTERNAL_REFERENCE_TYPE_FORMULATION":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_FORMULATION;
    case 38:
    case "EXTERNAL_REFERENCE_TYPE_SOURCE_DISTRIBUTION":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_SOURCE_DISTRIBUTION;
    case 39:
    case "EXTERNAL_REFERENCE_TYPE_ELECTRONIC_SIGNATURE":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_ELECTRONIC_SIGNATURE;
    case 40:
    case "EXTERNAL_REFERENCE_TYPE_DIGITAL_SIGNATURE":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_DIGITAL_SIGNATURE;
    case 41:
    case "EXTERNAL_REFERENCE_TYPE_RFC_9116":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_RFC_9116;
    case 42:
    case "EXTERNAL_REFERENCE_TYPE_RELEASE_NOTES":
      return ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_RELEASE_NOTES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ExternalReferenceType.UNRECOGNIZED;
  }
}

export function externalReferenceTypeToJSON(object: ExternalReferenceType): string {
  switch (object) {
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_OTHER:
      return "EXTERNAL_REFERENCE_TYPE_OTHER";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_VCS:
      return "EXTERNAL_REFERENCE_TYPE_VCS";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_ISSUE_TRACKER:
      return "EXTERNAL_REFERENCE_TYPE_ISSUE_TRACKER";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_WEBSITE:
      return "EXTERNAL_REFERENCE_TYPE_WEBSITE";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_ADVISORIES:
      return "EXTERNAL_REFERENCE_TYPE_ADVISORIES";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_BOM:
      return "EXTERNAL_REFERENCE_TYPE_BOM";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_MAILING_LIST:
      return "EXTERNAL_REFERENCE_TYPE_MAILING_LIST";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_SOCIAL:
      return "EXTERNAL_REFERENCE_TYPE_SOCIAL";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_CHAT:
      return "EXTERNAL_REFERENCE_TYPE_CHAT";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_DOCUMENTATION:
      return "EXTERNAL_REFERENCE_TYPE_DOCUMENTATION";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_SUPPORT:
      return "EXTERNAL_REFERENCE_TYPE_SUPPORT";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_DISTRIBUTION:
      return "EXTERNAL_REFERENCE_TYPE_DISTRIBUTION";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_LICENSE:
      return "EXTERNAL_REFERENCE_TYPE_LICENSE";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_BUILD_META:
      return "EXTERNAL_REFERENCE_TYPE_BUILD_META";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_BUILD_SYSTEM:
      return "EXTERNAL_REFERENCE_TYPE_BUILD_SYSTEM";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_SECURITY_CONTACT:
      return "EXTERNAL_REFERENCE_TYPE_SECURITY_CONTACT";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_ATTESTATION:
      return "EXTERNAL_REFERENCE_TYPE_ATTESTATION";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_THREAT_MODEL:
      return "EXTERNAL_REFERENCE_TYPE_THREAT_MODEL";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_ADVERSARY_MODEL:
      return "EXTERNAL_REFERENCE_TYPE_ADVERSARY_MODEL";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_RISK_ASSESSMENT:
      return "EXTERNAL_REFERENCE_TYPE_RISK_ASSESSMENT";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_DISTRIBUTION_INTAKE:
      return "EXTERNAL_REFERENCE_TYPE_DISTRIBUTION_INTAKE";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_VULNERABILITY_ASSERTION:
      return "EXTERNAL_REFERENCE_TYPE_VULNERABILITY_ASSERTION";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_EXPLOITABILITY_STATEMENT:
      return "EXTERNAL_REFERENCE_TYPE_EXPLOITABILITY_STATEMENT";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_PENTEST_REPORT:
      return "EXTERNAL_REFERENCE_TYPE_PENTEST_REPORT";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_STATIC_ANALYSIS_REPORT:
      return "EXTERNAL_REFERENCE_TYPE_STATIC_ANALYSIS_REPORT";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_DYNAMIC_ANALYSIS_REPORT:
      return "EXTERNAL_REFERENCE_TYPE_DYNAMIC_ANALYSIS_REPORT";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_RUNTIME_ANALYSIS_REPORT:
      return "EXTERNAL_REFERENCE_TYPE_RUNTIME_ANALYSIS_REPORT";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_COMPONENT_ANALYSIS_REPORT:
      return "EXTERNAL_REFERENCE_TYPE_COMPONENT_ANALYSIS_REPORT";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_MATURITY_REPORT:
      return "EXTERNAL_REFERENCE_TYPE_MATURITY_REPORT";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_CERTIFICATION_REPORT:
      return "EXTERNAL_REFERENCE_TYPE_CERTIFICATION_REPORT";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_QUALITY_METRICS:
      return "EXTERNAL_REFERENCE_TYPE_QUALITY_METRICS";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_CODIFIED_INFRASTRUCTURE:
      return "EXTERNAL_REFERENCE_TYPE_CODIFIED_INFRASTRUCTURE";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_MODEL_CARD:
      return "EXTERNAL_REFERENCE_TYPE_MODEL_CARD";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_POAM:
      return "EXTERNAL_REFERENCE_TYPE_POAM";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_LOG:
      return "EXTERNAL_REFERENCE_TYPE_LOG";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_CONFIGURATION:
      return "EXTERNAL_REFERENCE_TYPE_CONFIGURATION";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_EVIDENCE:
      return "EXTERNAL_REFERENCE_TYPE_EVIDENCE";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_FORMULATION:
      return "EXTERNAL_REFERENCE_TYPE_FORMULATION";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_SOURCE_DISTRIBUTION:
      return "EXTERNAL_REFERENCE_TYPE_SOURCE_DISTRIBUTION";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_ELECTRONIC_SIGNATURE:
      return "EXTERNAL_REFERENCE_TYPE_ELECTRONIC_SIGNATURE";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_DIGITAL_SIGNATURE:
      return "EXTERNAL_REFERENCE_TYPE_DIGITAL_SIGNATURE";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_RFC_9116:
      return "EXTERNAL_REFERENCE_TYPE_RFC_9116";
    case ExternalReferenceType.EXTERNAL_REFERENCE_TYPE_RELEASE_NOTES:
      return "EXTERNAL_REFERENCE_TYPE_RELEASE_NOTES";
    case ExternalReferenceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum HashAlg {
  /** HASH_ALG_NULL - buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified` */
  HASH_ALG_NULL = 0,
  HASH_ALG_MD_5 = 1,
  HASH_ALG_SHA_1 = 2,
  HASH_ALG_SHA_256 = 3,
  HASH_ALG_SHA_384 = 4,
  HASH_ALG_SHA_512 = 5,
  HASH_ALG_SHA_3_256 = 6,
  HASH_ALG_SHA_3_384 = 7,
  HASH_ALG_SHA_3_512 = 8,
  HASH_ALG_BLAKE_2_B_256 = 9,
  HASH_ALG_BLAKE_2_B_384 = 10,
  HASH_ALG_BLAKE_2_B_512 = 11,
  HASH_ALG_BLAKE_3 = 12,
  UNRECOGNIZED = -1,
}

export function hashAlgFromJSON(object: any): HashAlg {
  switch (object) {
    case 0:
    case "HASH_ALG_NULL":
      return HashAlg.HASH_ALG_NULL;
    case 1:
    case "HASH_ALG_MD_5":
      return HashAlg.HASH_ALG_MD_5;
    case 2:
    case "HASH_ALG_SHA_1":
      return HashAlg.HASH_ALG_SHA_1;
    case 3:
    case "HASH_ALG_SHA_256":
      return HashAlg.HASH_ALG_SHA_256;
    case 4:
    case "HASH_ALG_SHA_384":
      return HashAlg.HASH_ALG_SHA_384;
    case 5:
    case "HASH_ALG_SHA_512":
      return HashAlg.HASH_ALG_SHA_512;
    case 6:
    case "HASH_ALG_SHA_3_256":
      return HashAlg.HASH_ALG_SHA_3_256;
    case 7:
    case "HASH_ALG_SHA_3_384":
      return HashAlg.HASH_ALG_SHA_3_384;
    case 8:
    case "HASH_ALG_SHA_3_512":
      return HashAlg.HASH_ALG_SHA_3_512;
    case 9:
    case "HASH_ALG_BLAKE_2_B_256":
      return HashAlg.HASH_ALG_BLAKE_2_B_256;
    case 10:
    case "HASH_ALG_BLAKE_2_B_384":
      return HashAlg.HASH_ALG_BLAKE_2_B_384;
    case 11:
    case "HASH_ALG_BLAKE_2_B_512":
      return HashAlg.HASH_ALG_BLAKE_2_B_512;
    case 12:
    case "HASH_ALG_BLAKE_3":
      return HashAlg.HASH_ALG_BLAKE_3;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HashAlg.UNRECOGNIZED;
  }
}

export function hashAlgToJSON(object: HashAlg): string {
  switch (object) {
    case HashAlg.HASH_ALG_NULL:
      return "HASH_ALG_NULL";
    case HashAlg.HASH_ALG_MD_5:
      return "HASH_ALG_MD_5";
    case HashAlg.HASH_ALG_SHA_1:
      return "HASH_ALG_SHA_1";
    case HashAlg.HASH_ALG_SHA_256:
      return "HASH_ALG_SHA_256";
    case HashAlg.HASH_ALG_SHA_384:
      return "HASH_ALG_SHA_384";
    case HashAlg.HASH_ALG_SHA_512:
      return "HASH_ALG_SHA_512";
    case HashAlg.HASH_ALG_SHA_3_256:
      return "HASH_ALG_SHA_3_256";
    case HashAlg.HASH_ALG_SHA_3_384:
      return "HASH_ALG_SHA_3_384";
    case HashAlg.HASH_ALG_SHA_3_512:
      return "HASH_ALG_SHA_3_512";
    case HashAlg.HASH_ALG_BLAKE_2_B_256:
      return "HASH_ALG_BLAKE_2_B_256";
    case HashAlg.HASH_ALG_BLAKE_2_B_384:
      return "HASH_ALG_BLAKE_2_B_384";
    case HashAlg.HASH_ALG_BLAKE_2_B_512:
      return "HASH_ALG_BLAKE_2_B_512";
    case HashAlg.HASH_ALG_BLAKE_3:
      return "HASH_ALG_BLAKE_3";
    case HashAlg.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum IssueClassification {
  /**
   * ISSUE_CLASSIFICATION_NULL - Default
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   */
  ISSUE_CLASSIFICATION_NULL = 0,
  /** ISSUE_CLASSIFICATION_DEFECT - A fault, flaw, or bug in software */
  ISSUE_CLASSIFICATION_DEFECT = 1,
  /** ISSUE_CLASSIFICATION_ENHANCEMENT - A new feature or behavior in software */
  ISSUE_CLASSIFICATION_ENHANCEMENT = 2,
  /** ISSUE_CLASSIFICATION_SECURITY - A special type of defect which impacts security */
  ISSUE_CLASSIFICATION_SECURITY = 3,
  UNRECOGNIZED = -1,
}

export function issueClassificationFromJSON(object: any): IssueClassification {
  switch (object) {
    case 0:
    case "ISSUE_CLASSIFICATION_NULL":
      return IssueClassification.ISSUE_CLASSIFICATION_NULL;
    case 1:
    case "ISSUE_CLASSIFICATION_DEFECT":
      return IssueClassification.ISSUE_CLASSIFICATION_DEFECT;
    case 2:
    case "ISSUE_CLASSIFICATION_ENHANCEMENT":
      return IssueClassification.ISSUE_CLASSIFICATION_ENHANCEMENT;
    case 3:
    case "ISSUE_CLASSIFICATION_SECURITY":
      return IssueClassification.ISSUE_CLASSIFICATION_SECURITY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IssueClassification.UNRECOGNIZED;
  }
}

export function issueClassificationToJSON(object: IssueClassification): string {
  switch (object) {
    case IssueClassification.ISSUE_CLASSIFICATION_NULL:
      return "ISSUE_CLASSIFICATION_NULL";
    case IssueClassification.ISSUE_CLASSIFICATION_DEFECT:
      return "ISSUE_CLASSIFICATION_DEFECT";
    case IssueClassification.ISSUE_CLASSIFICATION_ENHANCEMENT:
      return "ISSUE_CLASSIFICATION_ENHANCEMENT";
    case IssueClassification.ISSUE_CLASSIFICATION_SECURITY:
      return "ISSUE_CLASSIFICATION_SECURITY";
    case IssueClassification.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Declared licenses and concluded licenses represent two different stages in the licensing process within software development. Declared licenses refer to the initial intention of the software authors regarding the licensing terms under which their code is released. On the other hand, concluded licenses are the result of a comprehensive analysis of the project's codebase to identify and confirm the actual licenses of the components used, which may differ from the initially declared licenses. While declared licenses provide an upfront indication of the licensing intentions, concluded licenses offer a more thorough understanding of the actual licensing within a project, facilitating proper compliance and risk management. Observed licenses are defined in `@.evidence.licenses`. Observed licenses form the evidence necessary to substantiate a concluded license. */
export enum LicenseAcknowledgementEnumeration {
  /** LICENSE_ACKNOWLEDGEMENT_ENUMERATION_UNSPECIFIED - The license acknowledgement is not specified. */
  LICENSE_ACKNOWLEDGEMENT_ENUMERATION_UNSPECIFIED = 0,
  /** LICENSE_ACKNOWLEDGEMENT_ENUMERATION_DECLARED - Declared licenses represent the initial intentions of authors regarding the licensing terms of their code. */
  LICENSE_ACKNOWLEDGEMENT_ENUMERATION_DECLARED = 1,
  /** LICENSE_ACKNOWLEDGEMENT_ENUMERATION_CONCLUDED - Concluded licenses are verified and confirmed. */
  LICENSE_ACKNOWLEDGEMENT_ENUMERATION_CONCLUDED = 2,
  UNRECOGNIZED = -1,
}

export function licenseAcknowledgementEnumerationFromJSON(object: any): LicenseAcknowledgementEnumeration {
  switch (object) {
    case 0:
    case "LICENSE_ACKNOWLEDGEMENT_ENUMERATION_UNSPECIFIED":
      return LicenseAcknowledgementEnumeration.LICENSE_ACKNOWLEDGEMENT_ENUMERATION_UNSPECIFIED;
    case 1:
    case "LICENSE_ACKNOWLEDGEMENT_ENUMERATION_DECLARED":
      return LicenseAcknowledgementEnumeration.LICENSE_ACKNOWLEDGEMENT_ENUMERATION_DECLARED;
    case 2:
    case "LICENSE_ACKNOWLEDGEMENT_ENUMERATION_CONCLUDED":
      return LicenseAcknowledgementEnumeration.LICENSE_ACKNOWLEDGEMENT_ENUMERATION_CONCLUDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LicenseAcknowledgementEnumeration.UNRECOGNIZED;
  }
}

export function licenseAcknowledgementEnumerationToJSON(object: LicenseAcknowledgementEnumeration): string {
  switch (object) {
    case LicenseAcknowledgementEnumeration.LICENSE_ACKNOWLEDGEMENT_ENUMERATION_UNSPECIFIED:
      return "LICENSE_ACKNOWLEDGEMENT_ENUMERATION_UNSPECIFIED";
    case LicenseAcknowledgementEnumeration.LICENSE_ACKNOWLEDGEMENT_ENUMERATION_DECLARED:
      return "LICENSE_ACKNOWLEDGEMENT_ENUMERATION_DECLARED";
    case LicenseAcknowledgementEnumeration.LICENSE_ACKNOWLEDGEMENT_ENUMERATION_CONCLUDED:
      return "LICENSE_ACKNOWLEDGEMENT_ENUMERATION_CONCLUDED";
    case LicenseAcknowledgementEnumeration.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** buf:lint:ignore ENUM_VALUE_PREFIX -- Enum value names should be prefixed with "LICENSING_TYPE_ENUM_" */
export enum LicensingTypeEnum {
  /** LICENSING_TYPE_NULL - buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified` */
  LICENSING_TYPE_NULL = 0,
  /** LICENSING_TYPE_ACADEMIC - A license that grants use of software solely for the purpose of education or research. */
  LICENSING_TYPE_ACADEMIC = 1,
  /** LICENSING_TYPE_APPLIANCE - A license covering use of software embedded in a specific piece of hardware. */
  LICENSING_TYPE_APPLIANCE = 2,
  /** LICENSING_TYPE_CLIENT_ACCESS - A Client Access License (CAL) allows client computers to access services provided by server software. */
  LICENSING_TYPE_CLIENT_ACCESS = 3,
  /** LICENSING_TYPE_CONCURRENT_USER - A Concurrent User license (aka floating license) limits the number of licenses for a software application and licenses are shared among a larger number of users. */
  LICENSING_TYPE_CONCURRENT_USER = 4,
  /** LICENSING_TYPE_CORE_POINTS - A license where the core of a computer's processor is assigned a specific number of points. */
  LICENSING_TYPE_CORE_POINTS = 5,
  /** LICENSING_TYPE_CUSTOM_METRIC - A license for which consumption is measured by non-standard metrics. */
  LICENSING_TYPE_CUSTOM_METRIC = 6,
  /** LICENSING_TYPE_DEVICE - A license that covers a defined number of installations on computers and other types of devices. */
  LICENSING_TYPE_DEVICE = 7,
  /** LICENSING_TYPE_EVALUATION - A license that grants permission to install and use software for trial purposes. */
  LICENSING_TYPE_EVALUATION = 8,
  /** LICENSING_TYPE_NAMED_USER - A license that grants access to the software to one or more pre-defined users. */
  LICENSING_TYPE_NAMED_USER = 9,
  /** LICENSING_TYPE_NODE_LOCKED - A license that grants access to the software on one or more pre-defined computers or devices. */
  LICENSING_TYPE_NODE_LOCKED = 10,
  /** LICENSING_TYPE_OEM - An Original Equipment Manufacturer license that is delivered with hardware, cannot be transferred to other hardware, and is valid for the life of the hardware. */
  LICENSING_TYPE_OEM = 11,
  /** LICENSING_TYPE_PERPETUAL - A license where the software is sold on a one-time basis and the licensee can use a copy of the software indefinitely. */
  LICENSING_TYPE_PERPETUAL = 12,
  /** LICENSING_TYPE_PROCESSOR_POINTS - A license where each installation consumes points per processor. */
  LICENSING_TYPE_PROCESSOR_POINTS = 13,
  /** LICENSING_TYPE_SUBSCRIPTION - A license where the licensee pays a fee to use the software or service. */
  LICENSING_TYPE_SUBSCRIPTION = 14,
  /** LICENSING_TYPE_USER - A license that grants access to the software or service by a specified number of users. */
  LICENSING_TYPE_USER = 15,
  /** LICENSING_TYPE_OTHER - Another license type. */
  LICENSING_TYPE_OTHER = 16,
  UNRECOGNIZED = -1,
}

export function licensingTypeEnumFromJSON(object: any): LicensingTypeEnum {
  switch (object) {
    case 0:
    case "LICENSING_TYPE_NULL":
      return LicensingTypeEnum.LICENSING_TYPE_NULL;
    case 1:
    case "LICENSING_TYPE_ACADEMIC":
      return LicensingTypeEnum.LICENSING_TYPE_ACADEMIC;
    case 2:
    case "LICENSING_TYPE_APPLIANCE":
      return LicensingTypeEnum.LICENSING_TYPE_APPLIANCE;
    case 3:
    case "LICENSING_TYPE_CLIENT_ACCESS":
      return LicensingTypeEnum.LICENSING_TYPE_CLIENT_ACCESS;
    case 4:
    case "LICENSING_TYPE_CONCURRENT_USER":
      return LicensingTypeEnum.LICENSING_TYPE_CONCURRENT_USER;
    case 5:
    case "LICENSING_TYPE_CORE_POINTS":
      return LicensingTypeEnum.LICENSING_TYPE_CORE_POINTS;
    case 6:
    case "LICENSING_TYPE_CUSTOM_METRIC":
      return LicensingTypeEnum.LICENSING_TYPE_CUSTOM_METRIC;
    case 7:
    case "LICENSING_TYPE_DEVICE":
      return LicensingTypeEnum.LICENSING_TYPE_DEVICE;
    case 8:
    case "LICENSING_TYPE_EVALUATION":
      return LicensingTypeEnum.LICENSING_TYPE_EVALUATION;
    case 9:
    case "LICENSING_TYPE_NAMED_USER":
      return LicensingTypeEnum.LICENSING_TYPE_NAMED_USER;
    case 10:
    case "LICENSING_TYPE_NODE_LOCKED":
      return LicensingTypeEnum.LICENSING_TYPE_NODE_LOCKED;
    case 11:
    case "LICENSING_TYPE_OEM":
      return LicensingTypeEnum.LICENSING_TYPE_OEM;
    case 12:
    case "LICENSING_TYPE_PERPETUAL":
      return LicensingTypeEnum.LICENSING_TYPE_PERPETUAL;
    case 13:
    case "LICENSING_TYPE_PROCESSOR_POINTS":
      return LicensingTypeEnum.LICENSING_TYPE_PROCESSOR_POINTS;
    case 14:
    case "LICENSING_TYPE_SUBSCRIPTION":
      return LicensingTypeEnum.LICENSING_TYPE_SUBSCRIPTION;
    case 15:
    case "LICENSING_TYPE_USER":
      return LicensingTypeEnum.LICENSING_TYPE_USER;
    case 16:
    case "LICENSING_TYPE_OTHER":
      return LicensingTypeEnum.LICENSING_TYPE_OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LicensingTypeEnum.UNRECOGNIZED;
  }
}

export function licensingTypeEnumToJSON(object: LicensingTypeEnum): string {
  switch (object) {
    case LicensingTypeEnum.LICENSING_TYPE_NULL:
      return "LICENSING_TYPE_NULL";
    case LicensingTypeEnum.LICENSING_TYPE_ACADEMIC:
      return "LICENSING_TYPE_ACADEMIC";
    case LicensingTypeEnum.LICENSING_TYPE_APPLIANCE:
      return "LICENSING_TYPE_APPLIANCE";
    case LicensingTypeEnum.LICENSING_TYPE_CLIENT_ACCESS:
      return "LICENSING_TYPE_CLIENT_ACCESS";
    case LicensingTypeEnum.LICENSING_TYPE_CONCURRENT_USER:
      return "LICENSING_TYPE_CONCURRENT_USER";
    case LicensingTypeEnum.LICENSING_TYPE_CORE_POINTS:
      return "LICENSING_TYPE_CORE_POINTS";
    case LicensingTypeEnum.LICENSING_TYPE_CUSTOM_METRIC:
      return "LICENSING_TYPE_CUSTOM_METRIC";
    case LicensingTypeEnum.LICENSING_TYPE_DEVICE:
      return "LICENSING_TYPE_DEVICE";
    case LicensingTypeEnum.LICENSING_TYPE_EVALUATION:
      return "LICENSING_TYPE_EVALUATION";
    case LicensingTypeEnum.LICENSING_TYPE_NAMED_USER:
      return "LICENSING_TYPE_NAMED_USER";
    case LicensingTypeEnum.LICENSING_TYPE_NODE_LOCKED:
      return "LICENSING_TYPE_NODE_LOCKED";
    case LicensingTypeEnum.LICENSING_TYPE_OEM:
      return "LICENSING_TYPE_OEM";
    case LicensingTypeEnum.LICENSING_TYPE_PERPETUAL:
      return "LICENSING_TYPE_PERPETUAL";
    case LicensingTypeEnum.LICENSING_TYPE_PROCESSOR_POINTS:
      return "LICENSING_TYPE_PROCESSOR_POINTS";
    case LicensingTypeEnum.LICENSING_TYPE_SUBSCRIPTION:
      return "LICENSING_TYPE_SUBSCRIPTION";
    case LicensingTypeEnum.LICENSING_TYPE_USER:
      return "LICENSING_TYPE_USER";
    case LicensingTypeEnum.LICENSING_TYPE_OTHER:
      return "LICENSING_TYPE_OTHER";
    case LicensingTypeEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum LifecyclePhase {
  /**
   * LIFECYCLE_PHASE_DESIGN - BOM produced early in the development lifecycle containing an inventory of components and services that are proposed or planned to be used. The inventory may need to be procured, retrieved, or resourced prior to use.
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema
   */
  LIFECYCLE_PHASE_DESIGN = 0,
  /** LIFECYCLE_PHASE_PRE_BUILD - BOM consists of information obtained prior to a build process and may contain source files, development artifacts, and manifests. The inventory may need to be resolved and retrieved prior to use. */
  LIFECYCLE_PHASE_PRE_BUILD = 1,
  /** LIFECYCLE_PHASE_BUILD - BOM consisting of information obtained during a build process where component inventory is available for use. The precise versions of resolved components are usually available at this time as well as the provenance of where the components were retrieved from. */
  LIFECYCLE_PHASE_BUILD = 2,
  /** LIFECYCLE_PHASE_POST_BUILD - BOM consisting of information obtained after a build process has completed and the resulting components(s) are available for further analysis. Built components may exist as the result of a CI/CD process, may have been installed or deployed to a system or device, and may need to be retrieved or extracted from the system or device. */
  LIFECYCLE_PHASE_POST_BUILD = 3,
  /** LIFECYCLE_PHASE_OPERATIONS - BOM produced that represents inventory that is running and operational. This may include staging or production environments and will generally encompass multiple SBOMs describing the applications and operating system, along with HBOMs describing the hardware that makes up the system. Operations Bill of Materials (OBOM) can provide full-stack inventory of runtime environments, configurations, and additional dependencies. */
  LIFECYCLE_PHASE_OPERATIONS = 4,
  /** LIFECYCLE_PHASE_DISCOVERY - BOM consisting of information observed through network discovery providing point-in-time enumeration of embedded, on-premise, and cloud-native services such as server applications, connected devices, microservices, and serverless functions. */
  LIFECYCLE_PHASE_DISCOVERY = 5,
  /** LIFECYCLE_PHASE_DECOMMISSION - BOM containing inventory that will be, or has been retired from operations. */
  LIFECYCLE_PHASE_DECOMMISSION = 6,
  UNRECOGNIZED = -1,
}

export function lifecyclePhaseFromJSON(object: any): LifecyclePhase {
  switch (object) {
    case 0:
    case "LIFECYCLE_PHASE_DESIGN":
      return LifecyclePhase.LIFECYCLE_PHASE_DESIGN;
    case 1:
    case "LIFECYCLE_PHASE_PRE_BUILD":
      return LifecyclePhase.LIFECYCLE_PHASE_PRE_BUILD;
    case 2:
    case "LIFECYCLE_PHASE_BUILD":
      return LifecyclePhase.LIFECYCLE_PHASE_BUILD;
    case 3:
    case "LIFECYCLE_PHASE_POST_BUILD":
      return LifecyclePhase.LIFECYCLE_PHASE_POST_BUILD;
    case 4:
    case "LIFECYCLE_PHASE_OPERATIONS":
      return LifecyclePhase.LIFECYCLE_PHASE_OPERATIONS;
    case 5:
    case "LIFECYCLE_PHASE_DISCOVERY":
      return LifecyclePhase.LIFECYCLE_PHASE_DISCOVERY;
    case 6:
    case "LIFECYCLE_PHASE_DECOMMISSION":
      return LifecyclePhase.LIFECYCLE_PHASE_DECOMMISSION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LifecyclePhase.UNRECOGNIZED;
  }
}

export function lifecyclePhaseToJSON(object: LifecyclePhase): string {
  switch (object) {
    case LifecyclePhase.LIFECYCLE_PHASE_DESIGN:
      return "LIFECYCLE_PHASE_DESIGN";
    case LifecyclePhase.LIFECYCLE_PHASE_PRE_BUILD:
      return "LIFECYCLE_PHASE_PRE_BUILD";
    case LifecyclePhase.LIFECYCLE_PHASE_BUILD:
      return "LIFECYCLE_PHASE_BUILD";
    case LifecyclePhase.LIFECYCLE_PHASE_POST_BUILD:
      return "LIFECYCLE_PHASE_POST_BUILD";
    case LifecyclePhase.LIFECYCLE_PHASE_OPERATIONS:
      return "LIFECYCLE_PHASE_OPERATIONS";
    case LifecyclePhase.LIFECYCLE_PHASE_DISCOVERY:
      return "LIFECYCLE_PHASE_DISCOVERY";
    case LifecyclePhase.LIFECYCLE_PHASE_DECOMMISSION:
      return "LIFECYCLE_PHASE_DECOMMISSION";
    case LifecyclePhase.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PatchClassification {
  /**
   * PATCH_CLASSIFICATION_NULL - Default
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   */
  PATCH_CLASSIFICATION_NULL = 0,
  /** PATCH_CLASSIFICATION_UNOFFICIAL - A patch which is not developed by the creators or maintainers of the software being patched. Refer to https://en.wikipedia.org/wiki/Unofficial_patch */
  PATCH_CLASSIFICATION_UNOFFICIAL = 1,
  /** PATCH_CLASSIFICATION_MONKEY - A patch which dynamically modifies runtime behavior. Refer to https://en.wikipedia.org/wiki/Monkey_patch */
  PATCH_CLASSIFICATION_MONKEY = 2,
  /** PATCH_CLASSIFICATION_BACKPORT - A patch which takes code from a newer version of software and applies it to older versions of the same software. Refer to https://en.wikipedia.org/wiki/Backporting */
  PATCH_CLASSIFICATION_BACKPORT = 3,
  /** PATCH_CLASSIFICATION_CHERRY_PICK - A patch created by selectively applying commits from other versions or branches of the same software. */
  PATCH_CLASSIFICATION_CHERRY_PICK = 4,
  UNRECOGNIZED = -1,
}

export function patchClassificationFromJSON(object: any): PatchClassification {
  switch (object) {
    case 0:
    case "PATCH_CLASSIFICATION_NULL":
      return PatchClassification.PATCH_CLASSIFICATION_NULL;
    case 1:
    case "PATCH_CLASSIFICATION_UNOFFICIAL":
      return PatchClassification.PATCH_CLASSIFICATION_UNOFFICIAL;
    case 2:
    case "PATCH_CLASSIFICATION_MONKEY":
      return PatchClassification.PATCH_CLASSIFICATION_MONKEY;
    case 3:
    case "PATCH_CLASSIFICATION_BACKPORT":
      return PatchClassification.PATCH_CLASSIFICATION_BACKPORT;
    case 4:
    case "PATCH_CLASSIFICATION_CHERRY_PICK":
      return PatchClassification.PATCH_CLASSIFICATION_CHERRY_PICK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PatchClassification.UNRECOGNIZED;
  }
}

export function patchClassificationToJSON(object: PatchClassification): string {
  switch (object) {
    case PatchClassification.PATCH_CLASSIFICATION_NULL:
      return "PATCH_CLASSIFICATION_NULL";
    case PatchClassification.PATCH_CLASSIFICATION_UNOFFICIAL:
      return "PATCH_CLASSIFICATION_UNOFFICIAL";
    case PatchClassification.PATCH_CLASSIFICATION_MONKEY:
      return "PATCH_CLASSIFICATION_MONKEY";
    case PatchClassification.PATCH_CLASSIFICATION_BACKPORT:
      return "PATCH_CLASSIFICATION_BACKPORT";
    case PatchClassification.PATCH_CLASSIFICATION_CHERRY_PICK:
      return "PATCH_CLASSIFICATION_CHERRY_PICK";
    case PatchClassification.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Scope {
  /** SCOPE_UNSPECIFIED - Default */
  SCOPE_UNSPECIFIED = 0,
  /** SCOPE_REQUIRED - The component is required for runtime */
  SCOPE_REQUIRED = 1,
  /** SCOPE_OPTIONAL - The component is optional at runtime. Optional components are components that are not capable of being called due to them not being installed or otherwise accessible by any means. Components that are installed but, due to configuration or other restrictions, are prohibited from being called must be scoped as 'required'. */
  SCOPE_OPTIONAL = 2,
  /** SCOPE_EXCLUDED - Components that are excluded provide the ability to document component usage for test and other non-runtime purposes. Excluded components are not reachable within a call graph at runtime. */
  SCOPE_EXCLUDED = 3,
  UNRECOGNIZED = -1,
}

export function scopeFromJSON(object: any): Scope {
  switch (object) {
    case 0:
    case "SCOPE_UNSPECIFIED":
      return Scope.SCOPE_UNSPECIFIED;
    case 1:
    case "SCOPE_REQUIRED":
      return Scope.SCOPE_REQUIRED;
    case 2:
    case "SCOPE_OPTIONAL":
      return Scope.SCOPE_OPTIONAL;
    case 3:
    case "SCOPE_EXCLUDED":
      return Scope.SCOPE_EXCLUDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Scope.UNRECOGNIZED;
  }
}

export function scopeToJSON(object: Scope): string {
  switch (object) {
    case Scope.SCOPE_UNSPECIFIED:
      return "SCOPE_UNSPECIFIED";
    case Scope.SCOPE_REQUIRED:
      return "SCOPE_REQUIRED";
    case Scope.SCOPE_OPTIONAL:
      return "SCOPE_OPTIONAL";
    case Scope.SCOPE_EXCLUDED:
      return "SCOPE_EXCLUDED";
    case Scope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Aggregate {
  /**
   * AGGREGATE_NOT_SPECIFIED - The relationship completeness is not specified.
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `not specified` is our fallback, doubling `unspecified`
   */
  AGGREGATE_NOT_SPECIFIED = 0,
  /** AGGREGATE_COMPLETE - The relationship is complete. No further relationships including constituent components, services, or dependencies are known to exist. */
  AGGREGATE_COMPLETE = 1,
  /** AGGREGATE_INCOMPLETE - The relationship is incomplete. Additional relationships exist and may include constituent components, services, or dependencies. */
  AGGREGATE_INCOMPLETE = 2,
  /** AGGREGATE_INCOMPLETE_FIRST_PARTY_ONLY - The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented. */
  AGGREGATE_INCOMPLETE_FIRST_PARTY_ONLY = 3,
  /** AGGREGATE_INCOMPLETE_THIRD_PARTY_ONLY - The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented. */
  AGGREGATE_INCOMPLETE_THIRD_PARTY_ONLY = 4,
  /** AGGREGATE_UNKNOWN - The relationship may be complete or incomplete. This usually signifies a 'best-effort' to obtain constituent components, services, or dependencies but the completeness is inconclusive. */
  AGGREGATE_UNKNOWN = 5,
  /** AGGREGATE_INCOMPLETE_FIRST_PARTY_PROPRIETARY_ONLY - The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented, limited specifically to those that are proprietary. */
  AGGREGATE_INCOMPLETE_FIRST_PARTY_PROPRIETARY_ONLY = 6,
  /** AGGREGATE_INCOMPLETE_FIRST_PARTY_OPENSOURCE_ONLY - The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented, limited specifically to those that are opensource. */
  AGGREGATE_INCOMPLETE_FIRST_PARTY_OPENSOURCE_ONLY = 7,
  /** AGGREGATE_INCOMPLETE_THIRD_PARTY_PROPRIETARY_ONLY - The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented, limited specifically to those that are proprietary. */
  AGGREGATE_INCOMPLETE_THIRD_PARTY_PROPRIETARY_ONLY = 8,
  /** AGGREGATE_INCOMPLETE_THIRD_PARTY_OPENSOURCE_ONLY - The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented, limited specifically to those that are opensource. */
  AGGREGATE_INCOMPLETE_THIRD_PARTY_OPENSOURCE_ONLY = 9,
  UNRECOGNIZED = -1,
}

export function aggregateFromJSON(object: any): Aggregate {
  switch (object) {
    case 0:
    case "AGGREGATE_NOT_SPECIFIED":
      return Aggregate.AGGREGATE_NOT_SPECIFIED;
    case 1:
    case "AGGREGATE_COMPLETE":
      return Aggregate.AGGREGATE_COMPLETE;
    case 2:
    case "AGGREGATE_INCOMPLETE":
      return Aggregate.AGGREGATE_INCOMPLETE;
    case 3:
    case "AGGREGATE_INCOMPLETE_FIRST_PARTY_ONLY":
      return Aggregate.AGGREGATE_INCOMPLETE_FIRST_PARTY_ONLY;
    case 4:
    case "AGGREGATE_INCOMPLETE_THIRD_PARTY_ONLY":
      return Aggregate.AGGREGATE_INCOMPLETE_THIRD_PARTY_ONLY;
    case 5:
    case "AGGREGATE_UNKNOWN":
      return Aggregate.AGGREGATE_UNKNOWN;
    case 6:
    case "AGGREGATE_INCOMPLETE_FIRST_PARTY_PROPRIETARY_ONLY":
      return Aggregate.AGGREGATE_INCOMPLETE_FIRST_PARTY_PROPRIETARY_ONLY;
    case 7:
    case "AGGREGATE_INCOMPLETE_FIRST_PARTY_OPENSOURCE_ONLY":
      return Aggregate.AGGREGATE_INCOMPLETE_FIRST_PARTY_OPENSOURCE_ONLY;
    case 8:
    case "AGGREGATE_INCOMPLETE_THIRD_PARTY_PROPRIETARY_ONLY":
      return Aggregate.AGGREGATE_INCOMPLETE_THIRD_PARTY_PROPRIETARY_ONLY;
    case 9:
    case "AGGREGATE_INCOMPLETE_THIRD_PARTY_OPENSOURCE_ONLY":
      return Aggregate.AGGREGATE_INCOMPLETE_THIRD_PARTY_OPENSOURCE_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Aggregate.UNRECOGNIZED;
  }
}

export function aggregateToJSON(object: Aggregate): string {
  switch (object) {
    case Aggregate.AGGREGATE_NOT_SPECIFIED:
      return "AGGREGATE_NOT_SPECIFIED";
    case Aggregate.AGGREGATE_COMPLETE:
      return "AGGREGATE_COMPLETE";
    case Aggregate.AGGREGATE_INCOMPLETE:
      return "AGGREGATE_INCOMPLETE";
    case Aggregate.AGGREGATE_INCOMPLETE_FIRST_PARTY_ONLY:
      return "AGGREGATE_INCOMPLETE_FIRST_PARTY_ONLY";
    case Aggregate.AGGREGATE_INCOMPLETE_THIRD_PARTY_ONLY:
      return "AGGREGATE_INCOMPLETE_THIRD_PARTY_ONLY";
    case Aggregate.AGGREGATE_UNKNOWN:
      return "AGGREGATE_UNKNOWN";
    case Aggregate.AGGREGATE_INCOMPLETE_FIRST_PARTY_PROPRIETARY_ONLY:
      return "AGGREGATE_INCOMPLETE_FIRST_PARTY_PROPRIETARY_ONLY";
    case Aggregate.AGGREGATE_INCOMPLETE_FIRST_PARTY_OPENSOURCE_ONLY:
      return "AGGREGATE_INCOMPLETE_FIRST_PARTY_OPENSOURCE_ONLY";
    case Aggregate.AGGREGATE_INCOMPLETE_THIRD_PARTY_PROPRIETARY_ONLY:
      return "AGGREGATE_INCOMPLETE_THIRD_PARTY_PROPRIETARY_ONLY";
    case Aggregate.AGGREGATE_INCOMPLETE_THIRD_PARTY_OPENSOURCE_ONLY:
      return "AGGREGATE_INCOMPLETE_THIRD_PARTY_OPENSOURCE_ONLY";
    case Aggregate.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** buf:lint:ignore ENUM_VALUE_PREFIX -- Enum value names should be prefixed with "EVIDENCE_FIELD_TYPE_" */
export enum EvidenceFieldType {
  /** EVIDENCE_FIELD_NULL - buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified` */
  EVIDENCE_FIELD_NULL = 0,
  EVIDENCE_FIELD_GROUP = 1,
  EVIDENCE_FIELD_NAME = 2,
  EVIDENCE_FIELD_VERSION = 3,
  EVIDENCE_FIELD_PURL = 4,
  EVIDENCE_FIELD_CPE = 5,
  EVIDENCE_FIELD_SWID = 6,
  EVIDENCE_FIELD_HASH = 7,
  EVIDENCE_FIELD_OMNIBOR_ID = 8,
  EVIDENCE_FIELD_SWHID = 9,
  UNRECOGNIZED = -1,
}

export function evidenceFieldTypeFromJSON(object: any): EvidenceFieldType {
  switch (object) {
    case 0:
    case "EVIDENCE_FIELD_NULL":
      return EvidenceFieldType.EVIDENCE_FIELD_NULL;
    case 1:
    case "EVIDENCE_FIELD_GROUP":
      return EvidenceFieldType.EVIDENCE_FIELD_GROUP;
    case 2:
    case "EVIDENCE_FIELD_NAME":
      return EvidenceFieldType.EVIDENCE_FIELD_NAME;
    case 3:
    case "EVIDENCE_FIELD_VERSION":
      return EvidenceFieldType.EVIDENCE_FIELD_VERSION;
    case 4:
    case "EVIDENCE_FIELD_PURL":
      return EvidenceFieldType.EVIDENCE_FIELD_PURL;
    case 5:
    case "EVIDENCE_FIELD_CPE":
      return EvidenceFieldType.EVIDENCE_FIELD_CPE;
    case 6:
    case "EVIDENCE_FIELD_SWID":
      return EvidenceFieldType.EVIDENCE_FIELD_SWID;
    case 7:
    case "EVIDENCE_FIELD_HASH":
      return EvidenceFieldType.EVIDENCE_FIELD_HASH;
    case 8:
    case "EVIDENCE_FIELD_OMNIBOR_ID":
      return EvidenceFieldType.EVIDENCE_FIELD_OMNIBOR_ID;
    case 9:
    case "EVIDENCE_FIELD_SWHID":
      return EvidenceFieldType.EVIDENCE_FIELD_SWHID;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EvidenceFieldType.UNRECOGNIZED;
  }
}

export function evidenceFieldTypeToJSON(object: EvidenceFieldType): string {
  switch (object) {
    case EvidenceFieldType.EVIDENCE_FIELD_NULL:
      return "EVIDENCE_FIELD_NULL";
    case EvidenceFieldType.EVIDENCE_FIELD_GROUP:
      return "EVIDENCE_FIELD_GROUP";
    case EvidenceFieldType.EVIDENCE_FIELD_NAME:
      return "EVIDENCE_FIELD_NAME";
    case EvidenceFieldType.EVIDENCE_FIELD_VERSION:
      return "EVIDENCE_FIELD_VERSION";
    case EvidenceFieldType.EVIDENCE_FIELD_PURL:
      return "EVIDENCE_FIELD_PURL";
    case EvidenceFieldType.EVIDENCE_FIELD_CPE:
      return "EVIDENCE_FIELD_CPE";
    case EvidenceFieldType.EVIDENCE_FIELD_SWID:
      return "EVIDENCE_FIELD_SWID";
    case EvidenceFieldType.EVIDENCE_FIELD_HASH:
      return "EVIDENCE_FIELD_HASH";
    case EvidenceFieldType.EVIDENCE_FIELD_OMNIBOR_ID:
      return "EVIDENCE_FIELD_OMNIBOR_ID";
    case EvidenceFieldType.EVIDENCE_FIELD_SWHID:
      return "EVIDENCE_FIELD_SWHID";
    case EvidenceFieldType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EvidenceTechnique {
  /** EVIDENCE_TECHNIQUE_SOURCE_CODE_ANALYSIS - buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error, it shall be fixed with v2.0 of this very schema */
  EVIDENCE_TECHNIQUE_SOURCE_CODE_ANALYSIS = 0,
  EVIDENCE_TECHNIQUE_BINARY_ANALYSIS = 1,
  EVIDENCE_TECHNIQUE_MANIFEST_ANALYSIS = 2,
  EVIDENCE_TECHNIQUE_AST_FINGERPRINT = 3,
  EVIDENCE_TECHNIQUE_HASH_COMPARISON = 4,
  EVIDENCE_TECHNIQUE_INSTRUMENTATION = 5,
  EVIDENCE_TECHNIQUE_DYNAMIC_ANALYSIS = 6,
  EVIDENCE_TECHNIQUE_FILENAME = 7,
  EVIDENCE_TECHNIQUE_ATTESTATION = 8,
  EVIDENCE_TECHNIQUE_OTHER = 9,
  UNRECOGNIZED = -1,
}

export function evidenceTechniqueFromJSON(object: any): EvidenceTechnique {
  switch (object) {
    case 0:
    case "EVIDENCE_TECHNIQUE_SOURCE_CODE_ANALYSIS":
      return EvidenceTechnique.EVIDENCE_TECHNIQUE_SOURCE_CODE_ANALYSIS;
    case 1:
    case "EVIDENCE_TECHNIQUE_BINARY_ANALYSIS":
      return EvidenceTechnique.EVIDENCE_TECHNIQUE_BINARY_ANALYSIS;
    case 2:
    case "EVIDENCE_TECHNIQUE_MANIFEST_ANALYSIS":
      return EvidenceTechnique.EVIDENCE_TECHNIQUE_MANIFEST_ANALYSIS;
    case 3:
    case "EVIDENCE_TECHNIQUE_AST_FINGERPRINT":
      return EvidenceTechnique.EVIDENCE_TECHNIQUE_AST_FINGERPRINT;
    case 4:
    case "EVIDENCE_TECHNIQUE_HASH_COMPARISON":
      return EvidenceTechnique.EVIDENCE_TECHNIQUE_HASH_COMPARISON;
    case 5:
    case "EVIDENCE_TECHNIQUE_INSTRUMENTATION":
      return EvidenceTechnique.EVIDENCE_TECHNIQUE_INSTRUMENTATION;
    case 6:
    case "EVIDENCE_TECHNIQUE_DYNAMIC_ANALYSIS":
      return EvidenceTechnique.EVIDENCE_TECHNIQUE_DYNAMIC_ANALYSIS;
    case 7:
    case "EVIDENCE_TECHNIQUE_FILENAME":
      return EvidenceTechnique.EVIDENCE_TECHNIQUE_FILENAME;
    case 8:
    case "EVIDENCE_TECHNIQUE_ATTESTATION":
      return EvidenceTechnique.EVIDENCE_TECHNIQUE_ATTESTATION;
    case 9:
    case "EVIDENCE_TECHNIQUE_OTHER":
      return EvidenceTechnique.EVIDENCE_TECHNIQUE_OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EvidenceTechnique.UNRECOGNIZED;
  }
}

export function evidenceTechniqueToJSON(object: EvidenceTechnique): string {
  switch (object) {
    case EvidenceTechnique.EVIDENCE_TECHNIQUE_SOURCE_CODE_ANALYSIS:
      return "EVIDENCE_TECHNIQUE_SOURCE_CODE_ANALYSIS";
    case EvidenceTechnique.EVIDENCE_TECHNIQUE_BINARY_ANALYSIS:
      return "EVIDENCE_TECHNIQUE_BINARY_ANALYSIS";
    case EvidenceTechnique.EVIDENCE_TECHNIQUE_MANIFEST_ANALYSIS:
      return "EVIDENCE_TECHNIQUE_MANIFEST_ANALYSIS";
    case EvidenceTechnique.EVIDENCE_TECHNIQUE_AST_FINGERPRINT:
      return "EVIDENCE_TECHNIQUE_AST_FINGERPRINT";
    case EvidenceTechnique.EVIDENCE_TECHNIQUE_HASH_COMPARISON:
      return "EVIDENCE_TECHNIQUE_HASH_COMPARISON";
    case EvidenceTechnique.EVIDENCE_TECHNIQUE_INSTRUMENTATION:
      return "EVIDENCE_TECHNIQUE_INSTRUMENTATION";
    case EvidenceTechnique.EVIDENCE_TECHNIQUE_DYNAMIC_ANALYSIS:
      return "EVIDENCE_TECHNIQUE_DYNAMIC_ANALYSIS";
    case EvidenceTechnique.EVIDENCE_TECHNIQUE_FILENAME:
      return "EVIDENCE_TECHNIQUE_FILENAME";
    case EvidenceTechnique.EVIDENCE_TECHNIQUE_ATTESTATION:
      return "EVIDENCE_TECHNIQUE_ATTESTATION";
    case EvidenceTechnique.EVIDENCE_TECHNIQUE_OTHER:
      return "EVIDENCE_TECHNIQUE_OTHER";
    case EvidenceTechnique.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Textual representation of the severity of the vulnerability adopted by the analysis method. If the analysis method uses values other than what is provided, the user is expected to translate appropriately. */
export enum Severity {
  /**
   * SEVERITY_UNKNOWN - The severity is not known
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `unknown` is our fallback, doubling `unspecified`
   */
  SEVERITY_UNKNOWN = 0,
  /** SEVERITY_CRITICAL - Critical severity */
  SEVERITY_CRITICAL = 1,
  /** SEVERITY_HIGH - High severity */
  SEVERITY_HIGH = 2,
  /** SEVERITY_MEDIUM - Medium severity */
  SEVERITY_MEDIUM = 3,
  /** SEVERITY_LOW - Low severity */
  SEVERITY_LOW = 4,
  /** SEVERITY_INFO - Informational warning. */
  SEVERITY_INFO = 5,
  /** SEVERITY_NONE - None */
  SEVERITY_NONE = 6,
  UNRECOGNIZED = -1,
}

export function severityFromJSON(object: any): Severity {
  switch (object) {
    case 0:
    case "SEVERITY_UNKNOWN":
      return Severity.SEVERITY_UNKNOWN;
    case 1:
    case "SEVERITY_CRITICAL":
      return Severity.SEVERITY_CRITICAL;
    case 2:
    case "SEVERITY_HIGH":
      return Severity.SEVERITY_HIGH;
    case 3:
    case "SEVERITY_MEDIUM":
      return Severity.SEVERITY_MEDIUM;
    case 4:
    case "SEVERITY_LOW":
      return Severity.SEVERITY_LOW;
    case 5:
    case "SEVERITY_INFO":
      return Severity.SEVERITY_INFO;
    case 6:
    case "SEVERITY_NONE":
      return Severity.SEVERITY_NONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Severity.UNRECOGNIZED;
  }
}

export function severityToJSON(object: Severity): string {
  switch (object) {
    case Severity.SEVERITY_UNKNOWN:
      return "SEVERITY_UNKNOWN";
    case Severity.SEVERITY_CRITICAL:
      return "SEVERITY_CRITICAL";
    case Severity.SEVERITY_HIGH:
      return "SEVERITY_HIGH";
    case Severity.SEVERITY_MEDIUM:
      return "SEVERITY_MEDIUM";
    case Severity.SEVERITY_LOW:
      return "SEVERITY_LOW";
    case Severity.SEVERITY_INFO:
      return "SEVERITY_INFO";
    case Severity.SEVERITY_NONE:
      return "SEVERITY_NONE";
    case Severity.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ScoreMethod {
  /**
   * SCORE_METHOD_NULL - An undefined score method
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   */
  SCORE_METHOD_NULL = 0,
  /** SCORE_METHOD_CVSSV2 - Common Vulnerability Scoring System v2 - https://www.first.org/cvss/v2/ */
  SCORE_METHOD_CVSSV2 = 1,
  /** SCORE_METHOD_CVSSV3 - Common Vulnerability Scoring System v3 - https://www.first.org/cvss/v3-0/ */
  SCORE_METHOD_CVSSV3 = 2,
  /** SCORE_METHOD_CVSSV31 - Common Vulnerability Scoring System v3.1 - https://www.first.org/cvss/v3-1/ */
  SCORE_METHOD_CVSSV31 = 3,
  /** SCORE_METHOD_OWASP - OWASP Risk Rating Methodology - https://owasp.org/www-community/OWASP_Risk_Rating_Methodology */
  SCORE_METHOD_OWASP = 4,
  /** SCORE_METHOD_OTHER - Other scoring method */
  SCORE_METHOD_OTHER = 5,
  /** SCORE_METHOD_CVSSV4 - Common Vulnerability Scoring System v4.0 - https://www.first.org/cvss/v4-0/ */
  SCORE_METHOD_CVSSV4 = 6,
  /** SCORE_METHOD_SSVC - Stakeholder Specific Vulnerability Categorization (all versions) - https://github.com/CERTCC/SSVC */
  SCORE_METHOD_SSVC = 7,
  UNRECOGNIZED = -1,
}

export function scoreMethodFromJSON(object: any): ScoreMethod {
  switch (object) {
    case 0:
    case "SCORE_METHOD_NULL":
      return ScoreMethod.SCORE_METHOD_NULL;
    case 1:
    case "SCORE_METHOD_CVSSV2":
      return ScoreMethod.SCORE_METHOD_CVSSV2;
    case 2:
    case "SCORE_METHOD_CVSSV3":
      return ScoreMethod.SCORE_METHOD_CVSSV3;
    case 3:
    case "SCORE_METHOD_CVSSV31":
      return ScoreMethod.SCORE_METHOD_CVSSV31;
    case 4:
    case "SCORE_METHOD_OWASP":
      return ScoreMethod.SCORE_METHOD_OWASP;
    case 5:
    case "SCORE_METHOD_OTHER":
      return ScoreMethod.SCORE_METHOD_OTHER;
    case 6:
    case "SCORE_METHOD_CVSSV4":
      return ScoreMethod.SCORE_METHOD_CVSSV4;
    case 7:
    case "SCORE_METHOD_SSVC":
      return ScoreMethod.SCORE_METHOD_SSVC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ScoreMethod.UNRECOGNIZED;
  }
}

export function scoreMethodToJSON(object: ScoreMethod): string {
  switch (object) {
    case ScoreMethod.SCORE_METHOD_NULL:
      return "SCORE_METHOD_NULL";
    case ScoreMethod.SCORE_METHOD_CVSSV2:
      return "SCORE_METHOD_CVSSV2";
    case ScoreMethod.SCORE_METHOD_CVSSV3:
      return "SCORE_METHOD_CVSSV3";
    case ScoreMethod.SCORE_METHOD_CVSSV31:
      return "SCORE_METHOD_CVSSV31";
    case ScoreMethod.SCORE_METHOD_OWASP:
      return "SCORE_METHOD_OWASP";
    case ScoreMethod.SCORE_METHOD_OTHER:
      return "SCORE_METHOD_OTHER";
    case ScoreMethod.SCORE_METHOD_CVSSV4:
      return "SCORE_METHOD_CVSSV4";
    case ScoreMethod.SCORE_METHOD_SSVC:
      return "SCORE_METHOD_SSVC";
    case ScoreMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ImpactAnalysisState {
  /**
   * IMPACT_ANALYSIS_STATE_NULL - An undefined impact analysis state
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   */
  IMPACT_ANALYSIS_STATE_NULL = 0,
  /** IMPACT_ANALYSIS_STATE_RESOLVED - The vulnerability has been remediated. */
  IMPACT_ANALYSIS_STATE_RESOLVED = 1,
  /** IMPACT_ANALYSIS_STATE_RESOLVED_WITH_PEDIGREE - The vulnerability has been remediated, and evidence of the changes is provided in the affected components pedigree containing verifiable commit history and/or diff(s). */
  IMPACT_ANALYSIS_STATE_RESOLVED_WITH_PEDIGREE = 2,
  /** IMPACT_ANALYSIS_STATE_EXPLOITABLE - The vulnerability may be directly or indirectly exploitable. */
  IMPACT_ANALYSIS_STATE_EXPLOITABLE = 3,
  /** IMPACT_ANALYSIS_STATE_IN_TRIAGE - The vulnerability is being investigated. */
  IMPACT_ANALYSIS_STATE_IN_TRIAGE = 4,
  /** IMPACT_ANALYSIS_STATE_FALSE_POSITIVE - The vulnerability is not specific to the component or service and was falsely identified or associated. */
  IMPACT_ANALYSIS_STATE_FALSE_POSITIVE = 5,
  /** IMPACT_ANALYSIS_STATE_NOT_AFFECTED - The component or service is not affected by the vulnerability. Justification should be specified for all not_affected cases. */
  IMPACT_ANALYSIS_STATE_NOT_AFFECTED = 6,
  UNRECOGNIZED = -1,
}

export function impactAnalysisStateFromJSON(object: any): ImpactAnalysisState {
  switch (object) {
    case 0:
    case "IMPACT_ANALYSIS_STATE_NULL":
      return ImpactAnalysisState.IMPACT_ANALYSIS_STATE_NULL;
    case 1:
    case "IMPACT_ANALYSIS_STATE_RESOLVED":
      return ImpactAnalysisState.IMPACT_ANALYSIS_STATE_RESOLVED;
    case 2:
    case "IMPACT_ANALYSIS_STATE_RESOLVED_WITH_PEDIGREE":
      return ImpactAnalysisState.IMPACT_ANALYSIS_STATE_RESOLVED_WITH_PEDIGREE;
    case 3:
    case "IMPACT_ANALYSIS_STATE_EXPLOITABLE":
      return ImpactAnalysisState.IMPACT_ANALYSIS_STATE_EXPLOITABLE;
    case 4:
    case "IMPACT_ANALYSIS_STATE_IN_TRIAGE":
      return ImpactAnalysisState.IMPACT_ANALYSIS_STATE_IN_TRIAGE;
    case 5:
    case "IMPACT_ANALYSIS_STATE_FALSE_POSITIVE":
      return ImpactAnalysisState.IMPACT_ANALYSIS_STATE_FALSE_POSITIVE;
    case 6:
    case "IMPACT_ANALYSIS_STATE_NOT_AFFECTED":
      return ImpactAnalysisState.IMPACT_ANALYSIS_STATE_NOT_AFFECTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImpactAnalysisState.UNRECOGNIZED;
  }
}

export function impactAnalysisStateToJSON(object: ImpactAnalysisState): string {
  switch (object) {
    case ImpactAnalysisState.IMPACT_ANALYSIS_STATE_NULL:
      return "IMPACT_ANALYSIS_STATE_NULL";
    case ImpactAnalysisState.IMPACT_ANALYSIS_STATE_RESOLVED:
      return "IMPACT_ANALYSIS_STATE_RESOLVED";
    case ImpactAnalysisState.IMPACT_ANALYSIS_STATE_RESOLVED_WITH_PEDIGREE:
      return "IMPACT_ANALYSIS_STATE_RESOLVED_WITH_PEDIGREE";
    case ImpactAnalysisState.IMPACT_ANALYSIS_STATE_EXPLOITABLE:
      return "IMPACT_ANALYSIS_STATE_EXPLOITABLE";
    case ImpactAnalysisState.IMPACT_ANALYSIS_STATE_IN_TRIAGE:
      return "IMPACT_ANALYSIS_STATE_IN_TRIAGE";
    case ImpactAnalysisState.IMPACT_ANALYSIS_STATE_FALSE_POSITIVE:
      return "IMPACT_ANALYSIS_STATE_FALSE_POSITIVE";
    case ImpactAnalysisState.IMPACT_ANALYSIS_STATE_NOT_AFFECTED:
      return "IMPACT_ANALYSIS_STATE_NOT_AFFECTED";
    case ImpactAnalysisState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ImpactAnalysisJustification {
  /**
   * IMPACT_ANALYSIS_JUSTIFICATION_NULL - An undefined impact analysis justification
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   */
  IMPACT_ANALYSIS_JUSTIFICATION_NULL = 0,
  /** IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_PRESENT - The code has been removed or tree-shaked. */
  IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_PRESENT = 1,
  /** IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_REACHABLE - The vulnerable code is not invoked at runtime. */
  IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_REACHABLE = 2,
  /** IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_CONFIGURATION - Exploitability requires a configurable option to be set/unset. */
  IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_CONFIGURATION = 3,
  /** IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_DEPENDENCY - Exploitability requires a dependency that is not present. */
  IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_DEPENDENCY = 4,
  /** IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_ENVIRONMENT - Exploitability requires a certain environment which is not present. */
  IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_ENVIRONMENT = 5,
  /** IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_COMPILER - Exploitability requires a compiler flag to be set/unset. */
  IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_COMPILER = 6,
  /** IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_RUNTIME - Exploits are prevented at runtime. */
  IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_RUNTIME = 7,
  /** IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_PERIMETER - Attacks are blocked at physical, logical, or network perimeter. */
  IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_PERIMETER = 8,
  /** IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_MITIGATING_CONTROL - Preventative measures have been implemented that reduce the likelihood and/or impact of the vulnerability. */
  IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_MITIGATING_CONTROL = 9,
  UNRECOGNIZED = -1,
}

export function impactAnalysisJustificationFromJSON(object: any): ImpactAnalysisJustification {
  switch (object) {
    case 0:
    case "IMPACT_ANALYSIS_JUSTIFICATION_NULL":
      return ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_NULL;
    case 1:
    case "IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_PRESENT":
      return ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_PRESENT;
    case 2:
    case "IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_REACHABLE":
      return ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_REACHABLE;
    case 3:
    case "IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_CONFIGURATION":
      return ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_CONFIGURATION;
    case 4:
    case "IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_DEPENDENCY":
      return ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_DEPENDENCY;
    case 5:
    case "IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_ENVIRONMENT":
      return ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_ENVIRONMENT;
    case 6:
    case "IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_COMPILER":
      return ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_COMPILER;
    case 7:
    case "IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_RUNTIME":
      return ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_RUNTIME;
    case 8:
    case "IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_PERIMETER":
      return ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_PERIMETER;
    case 9:
    case "IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_MITIGATING_CONTROL":
      return ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_MITIGATING_CONTROL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ImpactAnalysisJustification.UNRECOGNIZED;
  }
}

export function impactAnalysisJustificationToJSON(object: ImpactAnalysisJustification): string {
  switch (object) {
    case ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_NULL:
      return "IMPACT_ANALYSIS_JUSTIFICATION_NULL";
    case ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_PRESENT:
      return "IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_PRESENT";
    case ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_REACHABLE:
      return "IMPACT_ANALYSIS_JUSTIFICATION_CODE_NOT_REACHABLE";
    case ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_CONFIGURATION:
      return "IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_CONFIGURATION";
    case ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_DEPENDENCY:
      return "IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_DEPENDENCY";
    case ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_ENVIRONMENT:
      return "IMPACT_ANALYSIS_JUSTIFICATION_REQUIRES_ENVIRONMENT";
    case ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_COMPILER:
      return "IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_COMPILER";
    case ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_RUNTIME:
      return "IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_RUNTIME";
    case ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_PERIMETER:
      return "IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_AT_PERIMETER";
    case ImpactAnalysisJustification.IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_MITIGATING_CONTROL:
      return "IMPACT_ANALYSIS_JUSTIFICATION_PROTECTED_BY_MITIGATING_CONTROL";
    case ImpactAnalysisJustification.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum VulnerabilityResponse {
  /**
   * VULNERABILITY_RESPONSE_NULL - unspecified value
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `null` is our fallback, doubling `unspecified`
   */
  VULNERABILITY_RESPONSE_NULL = 0,
  /** VULNERABILITY_RESPONSE_CAN_NOT_FIX - Can not fix */
  VULNERABILITY_RESPONSE_CAN_NOT_FIX = 1,
  /** VULNERABILITY_RESPONSE_WILL_NOT_FIX - Will not fix */
  VULNERABILITY_RESPONSE_WILL_NOT_FIX = 2,
  /** VULNERABILITY_RESPONSE_UPDATE - Update to a different revision or release */
  VULNERABILITY_RESPONSE_UPDATE = 3,
  /** VULNERABILITY_RESPONSE_ROLLBACK - Revert to a previous revision or release */
  VULNERABILITY_RESPONSE_ROLLBACK = 4,
  /** VULNERABILITY_RESPONSE_WORKAROUND_AVAILABLE - There is a workaround available */
  VULNERABILITY_RESPONSE_WORKAROUND_AVAILABLE = 5,
  UNRECOGNIZED = -1,
}

export function vulnerabilityResponseFromJSON(object: any): VulnerabilityResponse {
  switch (object) {
    case 0:
    case "VULNERABILITY_RESPONSE_NULL":
      return VulnerabilityResponse.VULNERABILITY_RESPONSE_NULL;
    case 1:
    case "VULNERABILITY_RESPONSE_CAN_NOT_FIX":
      return VulnerabilityResponse.VULNERABILITY_RESPONSE_CAN_NOT_FIX;
    case 2:
    case "VULNERABILITY_RESPONSE_WILL_NOT_FIX":
      return VulnerabilityResponse.VULNERABILITY_RESPONSE_WILL_NOT_FIX;
    case 3:
    case "VULNERABILITY_RESPONSE_UPDATE":
      return VulnerabilityResponse.VULNERABILITY_RESPONSE_UPDATE;
    case 4:
    case "VULNERABILITY_RESPONSE_ROLLBACK":
      return VulnerabilityResponse.VULNERABILITY_RESPONSE_ROLLBACK;
    case 5:
    case "VULNERABILITY_RESPONSE_WORKAROUND_AVAILABLE":
      return VulnerabilityResponse.VULNERABILITY_RESPONSE_WORKAROUND_AVAILABLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VulnerabilityResponse.UNRECOGNIZED;
  }
}

export function vulnerabilityResponseToJSON(object: VulnerabilityResponse): string {
  switch (object) {
    case VulnerabilityResponse.VULNERABILITY_RESPONSE_NULL:
      return "VULNERABILITY_RESPONSE_NULL";
    case VulnerabilityResponse.VULNERABILITY_RESPONSE_CAN_NOT_FIX:
      return "VULNERABILITY_RESPONSE_CAN_NOT_FIX";
    case VulnerabilityResponse.VULNERABILITY_RESPONSE_WILL_NOT_FIX:
      return "VULNERABILITY_RESPONSE_WILL_NOT_FIX";
    case VulnerabilityResponse.VULNERABILITY_RESPONSE_UPDATE:
      return "VULNERABILITY_RESPONSE_UPDATE";
    case VulnerabilityResponse.VULNERABILITY_RESPONSE_ROLLBACK:
      return "VULNERABILITY_RESPONSE_ROLLBACK";
    case VulnerabilityResponse.VULNERABILITY_RESPONSE_WORKAROUND_AVAILABLE:
      return "VULNERABILITY_RESPONSE_WORKAROUND_AVAILABLE";
    case VulnerabilityResponse.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The vulnerability status of a given version or range of versions of a product. The statuses 'affected' and 'unaffected' indicate that the version is affected or unaffected by the vulnerability. The status 'unknown' indicates that it is unknown or unspecified whether the given version is affected. There can be many reasons for an 'unknown' status, including that an investigation has not been undertaken or that a vendor has not disclosed the status. */
export enum VulnerabilityAffectedStatus {
  /**
   * VULNERABILITY_AFFECTED_STATUS_UNKNOWN - It is unknown (or unspecified) whether the given version is affected.
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- `unknown` is our fallback, doubling `unspecified`
   */
  VULNERABILITY_AFFECTED_STATUS_UNKNOWN = 0,
  /** VULNERABILITY_AFFECTED_STATUS_AFFECTED - The version is affected by the vulnerability. */
  VULNERABILITY_AFFECTED_STATUS_AFFECTED = 1,
  /** VULNERABILITY_AFFECTED_STATUS_NOT_AFFECTED - The version is not affected by the vulnerability. */
  VULNERABILITY_AFFECTED_STATUS_NOT_AFFECTED = 2,
  UNRECOGNIZED = -1,
}

export function vulnerabilityAffectedStatusFromJSON(object: any): VulnerabilityAffectedStatus {
  switch (object) {
    case 0:
    case "VULNERABILITY_AFFECTED_STATUS_UNKNOWN":
      return VulnerabilityAffectedStatus.VULNERABILITY_AFFECTED_STATUS_UNKNOWN;
    case 1:
    case "VULNERABILITY_AFFECTED_STATUS_AFFECTED":
      return VulnerabilityAffectedStatus.VULNERABILITY_AFFECTED_STATUS_AFFECTED;
    case 2:
    case "VULNERABILITY_AFFECTED_STATUS_NOT_AFFECTED":
      return VulnerabilityAffectedStatus.VULNERABILITY_AFFECTED_STATUS_NOT_AFFECTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VulnerabilityAffectedStatus.UNRECOGNIZED;
  }
}

export function vulnerabilityAffectedStatusToJSON(object: VulnerabilityAffectedStatus): string {
  switch (object) {
    case VulnerabilityAffectedStatus.VULNERABILITY_AFFECTED_STATUS_UNKNOWN:
      return "VULNERABILITY_AFFECTED_STATUS_UNKNOWN";
    case VulnerabilityAffectedStatus.VULNERABILITY_AFFECTED_STATUS_AFFECTED:
      return "VULNERABILITY_AFFECTED_STATUS_AFFECTED";
    case VulnerabilityAffectedStatus.VULNERABILITY_AFFECTED_STATUS_NOT_AFFECTED:
      return "VULNERABILITY_AFFECTED_STATUS_NOT_AFFECTED";
    case VulnerabilityAffectedStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ModelParameterApproachType {
  /**
   * MODEL_PARAMETER_APPROACH_TYPE_SUPERVISED - buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error, it shall be fixed with v2.0 of this very schema
   * Supervised machine learning involves training an algorithm on labeled data to predict or classify new data based on the patterns learned from the labeled examples.
   */
  MODEL_PARAMETER_APPROACH_TYPE_SUPERVISED = 0,
  /** MODEL_PARAMETER_APPROACH_TYPE_UNSUPERVISED - Unsupervised machine learning involves training algorithms on unlabeled data to discover patterns, structures, or relationships without explicit guidance, allowing the model to identify inherent structures or clusters within the data. */
  MODEL_PARAMETER_APPROACH_TYPE_UNSUPERVISED = 1,
  /** MODEL_PARAMETER_APPROACH_TYPE_REINFORCED_LEARNING - Reinforcement learning is a type of machine learning where an agent learns to make decisions by interacting with an environment to maximize cumulative rewards, through trial and error. */
  MODEL_PARAMETER_APPROACH_TYPE_REINFORCED_LEARNING = 2,
  /** MODEL_PARAMETER_APPROACH_TYPE_SEMI_SUPERVISED - Semi-supervised machine learning utilizes a combination of labeled and unlabeled data during training to improve model performance, leveraging the benefits of both supervised and unsupervised learning techniques. */
  MODEL_PARAMETER_APPROACH_TYPE_SEMI_SUPERVISED = 3,
  /** MODEL_PARAMETER_APPROACH_TYPE_SELF_SUPERVISED - Self-supervised machine learning involves training models to predict parts of the input data from other parts of the same data, without requiring external labels, enabling learning from large amounts of unlabeled data. */
  MODEL_PARAMETER_APPROACH_TYPE_SELF_SUPERVISED = 4,
  UNRECOGNIZED = -1,
}

export function modelParameterApproachTypeFromJSON(object: any): ModelParameterApproachType {
  switch (object) {
    case 0:
    case "MODEL_PARAMETER_APPROACH_TYPE_SUPERVISED":
      return ModelParameterApproachType.MODEL_PARAMETER_APPROACH_TYPE_SUPERVISED;
    case 1:
    case "MODEL_PARAMETER_APPROACH_TYPE_UNSUPERVISED":
      return ModelParameterApproachType.MODEL_PARAMETER_APPROACH_TYPE_UNSUPERVISED;
    case 2:
    case "MODEL_PARAMETER_APPROACH_TYPE_REINFORCED_LEARNING":
      return ModelParameterApproachType.MODEL_PARAMETER_APPROACH_TYPE_REINFORCED_LEARNING;
    case 3:
    case "MODEL_PARAMETER_APPROACH_TYPE_SEMI_SUPERVISED":
      return ModelParameterApproachType.MODEL_PARAMETER_APPROACH_TYPE_SEMI_SUPERVISED;
    case 4:
    case "MODEL_PARAMETER_APPROACH_TYPE_SELF_SUPERVISED":
      return ModelParameterApproachType.MODEL_PARAMETER_APPROACH_TYPE_SELF_SUPERVISED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ModelParameterApproachType.UNRECOGNIZED;
  }
}

export function modelParameterApproachTypeToJSON(object: ModelParameterApproachType): string {
  switch (object) {
    case ModelParameterApproachType.MODEL_PARAMETER_APPROACH_TYPE_SUPERVISED:
      return "MODEL_PARAMETER_APPROACH_TYPE_SUPERVISED";
    case ModelParameterApproachType.MODEL_PARAMETER_APPROACH_TYPE_UNSUPERVISED:
      return "MODEL_PARAMETER_APPROACH_TYPE_UNSUPERVISED";
    case ModelParameterApproachType.MODEL_PARAMETER_APPROACH_TYPE_REINFORCED_LEARNING:
      return "MODEL_PARAMETER_APPROACH_TYPE_REINFORCED_LEARNING";
    case ModelParameterApproachType.MODEL_PARAMETER_APPROACH_TYPE_SEMI_SUPERVISED:
      return "MODEL_PARAMETER_APPROACH_TYPE_SEMI_SUPERVISED";
    case ModelParameterApproachType.MODEL_PARAMETER_APPROACH_TYPE_SELF_SUPERVISED:
      return "MODEL_PARAMETER_APPROACH_TYPE_SELF_SUPERVISED";
    case ModelParameterApproachType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ComponentDataType {
  /**
   * COMPONENT_DATA_TYPE_SOURCE_CODE - Any type of code, code snippet, or data-as-code
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error, it shall be fixed with v2.0 of this very schema
   */
  COMPONENT_DATA_TYPE_SOURCE_CODE = 0,
  /** COMPONENT_DATA_TYPE_CONFIGURATION - Parameters or settings that may be used by other components. */
  COMPONENT_DATA_TYPE_CONFIGURATION = 1,
  /** COMPONENT_DATA_TYPE_DATASET - A collection of data. */
  COMPONENT_DATA_TYPE_DATASET = 2,
  /** COMPONENT_DATA_TYPE_DEFINITION - Data that can be used to create new instances of what the definition defines. */
  COMPONENT_DATA_TYPE_DEFINITION = 3,
  /** COMPONENT_DATA_TYPE_OTHER - Any other type of data that does not fit into existing definitions. */
  COMPONENT_DATA_TYPE_OTHER = 4,
  UNRECOGNIZED = -1,
}

export function componentDataTypeFromJSON(object: any): ComponentDataType {
  switch (object) {
    case 0:
    case "COMPONENT_DATA_TYPE_SOURCE_CODE":
      return ComponentDataType.COMPONENT_DATA_TYPE_SOURCE_CODE;
    case 1:
    case "COMPONENT_DATA_TYPE_CONFIGURATION":
      return ComponentDataType.COMPONENT_DATA_TYPE_CONFIGURATION;
    case 2:
    case "COMPONENT_DATA_TYPE_DATASET":
      return ComponentDataType.COMPONENT_DATA_TYPE_DATASET;
    case 3:
    case "COMPONENT_DATA_TYPE_DEFINITION":
      return ComponentDataType.COMPONENT_DATA_TYPE_DEFINITION;
    case 4:
    case "COMPONENT_DATA_TYPE_OTHER":
      return ComponentDataType.COMPONENT_DATA_TYPE_OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComponentDataType.UNRECOGNIZED;
  }
}

export function componentDataTypeToJSON(object: ComponentDataType): string {
  switch (object) {
    case ComponentDataType.COMPONENT_DATA_TYPE_SOURCE_CODE:
      return "COMPONENT_DATA_TYPE_SOURCE_CODE";
    case ComponentDataType.COMPONENT_DATA_TYPE_CONFIGURATION:
      return "COMPONENT_DATA_TYPE_CONFIGURATION";
    case ComponentDataType.COMPONENT_DATA_TYPE_DATASET:
      return "COMPONENT_DATA_TYPE_DATASET";
    case ComponentDataType.COMPONENT_DATA_TYPE_DEFINITION:
      return "COMPONENT_DATA_TYPE_DEFINITION";
    case ComponentDataType.COMPONENT_DATA_TYPE_OTHER:
      return "COMPONENT_DATA_TYPE_OTHER";
    case ComponentDataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TaskType {
  /**
   * TASK_TYPE_COPY - A task that copies software or data used to accomplish other tasks in the workflow.
   * buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema
   */
  TASK_TYPE_COPY = 0,
  /** TASK_TYPE_CLONE - A task that clones a software repository into the workflow in order to retrieve its source code or data for use in a build step. */
  TASK_TYPE_CLONE = 1,
  /** TASK_TYPE_LINT - A task that checks source code for programmatic and stylistic errors. */
  TASK_TYPE_LINT = 2,
  /** TASK_TYPE_SCAN - A task that performs a scan against source code, or built or deployed components and services. Scans are typically run to gather or test for security vulnerabilities or policy compliance. */
  TASK_TYPE_SCAN = 3,
  /** TASK_TYPE_MERGE - A task that merges changes or fixes into source code prior to a build step in the workflow. */
  TASK_TYPE_MERGE = 4,
  /** TASK_TYPE_BUILD - A task that builds the source code, dependencies and/or data into an artifact that can be deployed to and executed on target systems. */
  TASK_TYPE_BUILD = 5,
  /** TASK_TYPE_TEST - A task that verifies the functionality of a component or service. */
  TASK_TYPE_TEST = 6,
  /** TASK_TYPE_DELIVER - A task that delivers a built artifact to one or more target repositories or storage systems. */
  TASK_TYPE_DELIVER = 7,
  /** TASK_TYPE_DEPLOY - A task that deploys a built artifact for execution on one or more target systems. */
  TASK_TYPE_DEPLOY = 8,
  /** TASK_TYPE_RELEASE - A task that releases a built, versioned artifact to a target repository or distribution system. */
  TASK_TYPE_RELEASE = 9,
  /** TASK_TYPE_CLEAN - A task that cleans unnecessary tools, build artifacts and/or data from workflow storage. */
  TASK_TYPE_CLEAN = 10,
  /** TASK_TYPE_OTHER - A workflow task that does not match current task type definitions. */
  TASK_TYPE_OTHER = 11,
  UNRECOGNIZED = -1,
}

export function taskTypeFromJSON(object: any): TaskType {
  switch (object) {
    case 0:
    case "TASK_TYPE_COPY":
      return TaskType.TASK_TYPE_COPY;
    case 1:
    case "TASK_TYPE_CLONE":
      return TaskType.TASK_TYPE_CLONE;
    case 2:
    case "TASK_TYPE_LINT":
      return TaskType.TASK_TYPE_LINT;
    case 3:
    case "TASK_TYPE_SCAN":
      return TaskType.TASK_TYPE_SCAN;
    case 4:
    case "TASK_TYPE_MERGE":
      return TaskType.TASK_TYPE_MERGE;
    case 5:
    case "TASK_TYPE_BUILD":
      return TaskType.TASK_TYPE_BUILD;
    case 6:
    case "TASK_TYPE_TEST":
      return TaskType.TASK_TYPE_TEST;
    case 7:
    case "TASK_TYPE_DELIVER":
      return TaskType.TASK_TYPE_DELIVER;
    case 8:
    case "TASK_TYPE_DEPLOY":
      return TaskType.TASK_TYPE_DEPLOY;
    case 9:
    case "TASK_TYPE_RELEASE":
      return TaskType.TASK_TYPE_RELEASE;
    case 10:
    case "TASK_TYPE_CLEAN":
      return TaskType.TASK_TYPE_CLEAN;
    case 11:
    case "TASK_TYPE_OTHER":
      return TaskType.TASK_TYPE_OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TaskType.UNRECOGNIZED;
  }
}

export function taskTypeToJSON(object: TaskType): string {
  switch (object) {
    case TaskType.TASK_TYPE_COPY:
      return "TASK_TYPE_COPY";
    case TaskType.TASK_TYPE_CLONE:
      return "TASK_TYPE_CLONE";
    case TaskType.TASK_TYPE_LINT:
      return "TASK_TYPE_LINT";
    case TaskType.TASK_TYPE_SCAN:
      return "TASK_TYPE_SCAN";
    case TaskType.TASK_TYPE_MERGE:
      return "TASK_TYPE_MERGE";
    case TaskType.TASK_TYPE_BUILD:
      return "TASK_TYPE_BUILD";
    case TaskType.TASK_TYPE_TEST:
      return "TASK_TYPE_TEST";
    case TaskType.TASK_TYPE_DELIVER:
      return "TASK_TYPE_DELIVER";
    case TaskType.TASK_TYPE_DEPLOY:
      return "TASK_TYPE_DEPLOY";
    case TaskType.TASK_TYPE_RELEASE:
      return "TASK_TYPE_RELEASE";
    case TaskType.TASK_TYPE_CLEAN:
      return "TASK_TYPE_CLEAN";
    case TaskType.TASK_TYPE_OTHER:
      return "TASK_TYPE_OTHER";
    case TaskType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Specifies attributes of the text */
export interface AttachedText {
  /** Specifies the format and nature of the data being attached, helping systems correctly interpret and process the content. Common content type examples include `application/json` for JSON data and `text/plain` for plain text documents. [RFC 2045 section 5.1](https://www.ietf.org/rfc/rfc2045.html#section-5.1) outlines the structure and use of content types. For a comprehensive list of registered content types, refer to the [IANA media types registry](https://www.iana.org/assignments/media-types/media-types.xhtml). */
  contentType?:
    | string
    | undefined;
  /** Specifies the optional encoding the text is represented in */
  encoding?:
    | string
    | undefined;
  /** SimpleContent value of element. Proactive controls such as input validation and sanitization should be employed to prevent misuse of attachment text. */
  value: string;
}

export interface Bom {
  /** The version of the CycloneDX specification a BOM is written to (starting at version 1.3) */
  specVersion: string;
  /** The version allows component publishers/authors to make changes to existing BOMs to update various aspects of the document such as description or licenses. When a system is presented with multiple BOMs for the same component, the system should use the most recent version of the BOM. The default version is '1' and should be incremented for each version of the BOM that is published. Each version of a component should have a unique BOM and if no changes are made to the BOMs, then each BOM will have a version of '1'. */
  version?:
    | number
    | undefined;
  /** Every BOM generated should have a unique serial number, even if the contents of the BOM being generated have not changed over time. The process or tool responsible for creating the BOM should create random UUID's for every BOM generated. */
  serialNumber?:
    | string
    | undefined;
  /** Provides additional information about a BOM. */
  metadata?:
    | Metadata
    | undefined;
  /** Provides the ability to document a list of components. */
  components: Component[];
  /** Provides the ability to document a list of external services. */
  services: Service[];
  /** Provides the ability to document external references related to the BOM or to the project the BOM describes. */
  externalReferences: ExternalReference[];
  /** Provides the ability to document dependency relationships. */
  dependencies: Dependency[];
  /** Compositions describe constituent parts (including components, services, and dependency relationships) and their completeness. The completeness of vulnerabilities expressed in a BOM may also be described. */
  compositions: Composition[];
  /** Vulnerabilities identified in components or services. */
  vulnerabilities: Vulnerability[];
  /** Comments made by people, organizations, or tools about any object with a bom-ref, such as components, services, vulnerabilities, or the BOM itself. Unlike inventory information, annotations may contain opinion or commentary from various stakeholders. */
  annotations: Annotation[];
  /** Specifies optional, custom, properties */
  properties: Property[];
  /** Describes how a component or service was manufactured or deployed. This is achieved through the use of formulas, workflows, tasks, and steps, which declare the precise steps to reproduce along with the observed formulas describing the steps which transpired in the manufacturing process. */
  formulation: Formula[];
  /** The list of declarations which describe the conformance to standards. Each declaration may include attestations, claims, and evidence. */
  declarations: Declarations[];
  /** A collection of reusable objects that are defined and may be used elsewhere in the BOM. */
  definitions: Definition[];
}

export interface Commit {
  /** A unique identifier of the commit. This may be version control specific. For example, Subversion uses revision numbers whereas git uses commit hashes. */
  uid?:
    | string
    | undefined;
  /** The URL to the commit. This URL will typically point to a commit in a version control system. */
  url?:
    | string
    | undefined;
  /** The author who created the changes in the commit */
  author?:
    | IdentifiableAction
    | undefined;
  /** The person who committed or pushed the commit */
  committer?:
    | IdentifiableAction
    | undefined;
  /** The text description of the contents of the commit */
  message?: string | undefined;
}

export interface Component {
  /** Specifies the type of component. For software components, classify as an application if no more specific appropriate classification is available or cannot be determined for the component. */
  type: Classification;
  /** The optional mime-type of the component. When used on file components, the mime-type can provide additional context about the kind of file being represented, such as an image, font, or executable. Some library or framework components may also have an associated mime-type. */
  mimeType?:
    | string
    | undefined;
  /** An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element. */
  bomRef?:
    | string
    | undefined;
  /** The organization that supplied the component. The supplier may often be the manufacturer but may also be a distributor or repackager. */
  supplier?:
    | OrganizationalEntity
    | undefined;
  /**
   * DEPRECATED - DO NOT USE - This will be removed in a future version - Use `.authors` or `.manufacturer` instead. The person(s) or organization(s) that authored the component
   *
   * @deprecated
   */
  author?:
    | string
    | undefined;
  /** The person(s) or organization(s) that published the component */
  publisher?:
    | string
    | undefined;
  /** The grouping name or identifier. This will often be a shortened, single name of the company or project that produced the component or the source package or domain name. Whitespace and special characters should be avoided. Examples include: apache, org.apache.commons, and apache.org. */
  group?:
    | string
    | undefined;
  /** The name of the component. This will often be a shortened, single name of the component. Examples: commons-lang3 and jquery */
  name: string;
  /** The component version. The version should ideally comply with semantic versioning but is not enforced. Version was made optional in v1.4 of the spec. For backward compatibility, it is recommended to use an empty string to represent components without version information. */
  version: string;
  /** Specifies a description for the component */
  description?:
    | string
    | undefined;
  /** Specifies the scope of the component. If a scope is not specified, SCOPE_REQUIRED scope should be assumed by the consumer of the BOM */
  scope?:
    | Scope
    | undefined;
  /** The hashes of the component. */
  hashes: Hash[];
  /** EITHER (list of SPDX licenses and/or named licenses) OR (tuple of one SPDX License Expression) */
  licenses: LicenseChoice[];
  /** An optional copyright notice informing users of the underlying claims to copyright ownership in a published work. */
  copyright?:
    | string
    | undefined;
  /** DEPRECATED - DO NOT USE. This will be removed in a future version. Specifies a well-formed CPE name. See https://nvd.nist.gov/products/cpe */
  cpe?:
    | string
    | undefined;
  /** Specifies the package-url (PURL). The purl, if specified, must be valid and conform to the specification defined at: https://github.com/package-url/purl-spec */
  purl?:
    | string
    | undefined;
  /** Specifies metadata and content for ISO-IEC 19770-2 Software Identification (SWID) Tags. */
  swid?:
    | Swid
    | undefined;
  /** DEPRECATED - DO NOT USE. This will be removed in a future version. Use the pedigree element instead to supply information on exactly how the component was modified. A boolean value indicating is the component has been modified from the original. A value of true indicates the component is a derivative of the original. A value of false indicates the component has not been modified from the original. */
  modified?:
    | boolean
    | undefined;
  /** Component pedigree is a way to document complex supply chain scenarios where components are created, distributed, modified, redistributed, combined with other components, etc. */
  pedigree?:
    | Pedigree
    | undefined;
  /** Provides the ability to document external references related to the component or to the project the component describes. */
  externalReferences: ExternalReference[];
  /** Specifies optional sub-components. This is not a dependency tree. It provides a way to specify a hierarchical representation of component assemblies, similar to system -> subsystem -> parts assembly in physical supply chains. */
  components: Component[];
  /** Specifies optional, custom, properties */
  properties: Property[];
  /** Specifies optional license and copyright evidence. */
  evidence?:
    | Evidence
    | undefined;
  /** Specifies optional release notes. */
  releaseNotes?:
    | ReleaseNotes
    | undefined;
  /** A model card describes the intended uses of a machine learning model, potential limitations, biases, ethical considerations, training parameters, datasets used to train the model, performance metrics, and other relevant data useful for ML transparency. */
  modelCard?:
    | ModelCard
    | undefined;
  /** This object SHOULD be specified for any component of type `data` and must not be specified for other component types. */
  data: ComponentData[];
  /** Cryptographic assets have properties that uniquely define them and that make them actionable for further reasoning. As an example, it makes a difference if one knows the algorithm family (e.g. AES) or the specific variant or instantiation (e.g. AES-128-GCM). This is because the security level and the algorithm primitive (authenticated encryption) is only defined by the definition of the algorithm variant. The presence of a weak cryptographic algorithm like SHA1 vs. HMAC-SHA1 also makes a difference. */
  cryptoProperties?:
    | CryptoProperties
    | undefined;
  /** The organization that created the component. Manufacturer is common in components created through automated processes. Components created through manual means may have `.authors` instead. */
  manufacturer?:
    | OrganizationalEntity
    | undefined;
  /** The person(s) who created the component. Authors are common in components created through manual processes. Components created through automated means may have `.manufacturer` instead. */
  authors: OrganizationalContact[];
  /** Textual strings that aid in discovery, search, and retrieval of the associated object. Tags often serve as a way to group or categorize similar or related objects by various attributes. Examples include "json-parser", "object-persistence", "text-to-image", "translation", and "object-detection". */
  tags: string[];
  /** Specifies the OmniBOR Artifact ID. The OmniBOR, if specified, must be valid and conform to the specification defined at: https://www.iana.org/assignments/uri-schemes/prov/gitoid */
  omniborId: string[];
  /** Specifies the Software Heritage persistent identifier (SWHID). The SWHID, if specified, must be valid and conform to the specification defined at: https://docs.softwareheritage.org/devel/swh-model/persistent-identifiers.html */
  swhid: string[];
}

/** Specifies the data flow. */
export interface DataFlow {
  /** Specifies the flow direction of the data. */
  flow: DataFlowDirection;
  /** Data classification tags data according to its type, sensitivity, and value if altered, stolen, or destroyed. */
  value: string;
  /** Name for the defined data */
  name?:
    | string
    | undefined;
  /** Short description of the data content and usage */
  description?:
    | string
    | undefined;
  /** The URI, URL, or BOM-Link of the components or services the data came in from */
  source: string[];
  /** The URI, URL, or BOM-Link of the components or services the data is sent to */
  destination: string[];
  /** Data Governance */
  governance?: DataGovernance | undefined;
}

/** Defines the direct dependencies of a component, service, or the components provided/implemented by a given component. Components or services that do not have their own dependencies must be declared as empty elements within the graph. Components or services that are not represented in the dependency graph may have unknown dependencies. It is recommended that implementations assume this to be opaque and not an indicator of an object being dependency-free. It is recommended to leverage compositions to indicate unknown dependency graphs. */
export interface Dependency {
  /** References a component or service by its bom-ref attribute */
  ref: string;
  /** The bom-ref identifiers of the components or services that are dependencies of this dependency object. */
  dependencies: Dependency[];
  /** The bom-ref identifiers of the components or services that define a given specification or standard, which are provided or implemented by this dependency object. */
  provides: string[];
}

/** The patch file (or diff) that shows changes. Refer to https://en.wikipedia.org/wiki/Diff */
export interface Diff {
  /** Specifies the optional text of the diff */
  text?:
    | AttachedText
    | undefined;
  /** Specifies the URL to the diff */
  url?: string | undefined;
}

/** External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM. */
export interface ExternalReference {
  /** Specifies the type of external reference. There are built-in types to describe common references. If a type does not exist for the reference being referred to, use the "other" type. */
  type: ExternalReferenceType;
  /** The URL to the external reference */
  url: string;
  /** An optional comment describing the external reference */
  comment?:
    | string
    | undefined;
  /** Optional integrity hashes for the external resource content */
  hashes: Hash[];
}

/** Specifies the file hash of the component */
export interface Hash {
  /** Specifies the algorithm used to create the hash */
  alg: HashAlg;
  /** SimpleContent value of element */
  value: string;
}

export interface IdentifiableAction {
  /** The timestamp in which the action occurred */
  timestamp?:
    | Date
    | undefined;
  /** The name of the individual who performed the action */
  name?:
    | string
    | undefined;
  /** The email address of the individual who performed the action */
  email?: string | undefined;
}

/** An individual issue that has been resolved. */
export interface Issue {
  /** Specifies the type of issue */
  type: IssueClassification;
  /** The identifier of the issue assigned by the source of the issue */
  id?:
    | string
    | undefined;
  /** The name of the issue */
  name?:
    | string
    | undefined;
  /** A description of the issue */
  description?:
    | string
    | undefined;
  /** The source of the issue where it is documented */
  source?:
    | Source
    | undefined;
  /** A collection of URL's for reference. Multiple URLs are allowed. Example: "https://example.com" */
  references: string[];
}

/** The source of the issue where it is documented. */
export interface Source {
  /** The name of the source. For example, "National Vulnerability Database", "NVD", and "Apache" */
  name?:
    | string
    | undefined;
  /** The url of the issue documentation as provided by the source */
  url?: string | undefined;
}

export interface LicenseChoice {
  /** A license */
  license?:
    | License
    | undefined;
  /** A valid SPDX license expression. Refer to https://spdx.org/specifications for syntax requirements */
  expression?:
    | string
    | undefined;
  /** This field must only be used when "expression" is chosen as the License object has its own acknowledgement. */
  acknowledgement?:
    | LicenseAcknowledgementEnumeration
    | undefined;
  /** This field must only be used when "expression" is chosen as the License object has its own bom_ref. */
  bomRef?: string | undefined;
}

/** Specifies the details and attributes related to a software license. It can either include a valid SPDX license identifier or a named license, along with additional properties such as license acknowledgment, comprehensive commercial licensing information, and the full text of the license. */
export interface License {
  /** A valid SPDX license identifier. If specified, this value must be one of the enumeration of valid SPDX license identifiers defined in the spdx.schema.json (or spdx.xml) subschema which is synchronized with the official SPDX license list. */
  id?:
    | string
    | undefined;
  /** The name of the license. This may include the name of a commercial or proprietary license or an open source license that may not be defined by SPDX. */
  name?:
    | string
    | undefined;
  /** Specifies the optional full text of the attachment */
  text?:
    | AttachedText
    | undefined;
  /** The URL to the attachment file. If the attachment is a license or BOM, an externalReference should also be specified for completeness. */
  url?:
    | string
    | undefined;
  /** An optional identifier which can be used to reference the license elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element. */
  bomRef?:
    | string
    | undefined;
  /** Licensing details describing the licensor/licensee, license type, renewal and expiration dates, and other important metadata */
  licensing?:
    | Licensing
    | undefined;
  /** Specifies optional, custom, properties */
  properties: Property[];
  /** Declared licenses and concluded licenses represent two different stages in the licensing process within software development. Declared licenses refer to the initial intention of the software authors regarding the licensing terms under which their code is released. On the other hand, concluded licenses are the result of a comprehensive analysis of the project's codebase to identify and confirm the actual licenses of the components used, which may differ from the initially declared licenses. While declared licenses provide an upfront indication of the licensing intentions, concluded licenses offer a more thorough understanding of the actual licensing within a project, facilitating proper compliance and risk management. Observed licenses are defined in `@.evidence.licenses`. Observed licenses form the evidence necessary to substantiate a concluded license. */
  acknowledgement?: LicenseAcknowledgementEnumeration | undefined;
}

export interface Licensing {
  /** License identifiers that may be used to manage licenses and their lifecycle */
  altIds: string[];
  /** The individual or organization that grants a license to another individual or organization */
  licensor?:
    | OrganizationalEntityOrContact
    | undefined;
  /** The individual or organization for which a license was granted to */
  licensee?:
    | OrganizationalEntityOrContact
    | undefined;
  /** The individual or organization that purchased the license */
  purchaser?:
    | OrganizationalEntityOrContact
    | undefined;
  /** The purchase order identifier the purchaser sent to a supplier or vendor to authorize a purchase */
  purchaseOrder?:
    | string
    | undefined;
  /** The type of license(s) that was granted to the licensee */
  licenseTypes: LicensingTypeEnum[];
  /** The timestamp indicating when the license was last renewed. For new purchases, this is often the purchase or acquisition date. For non-perpetual licenses or subscriptions, this is the timestamp of when the license was last renewed. */
  lastRenewal?:
    | Date
    | undefined;
  /** The timestamp indicating when the current license expires (if applicable). */
  expiration?: Date | undefined;
}

/** EITHER an organization OR an individual */
export interface OrganizationalEntityOrContact {
  /** Organization */
  organization?:
    | OrganizationalEntity
    | undefined;
  /** Individual */
  individual?: OrganizationalContact | undefined;
}

export interface Metadata {
  /** The date and time (timestamp) when the document was created. */
  timestamp?:
    | Date
    | undefined;
  /** The tool(s) used in the creation of the BOM. */
  tools?:
    | Tool
    | undefined;
  /** The person(s) who created the BOM. Authors are common in BOMs created through manual processes. BOMs created through automated means may have '.manufacturer' instead. */
  authors: OrganizationalContact[];
  /** The component that the BOM describes. */
  component?:
    | Component
    | undefined;
  /**
   * DEPRECATED - DO NOT USE - This will be removed in a future version - Use the `.component.manufacturer` instead. The organization that manufactured the component that the BOM describes.
   *
   * @deprecated
   */
  manufacture?:
    | OrganizationalEntity
    | undefined;
  /** The organization that supplied the component that the BOM describes. The supplier may often be the manufacture, but may also be a distributor or repackager. */
  supplier?:
    | OrganizationalEntity
    | undefined;
  /**
   * The license information for the BOM document. This may be different from the license(s) of the component(s) that the BOM describes.
   * EITHER (list of SPDX licenses and/or named licenses) OR (tuple of one SPDX License Expression)
   */
  licenses: LicenseChoice[];
  /** Specifies optional, custom, properties */
  properties: Property[];
  /** Lifecycles communicate the stage(s) in which data in the BOM was captured. Different types of data may be available at various phases of a lifecycle, such as the Software Development Lifecycle (SDLC), IT Asset Management (ITAM), and Software Asset Management (SAM). Thus, a BOM may include data specific to or only obtainable in a given lifecycle. */
  lifecycles: Lifecycles[];
  /** The organization that created the BOM. Manufacturer is common in BOMs created through automated processes. BOMs created through manual means may have '.authors' instead. */
  manufacturer?: OrganizationalEntity | undefined;
}

export interface Lifecycles {
  /** A pre-defined phase in the product lifecycle. */
  phase?:
    | LifecyclePhase
    | undefined;
  /** The name of the lifecycle phase */
  name?:
    | string
    | undefined;
  /** The description of the lifecycle phase */
  description?: string | undefined;
}

export interface OrganizationalContact {
  /** The name of the contact */
  name?:
    | string
    | undefined;
  /** The email address of the contact. */
  email?:
    | string
    | undefined;
  /** The phone number of the contact. */
  phone?:
    | string
    | undefined;
  /** An optional identifier which can be used to reference the object elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element. */
  bomRef?: string | undefined;
}

export interface OrganizationalEntity {
  /** The name of the organization */
  name?:
    | string
    | undefined;
  /** The URL of the organization. Multiple URLs are allowed. */
  url: string[];
  /** A contact person at the organization. Multiple contacts are allowed. */
  contact: OrganizationalContact[];
  /** An optional identifier which can be used to reference the object elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element. */
  bomRef?:
    | string
    | undefined;
  /** The physical address (location) of the organization */
  address?: PostalAddressType | undefined;
}

/** Specifies an individual patch */
export interface Patch {
  /** Specifies the purpose for the patch, including the resolution of defects, security issues, or new behavior or functionality */
  type: PatchClassification;
  /** The patch file (or diff) that show changes. Refer to https://en.wikipedia.org/wiki/Diff */
  diff?:
    | Diff
    | undefined;
  /** A collection of issues the patch resolves */
  resolves: Issue[];
}

/** Component pedigree is a way to document complex supply chain scenarios where components are created, distributed, modified, redistributed, combined with other components, etc. Pedigree supports viewing this complex chain from the beginning, the end, or anywhere in the middle. It also provides a way to document variants where the exact relation may not be known. */
export interface Pedigree {
  /** Describes zero or more components in which a component is derived from. This is commonly used to describe forks from existing projects where the forked version contains an ancestor node containing the original component it was forked from. For example, Component A is the original component. Component B is the component being used and documented in the BOM. However, Component B contains a pedigree node with a single ancestor documenting Component A - the original component from which Component B is derived from. */
  ancestors: Component[];
  /** Descendants are the exact opposite of ancestors. This provides a way to document all forks (and their forks) of an original or root component. */
  descendants: Component[];
  /** Variants describe relations where the relationship between the components is not known. For example, if Component A contains nearly identical code to Component B. They are both related, but it is unclear if one is derived from the other or if they share a common ancestor. */
  variants: Component[];
  /** A list of zero or more commits which provide a trail describing how the component deviates from an ancestor, descendant, or variant. */
  commits: Commit[];
  /** A list of zero or more patches describing how the component deviates from an ancestor, descendant, or variant. Patches may be complementary to commits or may be used in place of commits. */
  patches: Patch[];
  /** Notes, observations, and other non-structured commentary describing the component's pedigree. */
  notes?: string | undefined;
}

export interface Service {
  /** An optional identifier which can be used to reference the service elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element. */
  bomRef?:
    | string
    | undefined;
  /** The organization that provides the service. */
  provider?:
    | OrganizationalEntity
    | undefined;
  /** The grouping name, namespace, or identifier. This will often be a shortened, single name of the company or project that produced the service or domain name. Whitespace and special characters should be avoided. */
  group?:
    | string
    | undefined;
  /** The name of the service. This will often be a shortened, single name of the service. */
  name: string;
  /** The service version. */
  version?:
    | string
    | undefined;
  /** Specifies a description for the service. */
  description?:
    | string
    | undefined;
  /** The endpoint URIs of the service. Multiple endpoints are allowed. Example: "https://example.com/api/v1/ticker" */
  endpoints: string[];
  /** A boolean value indicating if the service requires authentication. A value of true indicates the service requires authentication prior to use. A value of false indicates the service does not require authentication. */
  authenticated?:
    | boolean
    | undefined;
  /** A boolean value indicating if the use of the service crosses a trust zone or boundary. A value of true indicates that by using the service, a trust boundary is crossed. A value of false indicates that by using the service, a trust boundary is not crossed. */
  xTrustBoundary?:
    | boolean
    | undefined;
  /** Specifies information about the data including the directional flow of data and the data classification. */
  data: DataFlow[];
  /** EITHER (list of SPDX licenses and/or named licenses) OR (tuple of one SPDX License Expression) */
  licenses: LicenseChoice[];
  /** Provides the ability to document external references related to the service. */
  externalReferences: ExternalReference[];
  /** Specifies optional sub-service. This is not a dependency tree. It provides a way to specify a hierarchical representation of service assemblies, similar to system -> subsystem -> parts assembly in physical supply chains. */
  services: Service[];
  /** Specifies optional, custom, properties */
  properties: Property[];
  /** Specifies optional release notes. */
  releaseNotes?:
    | ReleaseNotes
    | undefined;
  /** The name of the trust zone the service resides in. */
  trustZone?:
    | string
    | undefined;
  /** Textual strings that aid in the discovery, search, and retrieval of the associated object. Tags often serve as a way to group or categorize similar or related objects by various attributes. Examples include "json-parser", "object-persistence", "text-to-image", "translation", and "object-detection". */
  tags: string[];
}

/** Specifies metadata and content for ISO-IEC 19770-2 Software Identification (SWID) Tags. */
export interface Swid {
  /** Maps to the tagId of a SoftwareIdentity. */
  tagId: string;
  /** Maps to the name of a SoftwareIdentity. */
  name: string;
  /** Maps to the version of a SoftwareIdentity. Defaults to '0.0' if not specified. */
  version?:
    | string
    | undefined;
  /** Maps to the tagVersion of a SoftwareIdentity. Defaults to '0' if not specified. */
  tagVersion?:
    | number
    | undefined;
  /** Maps to the patch of a SoftwareIdentity. Defaults to 'false' if not specified. */
  patch?:
    | boolean
    | undefined;
  /** Specifies the full content of the SWID tag. */
  text?:
    | AttachedText
    | undefined;
  /** The URL to the SWID file. */
  url?: string | undefined;
}

/** Specifies a tool (manual or automated). */
export interface Tool {
  /**
   * DEPRECATED - DO NOT USE - The vendor of the tool used to create the BOM.
   *
   * @deprecated
   */
  vendor?:
    | string
    | undefined;
  /**
   * DEPRECATED - DO NOT USE - The name of the tool used to create the BOM.
   *
   * @deprecated
   */
  name?:
    | string
    | undefined;
  /**
   * DEPRECATED - DO NOT USE - The version of the tool used to create the BOM.
   *
   * @deprecated
   */
  version?:
    | string
    | undefined;
  /**
   * DEPRECATED - DO NOT USE
   *
   * @deprecated
   */
  hashes: Hash[];
  /**
   * DEPRECATED - DO NOT USE - Provides the ability to document external references related to the tool.
   *
   * @deprecated
   */
  externalReferences: ExternalReference[];
  /** A list of software and hardware components used as tools */
  components: Component[];
  /** A list of services used as tools. This may include microservices, function-as-a-service, and other types of network or intra-process services. */
  services: Service[];
}

/** Specifies a property */
export interface Property {
  /** Name (or key) */
  name: string;
  /** Value */
  value?: string | undefined;
}

export interface Composition {
  /** Indicates the aggregate completeness */
  aggregate: Aggregate;
  /** The assemblies the aggregate completeness applies to */
  assemblies: string[];
  /** The dependencies the aggregate completeness applies to */
  dependencies: string[];
  /** The bom-ref identifiers of the vulnerabilities being described. */
  vulnerabilities: string[];
  /** An optional identifier which can be used to reference the composition elsewhere in the BOM. Every bom-ref must be unique within the BOM. */
  bomRef?: string | undefined;
}

export interface EvidenceCopyright {
  /** Copyright text */
  text: string;
}

/** Provides the ability to document evidence collected through various forms of extraction or analysis. */
export interface Evidence {
  /** EITHER (list of SPDX licenses and/or named licenses) OR (tuple of one SPDX License Expression) */
  licenses: LicenseChoice[];
  /** Copyright evidence captures intellectual property assertions, providing evidence of possible ownership and legal protection. */
  copyright: EvidenceCopyright[];
  /** Evidence that substantiates the identity of a component. The identity may be an object or an array of identity objects. Support for specifying identity as a single object was introduced in CycloneDX v1.5. Arrays were introduced in v1.6. It is recommended that all implementations use arrays, even if only one identity object is specified. */
  identity: EvidenceIdentity[];
  /** Evidence of individual instances of a component spread across multiple locations. */
  occurrences: EvidenceOccurrences[];
  /** Evidence of the components use through the callstack. */
  callstack?: Callstack | undefined;
}

export interface Callstack {
  /** Within a call stack, a frame is a discrete unit that encapsulates an execution context, including local variables, parameters, and the return address. As function calls are made, frames are pushed onto the stack, forming an array-like structure that orchestrates the flow of program execution and manages the sequence of function invocations. */
  frames: Callstack_Frames[];
}

export interface Callstack_Frames {
  /** A package organizes modules into namespaces, providing a unique namespace for each type it contains. */
  package?:
    | string
    | undefined;
  /** A module or class that encloses functions/methods and other code. */
  module: string;
  /** A block of code designed to perform a particular task. */
  function?:
    | string
    | undefined;
  /** Optional arguments that are passed to the module or function. */
  parameters: string[];
  /** The line number the code that is called resides on. */
  line?:
    | number
    | undefined;
  /** The column the code that is called resides. */
  column?:
    | number
    | undefined;
  /** The full path and filename of the module. */
  fullFilename?: string | undefined;
}

export interface EvidenceIdentity {
  /** The identity field of the component which the evidence describes. */
  field: EvidenceFieldType;
  /** The overall confidence of the evidence from 0 - 1, where 1 is 100% confidence. */
  confidence?:
    | number
    | undefined;
  /** The methods used to extract and/or analyze the evidence. */
  methods: EvidenceMethods[];
  /** The object in the BOM identified by its bom-ref. This is often a component or service, but may be any object type supporting bom-refs. Tools used for analysis should already be defined in the BOM, either in the metadata/tools, components, or formulation. */
  tools: string[];
  /** The value of the field (cpe, purl, etc) that has been concluded based on the aggregate of all methods (if available). */
  concludedValue?: string | undefined;
}

export interface EvidenceMethods {
  /** The technique used in this method of analysis. */
  technique: EvidenceTechnique;
  /** The confidence of the evidence from 0 - 1, where 1 is 100% confidence. Confidence is specific to the technique used. Each technique of analysis can have independent confidence. */
  confidence: number;
  /** The value or contents of the evidence. */
  value?: string | undefined;
}

export interface EvidenceOccurrences {
  /** An optional identifier which can be used to reference the occurrence elsewhere in the BOM. Every bom-ref must be unique within the BOM. */
  bomRef?:
    | string
    | undefined;
  /** The location or path to where the component was found. */
  location: string;
  /** The line number where the component was found. */
  line?:
    | number
    | undefined;
  /** The offset where the component was found. */
  offset?:
    | number
    | undefined;
  /** The symbol name that was found associated with the component. */
  symbol?:
    | string
    | undefined;
  /** Any additional context of the detected component (e.g. a code snippet). */
  additionalContext?: string | undefined;
}

/** A note containing the locale and content. */
export interface Note {
  /** The ISO-639 (or higher) language code and optional ISO-3166 (or higher) country code. Examples include: "en", "en-US", "fr" and "fr-CA". */
  locale?:
    | string
    | undefined;
  /** Specifies the full content of the release note. */
  text?: AttachedText | undefined;
}

export interface ReleaseNotes {
  /** The software versioning type. It is recommended that the release type use one of 'major', 'minor', 'patch', 'pre-release', or 'internal'. Representing all possible software release types is not practical, so standardizing on the recommended values, whenever possible, is strongly encouraged. */
  type: string;
  /** The title of the release. */
  title?:
    | string
    | undefined;
  /** The URL to an image that may be prominently displayed with the release note. */
  featuredImage?:
    | string
    | undefined;
  /** The URL to an image that may be used in messaging on social media platforms. */
  socialImage?:
    | string
    | undefined;
  /** A short description of the release. */
  description?:
    | string
    | undefined;
  /** The date and time (timestamp) when the release note was created. */
  timestamp?:
    | Date
    | undefined;
  /** Optional alternate names the release may be referred to. This may include unofficial terms used by development and marketing teams (e.g. code names). */
  aliases: string[];
  /** Textual strings that aid in the discovery, search, and retrieval of the associated object. Tags often serve as a way to group or categorize similar or related objects by various attributes. Examples include "json-parser", "object-persistence", "text-to-image", "translation", and "object-detection". */
  tags: string[];
  /** A collection of issues that have been resolved. */
  resolves: Issue[];
  /** Zero or more release notes containing the locale and content. Multiple note messages may be specified to support release notes in a wide variety of languages. */
  notes: Note[];
  /** Specifies optional, custom, properties */
  properties: Property[];
}

/** Defines a weakness in a component or service that could be exploited or triggered by a threat source. */
export interface Vulnerability {
  /** An optional identifier which can be used to reference the vulnerability elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element. */
  bomRef?:
    | string
    | undefined;
  /** The identifier that uniquely identifies the vulnerability. */
  id?:
    | string
    | undefined;
  /** The source that published the vulnerability. */
  source?:
    | Source
    | undefined;
  /** Zero or more pointers to vulnerabilities that are the equivalent of the vulnerability specified. Oftentimes, the same vulnerability may exist in multiple sources of vulnerability intelligence but have different identifiers. References provide a way to correlate vulnerabilities across multiple sources of vulnerability intelligence. */
  references: VulnerabilityReference[];
  /** List of vulnerability ratings. Consumers SHOULD consider ratings in prioritization decisions; source ratings may differ and aid prioritization. */
  ratings: VulnerabilityRating[];
  /** List of Common Weaknesses Enumerations (CWEs) codes that describe this vulnerability. For example, 399 (of https://cwe.mitre.org/data/definitions/399.html) */
  cwes: number[];
  /** A description of the vulnerability as provided by the source. */
  description?:
    | string
    | undefined;
  /** If available, an in-depth description of the vulnerability as provided by the source organization. Details often include information useful in understanding the root cause. */
  detail?:
    | string
    | undefined;
  /** Recommendations of how the vulnerability can be remediated or mitigated. */
  recommendation?:
    | string
    | undefined;
  /** Published advisories of the vulnerability if provided. */
  advisories: Advisory[];
  /** The date and time (timestamp) when the vulnerability record was created in the vulnerability database. */
  created?:
    | Date
    | undefined;
  /** The date and time (timestamp) when the vulnerability record was first published. */
  published?:
    | Date
    | undefined;
  /** The date and time (timestamp) when the vulnerability record was last updated. */
  updated?:
    | Date
    | undefined;
  /** Individuals or organizations credited with the discovery of the vulnerability. */
  credits?:
    | VulnerabilityCredits
    | undefined;
  /** The tool(s) used to identify, confirm, or score the vulnerability. */
  tools?:
    | Tool
    | undefined;
  /** An assessment of the impact and exploitability of the vulnerability. */
  analysis?:
    | VulnerabilityAnalysis
    | undefined;
  /** affects */
  affects: VulnerabilityAffects[];
  /** Specifies optional, custom, properties */
  properties: Property[];
  /** The date and time (timestamp) when the vulnerability record was rejected (if applicable). */
  rejected?:
    | Date
    | undefined;
  /** Evidence used to reproduce the vulnerability. */
  proofOfConcept?:
    | ProofOfConcept
    | undefined;
  /** A bypass, usually temporary, of the vulnerability that reduces its likelihood and/or impact. Workarounds often involve changes to configuration or deployments. */
  workaround?: string | undefined;
}

export interface ProofOfConcept {
  /** Precise steps to reproduce the vulnerability. */
  reproductionSteps?:
    | string
    | undefined;
  /** A description of the environment in which reproduction was possible. */
  environment?:
    | string
    | undefined;
  /** Supporting material that helps in reproducing or understanding how reproduction is possible. This may include screenshots, payloads, and PoC exploit code. */
  supportingMaterial: AttachedText[];
}

export interface VulnerabilityReference {
  /** An identifier that uniquely identifies the vulnerability. */
  id: string;
  /** The source that published the vulnerability. */
  source: Source | undefined;
}

export interface VulnerabilityRating {
  /** The source that calculated the severity or risk rating of the vulnerability. */
  source?:
    | Source
    | undefined;
  /** The numerical score of the rating. */
  score?:
    | number
    | undefined;
  /** Textual representation of the severity that corresponds to the numerical score of the rating. */
  severity?:
    | Severity
    | undefined;
  /** Specifies the severity or risk scoring methodology or standard used. */
  method?:
    | ScoreMethod
    | undefined;
  /** Textual representation of the metric values used to score the vulnerability. */
  vector?:
    | string
    | undefined;
  /** An optional reason for rating the vulnerability as it was. */
  justification?: string | undefined;
}

/** Title and location where advisory information can be obtained. An advisory is a notification of a threat to a component, service, or system. */
export interface Advisory {
  /** An optional name of the advisory. */
  title?:
    | string
    | undefined;
  /** Location where the advisory can be obtained. */
  url: string;
}

export interface VulnerabilityCredits {
  /** The organizations credited with vulnerability discovery. */
  organizations: OrganizationalEntity[];
  /** The individuals not associated with organizations that are credited with vulnerability discovery. */
  individuals: OrganizationalContact[];
}

export interface VulnerabilityAnalysis {
  /** Declares the current state of an occurrence of a vulnerability after automated or manual analysis. */
  state?:
    | ImpactAnalysisState
    | undefined;
  /** The rationale of why the impact analysis state was asserted. */
  justification?:
    | ImpactAnalysisJustification
    | undefined;
  /** A response to the vulnerability by the manufacturer, supplier, or project responsible for the affected component or service. More than one response is allowed. Responses are strongly encouraged for vulnerabilities where the analysis state is exploitable. */
  response: VulnerabilityResponse[];
  /** Detailed description of the impact, including methods used during the assessment. If a vulnerability is not exploitable, this field should include specific details on why the component or service is not impacted by this vulnerability. */
  detail?:
    | string
    | undefined;
  /** The date and time (timestamp) when the analysis was first issued. */
  firstIssued?:
    | Date
    | undefined;
  /** The date and time (timestamp) when the analysis was last updated. */
  lastUpdated?: Date | undefined;
}

export interface VulnerabilityAffects {
  /** References a component or service by the objects bom-ref */
  ref: string;
  /** Zero or more individual versions or range of versions. */
  versions: VulnerabilityAffectedVersions[];
}

export interface VulnerabilityAffectedVersions {
  /** A single version of a component or service. */
  version?:
    | string
    | undefined;
  /** A version range specified in Package URL Version Range syntax (vers), which is defined at https://github.com/package-url/vers-spec */
  range?:
    | string
    | undefined;
  /** The vulnerability status for the version or range of versions. Defaults to VULNERABILITY_AFFECTED_STATUS_AFFECTED if not specified. */
  status?: VulnerabilityAffectedStatus | undefined;
}

export interface AnnotatorChoice {
  /** The organization that created the annotation */
  organization?:
    | OrganizationalEntity
    | undefined;
  /** The person that created the annotation */
  individual?:
    | OrganizationalContact
    | undefined;
  /** The tool or component that created the annotation */
  component?:
    | Component
    | undefined;
  /** The service that created the annotation */
  service?: Service | undefined;
}

export interface Annotation {
  /** An optional identifier which can be used to reference the annotation elsewhere in the BOM. Every bom-ref must be unique within the BOM. */
  bomRef?:
    | string
    | undefined;
  /** The object in the BOM identified by its bom-ref. This is often a component or service but may be any object type supporting bom-refs. */
  subjects: string[];
  /** The organization, person, component, or service which created the textual content of the annotation. */
  annotator:
    | AnnotatorChoice
    | undefined;
  /** The date and time (timestamp) when the annotation was created. */
  timestamp:
    | Date
    | undefined;
  /** The textual content of the annotation. */
  text: string;
}

/**
 * A model card describes the intended uses of a machine learning model and potential limitations, including biases and ethical considerations. Model cards typically contain the training parameters, which datasets were used to train the model, performance metrics, and other relevant data useful for ML transparency. This object SHOULD be specified for any component of type `machine-learning-model` and must not be specified for other component types.
 *
 * Comment:
 * Model card support in CycloneDX is derived from TensorFlow Model Card Toolkit released under the Apache 2.0 license and available from https://github.com/tensorflow/model-card-toolkit/blob/main/model_card_toolkit/schema/v0.0.2/model_card.schema.json. In addition, CycloneDX model card support includes portions of VerifyML, also released under the Apache 2.0 license and available from https://github.com/cylynx/verifyml/blob/main/verifyml/model_card_toolkit/schema/v0.0.4/model_card.schema.json.
 */
export interface ModelCard {
  /** An optional identifier which can be used to reference the model card elsewhere in the BOM. Every bom-ref must be unique within the BOM. */
  bomRef?:
    | string
    | undefined;
  /** Hyper-parameters for construction of the model. */
  modelParameters?:
    | ModelCard_ModelParameters
    | undefined;
  /** A quantitative analysis of the model */
  quantitativeAnalysis?:
    | ModelCard_QuantitativeAnalysis
    | undefined;
  /** What considerations should be taken into account regarding the model's construction, training, and application? */
  considerations?: ModelCard_ModelCardConsiderations | undefined;
}

export interface ModelCard_ModelParameters {
  /** The overall approach to learning used by the model for problem-solving. */
  approach?:
    | ModelCard_ModelParameters_Approach
    | undefined;
  /** Directly influences the input and/or output. Examples include classification, regression, clustering, etc. */
  task?:
    | string
    | undefined;
  /** The model architecture family such as transformer network, convolutional neural network, residual neural network, LSTM neural network, etc. */
  architectureFamily?:
    | string
    | undefined;
  /** The specific architecture of the model, such as GPT-1, ResNet-50, YOLOv3, etc. */
  modelArchitecture?:
    | string
    | undefined;
  /** The datasets used to train and evaluate the model. */
  datasets: ModelCard_ModelParameters_Datasets[];
  /** The input format(s) of the model */
  inputs: ModelCard_ModelParameters_MachineLearningInputOutputParameters[];
  /** The output format(s) from the model */
  outputs: ModelCard_ModelParameters_MachineLearningInputOutputParameters[];
}

export interface ModelCard_ModelParameters_Approach {
  /** Learning types describing the learning problem or hybrid learning problem. */
  type?: ModelParameterApproachType | undefined;
}

export interface ModelCard_ModelParameters_Datasets {
  /** Inline Data Information */
  dataset?:
    | ComponentData
    | undefined;
  /** References a data component by the components bom-ref attribute */
  ref?: string | undefined;
}

export interface ModelCard_ModelParameters_MachineLearningInputOutputParameters {
  /** The data format for input/output to the model. Example formats include string, image, time-series */
  format?: string | undefined;
}

export interface ModelCard_QuantitativeAnalysis {
  /** The model performance metrics being reported. Examples may include accuracy, F1 score, precision, top-3 error rates, MSC, etc. */
  performanceMetrics: ModelCard_QuantitativeAnalysis_PerformanceMetrics[];
  /** A collection of graphics that represent various measurements. */
  graphics?: GraphicsCollection | undefined;
}

export interface ModelCard_QuantitativeAnalysis_PerformanceMetrics {
  /** The type of performance metric. */
  type?:
    | string
    | undefined;
  /** The value of the performance metric. */
  value?:
    | string
    | undefined;
  /** The name of the slice this metric was computed on. By default, assume this metric is not sliced. */
  slice?:
    | string
    | undefined;
  /** The confidence interval of the metric. */
  confidenceInterval?: ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval | undefined;
}

export interface ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval {
  /** The lower bound of the confidence interval. */
  lowerBound?:
    | string
    | undefined;
  /** The upper bound of the confidence interval. */
  upperBound?: string | undefined;
}

export interface ModelCard_ModelCardConsiderations {
  /** Who are the intended users of the model? */
  users: string[];
  /** What are the intended use cases of the model? */
  useCases: string[];
  /** What are the known technical limitations of the model? E.g. What kind(s) of data should the model be expected not to perform well on? What are the factors that might degrade model performance? */
  technicalLimitations: string[];
  /** What are the known tradeoffs in accuracy/performance of the model? */
  performanceTradeoffs: string[];
  /** What are the ethical risks involved in the application of this model? */
  ethicalConsiderations: ModelCard_ModelCardConsiderations_EthicalConsiderations[];
  /** How does the model affect groups at risk of being systematically disadvantaged? What are the harms and benefits to the various affected groups? */
  fairnessAssessments: ModelCard_ModelCardConsiderations_FairnessAssessments[];
  /** What are the various environmental impacts the corresponding machine learning model has exhibited across its lifecycle? */
  environmentalConsiderations?: ModelCard_ModelCardConsiderations_EnvironmentalConsiderations | undefined;
}

export interface ModelCard_ModelCardConsiderations_EthicalConsiderations {
  /** The name of the risk. */
  name?:
    | string
    | undefined;
  /** Strategy used to address this risk. */
  mitigationStrategy?: string | undefined;
}

export interface ModelCard_ModelCardConsiderations_FairnessAssessments {
  /** The groups or individuals at risk of being systematically disadvantaged by the model. */
  groupAtRisk?:
    | string
    | undefined;
  /** Expected benefits to the identified groups. */
  benefits?:
    | string
    | undefined;
  /** Expected harms to the identified groups. */
  harms?:
    | string
    | undefined;
  /** With respect to the benefits and harms outlined, please describe any mitigation strategy implemented. */
  mitigationStrategy?: string | undefined;
}

export interface ModelCard_ModelCardConsiderations_EnvironmentalConsiderations {
  /** Describes energy consumption information incurred for one or more component lifecycle activities. */
  energyConsumptions: ModelCard_ModelCardConsiderations_EnergyConsumption[];
  /** Specifies optional, custom properties for environment considerations */
  properties: Property[];
}

/** Describes energy consumption information incurred for the specified lifecycle activity. */
export interface ModelCard_ModelCardConsiderations_EnergyConsumption {
  /** The type of activity that is part of a machine learning model development or operational lifecycle. */
  activity: ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType;
  /** The providers of the energy consumed by the associated model development lifecycle activity. */
  energyProviders: EnergyProviderType[];
  /** The total energy cost associated with the model lifecycle activity. */
  activityEnergyCost:
    | EnergyMeasureType
    | undefined;
  /** The CO2 cost or debit equivalent to the total energy cost. */
  co2CostEquivalent?:
    | CO2MeasureType
    | undefined;
  /** The CO2 offset or credit for the CO2 equivalent cost. */
  co2CostOffset?:
    | CO2MeasureType
    | undefined;
  /** Specifies optional, custom properties for environment considerations */
  properties: Property[];
}

/** An activity that is part of a machine learning model development or operational lifecycle. */
export enum ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType {
  /** ACTIVITY_TYPE_UNSPECIFIED - Default */
  ACTIVITY_TYPE_UNSPECIFIED = 0,
  /** ACTIVITY_TYPE_OTHER - a lifecycle activity type whose description does not match currently defined values (the default type). */
  ACTIVITY_TYPE_OTHER = 1,
  /** ACTIVITY_TYPE_DESIGN - model design including problem framing, goal definition and algorithm selection. */
  ACTIVITY_TYPE_DESIGN = 2,
  /** ACTIVITY_TYPE_DATA_COLLECTION - model data acquisition including search, selection and transfer. */
  ACTIVITY_TYPE_DATA_COLLECTION = 3,
  /** ACTIVITY_TYPE_DATA_PREPARATION - model data preparation including data cleaning, labeling and conversion. */
  ACTIVITY_TYPE_DATA_PREPARATION = 4,
  /** ACTIVITY_TYPE_TRAINING - model building, training and generalized tuning. */
  ACTIVITY_TYPE_TRAINING = 5,
  /** ACTIVITY_TYPE_FINE_TUNING - refining a trained model to produce desired outputs for a given problem space. */
  ACTIVITY_TYPE_FINE_TUNING = 6,
  /** ACTIVITY_TYPE_VALIDATION - model validation including model output evaluation and testing. */
  ACTIVITY_TYPE_VALIDATION = 7,
  /** ACTIVITY_TYPE_DEPLOYMENT - explicit model deployment to a target hosting infrastructure. */
  ACTIVITY_TYPE_DEPLOYMENT = 8,
  /** ACTIVITY_TYPE_INFERENCE - generating an output response from a hosted model from a set of inputs. */
  ACTIVITY_TYPE_INFERENCE = 9,
  UNRECOGNIZED = -1,
}

export function modelCard_ModelCardConsiderations_EnergyConsumption_ActivityTypeFromJSON(
  object: any,
): ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType {
  switch (object) {
    case 0:
    case "ACTIVITY_TYPE_UNSPECIFIED":
      return ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_UNSPECIFIED;
    case 1:
    case "ACTIVITY_TYPE_OTHER":
      return ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_OTHER;
    case 2:
    case "ACTIVITY_TYPE_DESIGN":
      return ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_DESIGN;
    case 3:
    case "ACTIVITY_TYPE_DATA_COLLECTION":
      return ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_DATA_COLLECTION;
    case 4:
    case "ACTIVITY_TYPE_DATA_PREPARATION":
      return ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_DATA_PREPARATION;
    case 5:
    case "ACTIVITY_TYPE_TRAINING":
      return ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_TRAINING;
    case 6:
    case "ACTIVITY_TYPE_FINE_TUNING":
      return ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_FINE_TUNING;
    case 7:
    case "ACTIVITY_TYPE_VALIDATION":
      return ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_VALIDATION;
    case 8:
    case "ACTIVITY_TYPE_DEPLOYMENT":
      return ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_DEPLOYMENT;
    case 9:
    case "ACTIVITY_TYPE_INFERENCE":
      return ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_INFERENCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.UNRECOGNIZED;
  }
}

export function modelCard_ModelCardConsiderations_EnergyConsumption_ActivityTypeToJSON(
  object: ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType,
): string {
  switch (object) {
    case ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_UNSPECIFIED:
      return "ACTIVITY_TYPE_UNSPECIFIED";
    case ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_OTHER:
      return "ACTIVITY_TYPE_OTHER";
    case ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_DESIGN:
      return "ACTIVITY_TYPE_DESIGN";
    case ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_DATA_COLLECTION:
      return "ACTIVITY_TYPE_DATA_COLLECTION";
    case ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_DATA_PREPARATION:
      return "ACTIVITY_TYPE_DATA_PREPARATION";
    case ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_TRAINING:
      return "ACTIVITY_TYPE_TRAINING";
    case ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_FINE_TUNING:
      return "ACTIVITY_TYPE_FINE_TUNING";
    case ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_VALIDATION:
      return "ACTIVITY_TYPE_VALIDATION";
    case ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_DEPLOYMENT:
      return "ACTIVITY_TYPE_DEPLOYMENT";
    case ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.ACTIVITY_TYPE_INFERENCE:
      return "ACTIVITY_TYPE_INFERENCE";
    case ModelCard_ModelCardConsiderations_EnergyConsumption_ActivityType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Describes the physical provider of energy used for model development or operations. */
export interface EnergyProviderType {
  /** BOM unique reference to the energy provider. */
  bomRef?:
    | string
    | undefined;
  /** A description of the energy provider. */
  description: string;
  /** The organization of the energy provider. */
  organization:
    | OrganizationalEntity
    | undefined;
  /** The energy source for the energy provider. */
  energySource: EnergyProviderType_EnergySourceType;
  /** The energy provided by the energy source for an associated activity. */
  energyProvided:
    | EnergyMeasureType
    | undefined;
  /** Provides the ability to document external references related to the BOM or to the project the BOM describes. */
  externalReferences: ExternalReference[];
}

export enum EnergyProviderType_EnergySourceType {
  /** ENERGY_SOURCE_TYPE_UNSPECIFIED - Default */
  ENERGY_SOURCE_TYPE_UNSPECIFIED = 0,
  /** ENERGY_SOURCE_TYPE_UNKNOWN - energy source: unknown. The energy source is unknown. */
  ENERGY_SOURCE_TYPE_UNKNOWN = 1,
  /** ENERGY_SOURCE_TYPE_OTHER - energy source: other. An energy source that is not listed. */
  ENERGY_SOURCE_TYPE_OTHER = 2,
  /** ENERGY_SOURCE_TYPE_COAL - energy source: coal. Energy produced by types of coal. */
  ENERGY_SOURCE_TYPE_COAL = 3,
  /** ENERGY_SOURCE_TYPE_OIL - energy source: oil. Petroleum products (primarily crude oil and its derivative fuel oils). */
  ENERGY_SOURCE_TYPE_OIL = 4,
  /** ENERGY_SOURCE_TYPE_NATURAL_GAS - energy source: natural-gas. Hydrocarbon gas liquids (HGL) that occur as gases at atmospheric pressure and as liquids under higher pressures including Natural gas (C5H12 and heavier), Ethane (C2H6), Propane (C3H8), etc. */
  ENERGY_SOURCE_TYPE_NATURAL_GAS = 5,
  /** ENERGY_SOURCE_TYPE_NUCLEAR - energy source: nuclear. Energy produced from the cores of atoms (i.e., through nuclear fission or fusion). */
  ENERGY_SOURCE_TYPE_NUCLEAR = 6,
  /** ENERGY_SOURCE_TYPE_WIND - energy source: wind. Energy produced from moving air. */
  ENERGY_SOURCE_TYPE_WIND = 7,
  /** ENERGY_SOURCE_TYPE_SOLAR - energy source: solar. Energy produced from the sun (i.e., solar radiation). */
  ENERGY_SOURCE_TYPE_SOLAR = 8,
  /** ENERGY_SOURCE_TYPE_GEOTHERMAL - energy source: geothermal. Energy produced from heat within the earth. */
  ENERGY_SOURCE_TYPE_GEOTHERMAL = 9,
  /** ENERGY_SOURCE_TYPE_HYDROPOWER - energy source: hydropower. Energy produced from flowing water. */
  ENERGY_SOURCE_TYPE_HYDROPOWER = 10,
  /** ENERGY_SOURCE_TYPE_BIOFUEL - energy source: biofuel. Liquid fuels produced from biomass feedstocks (i.e., organic materials such as plants or animals). */
  ENERGY_SOURCE_TYPE_BIOFUEL = 11,
  UNRECOGNIZED = -1,
}

export function energyProviderType_EnergySourceTypeFromJSON(object: any): EnergyProviderType_EnergySourceType {
  switch (object) {
    case 0:
    case "ENERGY_SOURCE_TYPE_UNSPECIFIED":
      return EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_UNSPECIFIED;
    case 1:
    case "ENERGY_SOURCE_TYPE_UNKNOWN":
      return EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_UNKNOWN;
    case 2:
    case "ENERGY_SOURCE_TYPE_OTHER":
      return EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_OTHER;
    case 3:
    case "ENERGY_SOURCE_TYPE_COAL":
      return EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_COAL;
    case 4:
    case "ENERGY_SOURCE_TYPE_OIL":
      return EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_OIL;
    case 5:
    case "ENERGY_SOURCE_TYPE_NATURAL_GAS":
      return EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_NATURAL_GAS;
    case 6:
    case "ENERGY_SOURCE_TYPE_NUCLEAR":
      return EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_NUCLEAR;
    case 7:
    case "ENERGY_SOURCE_TYPE_WIND":
      return EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_WIND;
    case 8:
    case "ENERGY_SOURCE_TYPE_SOLAR":
      return EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_SOLAR;
    case 9:
    case "ENERGY_SOURCE_TYPE_GEOTHERMAL":
      return EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_GEOTHERMAL;
    case 10:
    case "ENERGY_SOURCE_TYPE_HYDROPOWER":
      return EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_HYDROPOWER;
    case 11:
    case "ENERGY_SOURCE_TYPE_BIOFUEL":
      return EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_BIOFUEL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EnergyProviderType_EnergySourceType.UNRECOGNIZED;
  }
}

export function energyProviderType_EnergySourceTypeToJSON(object: EnergyProviderType_EnergySourceType): string {
  switch (object) {
    case EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_UNSPECIFIED:
      return "ENERGY_SOURCE_TYPE_UNSPECIFIED";
    case EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_UNKNOWN:
      return "ENERGY_SOURCE_TYPE_UNKNOWN";
    case EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_OTHER:
      return "ENERGY_SOURCE_TYPE_OTHER";
    case EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_COAL:
      return "ENERGY_SOURCE_TYPE_COAL";
    case EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_OIL:
      return "ENERGY_SOURCE_TYPE_OIL";
    case EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_NATURAL_GAS:
      return "ENERGY_SOURCE_TYPE_NATURAL_GAS";
    case EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_NUCLEAR:
      return "ENERGY_SOURCE_TYPE_NUCLEAR";
    case EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_WIND:
      return "ENERGY_SOURCE_TYPE_WIND";
    case EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_SOLAR:
      return "ENERGY_SOURCE_TYPE_SOLAR";
    case EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_GEOTHERMAL:
      return "ENERGY_SOURCE_TYPE_GEOTHERMAL";
    case EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_HYDROPOWER:
      return "ENERGY_SOURCE_TYPE_HYDROPOWER";
    case EnergyProviderType_EnergySourceType.ENERGY_SOURCE_TYPE_BIOFUEL:
      return "ENERGY_SOURCE_TYPE_BIOFUEL";
    case EnergyProviderType_EnergySourceType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A measure of energy. */
export interface EnergyMeasureType {
  /** Quantity of energy. */
  value: number;
  /** Unit of energy. */
  unit: EnergyMeasureType_EnergyMeasureUnitType;
}

export enum EnergyMeasureType_EnergyMeasureUnitType {
  /** ENERGY_MEASURE_UNIT_TYPE_UNSPECIFIED - Default */
  ENERGY_MEASURE_UNIT_TYPE_UNSPECIFIED = 0,
  /** ENERGY_MEASURE_UNIT_TYPE_KILOWATT_HOURS - kilowatt-hour (kWh) is the energy delivered by one kilowatt (kW) of power for one hour (h) (the default unit). */
  ENERGY_MEASURE_UNIT_TYPE_KILOWATT_HOURS = 1,
  UNRECOGNIZED = -1,
}

export function energyMeasureType_EnergyMeasureUnitTypeFromJSON(object: any): EnergyMeasureType_EnergyMeasureUnitType {
  switch (object) {
    case 0:
    case "ENERGY_MEASURE_UNIT_TYPE_UNSPECIFIED":
      return EnergyMeasureType_EnergyMeasureUnitType.ENERGY_MEASURE_UNIT_TYPE_UNSPECIFIED;
    case 1:
    case "ENERGY_MEASURE_UNIT_TYPE_KILOWATT_HOURS":
      return EnergyMeasureType_EnergyMeasureUnitType.ENERGY_MEASURE_UNIT_TYPE_KILOWATT_HOURS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EnergyMeasureType_EnergyMeasureUnitType.UNRECOGNIZED;
  }
}

export function energyMeasureType_EnergyMeasureUnitTypeToJSON(object: EnergyMeasureType_EnergyMeasureUnitType): string {
  switch (object) {
    case EnergyMeasureType_EnergyMeasureUnitType.ENERGY_MEASURE_UNIT_TYPE_UNSPECIFIED:
      return "ENERGY_MEASURE_UNIT_TYPE_UNSPECIFIED";
    case EnergyMeasureType_EnergyMeasureUnitType.ENERGY_MEASURE_UNIT_TYPE_KILOWATT_HOURS:
      return "ENERGY_MEASURE_UNIT_TYPE_KILOWATT_HOURS";
    case EnergyMeasureType_EnergyMeasureUnitType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** A measure of carbon dioxide (CO2). */
export interface CO2MeasureType {
  /** Quantity of carbon dioxide (CO2). */
  value: number;
  /** Unit of carbon dioxide (CO2). */
  unit: CO2MeasureType_CO2MeasureUnitType;
}

export enum CO2MeasureType_CO2MeasureUnitType {
  /** CO2_MEASURE_UNIT_TYPE_UNSPECIFIED - Default */
  CO2_MEASURE_UNIT_TYPE_UNSPECIFIED = 0,
  /** CO2_MEASURE_UNIT_TYPE_TONNES_CO2_EQUIVALENT - Tonnes (t) of carbon dioxide (CO2) equivalent (eq) (the default unit). */
  CO2_MEASURE_UNIT_TYPE_TONNES_CO2_EQUIVALENT = 1,
  UNRECOGNIZED = -1,
}

export function cO2MeasureType_CO2MeasureUnitTypeFromJSON(object: any): CO2MeasureType_CO2MeasureUnitType {
  switch (object) {
    case 0:
    case "CO2_MEASURE_UNIT_TYPE_UNSPECIFIED":
      return CO2MeasureType_CO2MeasureUnitType.CO2_MEASURE_UNIT_TYPE_UNSPECIFIED;
    case 1:
    case "CO2_MEASURE_UNIT_TYPE_TONNES_CO2_EQUIVALENT":
      return CO2MeasureType_CO2MeasureUnitType.CO2_MEASURE_UNIT_TYPE_TONNES_CO2_EQUIVALENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CO2MeasureType_CO2MeasureUnitType.UNRECOGNIZED;
  }
}

export function cO2MeasureType_CO2MeasureUnitTypeToJSON(object: CO2MeasureType_CO2MeasureUnitType): string {
  switch (object) {
    case CO2MeasureType_CO2MeasureUnitType.CO2_MEASURE_UNIT_TYPE_UNSPECIFIED:
      return "CO2_MEASURE_UNIT_TYPE_UNSPECIFIED";
    case CO2MeasureType_CO2MeasureUnitType.CO2_MEASURE_UNIT_TYPE_TONNES_CO2_EQUIVALENT:
      return "CO2_MEASURE_UNIT_TYPE_TONNES_CO2_EQUIVALENT";
    case CO2MeasureType_CO2MeasureUnitType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An address used to identify a contactable location. */
export interface PostalAddressType {
  /** An optional identifier which can be used to reference the address elsewhere in the BOM. Every bom-ref must be unique within the BOM. */
  bomRef?:
    | string
    | undefined;
  /** The country name or the two-letter ISO 3166-1 country code. */
  country?:
    | string
    | undefined;
  /** The region or state in the country. For example, Texas. */
  region?:
    | string
    | undefined;
  /** The locality or city within the country. For example, Austin. */
  locality?:
    | string
    | undefined;
  /** The post office box number. For example, 901. */
  postOfficeBoxNumber?:
    | string
    | undefined;
  /** The postal code. For example, 78758. */
  postalCodeue?:
    | string
    | undefined;
  /** The street address. For example, 100 Main Street. */
  streetAddress?: string | undefined;
}

export interface ComponentData {
  /** An optional identifier which can be used to reference the dataset elsewhere in the BOM. Every bom-ref must be unique within the BOM. */
  bomRef?:
    | string
    | undefined;
  /** The general theme or subject matter of the data being specified. */
  type: ComponentDataType;
  /** The name of the dataset. */
  name?:
    | string
    | undefined;
  /** The contents or references to the contents of the data being described. */
  contents?:
    | ComponentData_ComponentDataContents
    | undefined;
  /** Data classification tags data according to its type, sensitivity, and value if altered, stolen, or destroyed. */
  classification?:
    | string
    | undefined;
  /** A description of any sensitive data in a dataset. */
  sensitiveData: string[];
  /** A collection of graphics that represent various measurements. */
  graphics?:
    | GraphicsCollection
    | undefined;
  /** A description of the dataset. Can describe size of dataset, whether it's used for source code, training, testing, or validation, etc. */
  description?:
    | string
    | undefined;
  /** Data Governance */
  governance?: DataGovernance | undefined;
}

export interface ComponentData_ComponentDataContents {
  /** An optional way to include textual or encoded data. */
  attachment?:
    | AttachedText
    | undefined;
  /** The URL to where the data can be retrieved. */
  url?:
    | string
    | undefined;
  /** Provides the ability to document name-value parameters used for configuration. */
  properties: Property[];
}

/** Data governance captures information regarding data ownership, stewardship, and custodianship, providing insights into the individuals or entities responsible for managing, overseeing, and safeguarding the data throughout its lifecycle. */
export interface DataGovernance {
  /** Data custodians are responsible for the safe custody, transport, and storage of data. */
  custodians: DataGovernance_DataGovernanceResponsibleParty[];
  /** Data stewards are responsible for data content, context, and associated business rules. */
  stewards: DataGovernance_DataGovernanceResponsibleParty[];
  /** Data owners are concerned with risk and appropriate access to data. */
  owners: DataGovernance_DataGovernanceResponsibleParty[];
}

export interface DataGovernance_DataGovernanceResponsibleParty {
  /** The organization that is responsible for specific data governance role(s). */
  organization?:
    | OrganizationalEntity
    | undefined;
  /** The individual that is responsible for specific data governance role(s). */
  contact?: OrganizationalContact | undefined;
}

/** A collection of graphics that represent various measurements. */
export interface GraphicsCollection {
  /** A description of this collection of graphics. */
  description?:
    | string
    | undefined;
  /** A collection of graphics. */
  graphic: GraphicsCollection_Graphic[];
}

export interface GraphicsCollection_Graphic {
  /** The name of the graphic. */
  name?:
    | string
    | undefined;
  /** The graphic (vector or raster). Base64 encoding must be specified for binary images. */
  image?: AttachedText | undefined;
}

/** Describes workflows and resources that captures rules and other aspects of how the associated BOM component or service was formed. */
export interface Formula {
  /** BOM unique reference to the resource. */
  bomRef?:
    | string
    | undefined;
  /** Transient components that are used in tasks that constitute one or more of this formula's workflows */
  components: Component[];
  /** Transient services that are used in tasks that constitute one or more of this formula's workflows */
  services: Service[];
  /** List of workflows that can be declared to accomplish specific orchestrated goals and independently triggered. */
  workflows: Workflow[];
  /** Domain-specific formula properties. */
  properties: Property[];
}

/** A specialized orchestration task. */
export interface Workflow {
  /** BOM unique reference to the resource. */
  bomRef: string;
  /** The unique identifier for the resource instance within its deployment context. */
  uid: string;
  /** The name of the resource instance. */
  name?:
    | string
    | undefined;
  /** A description of the resource instance. */
  description?:
    | string
    | undefined;
  /** Domain-specific resource instance properties. */
  properties: Property[];
  /** References to component or service resources that are used to realize the resource instance. */
  resourceReferences: ResourceReferenceChoice[];
  /** The tasks that comprise the workflow. */
  tasks: Task[];
  /** The graph of dependencies between tasks within the workflow. */
  taskDependencies: Dependency[];
  /** Indicates the types of activities performed by the set of workflow tasks. */
  taskTypes: TaskType[];
  /** The trigger that initiated the task. */
  trigger?:
    | Trigger
    | undefined;
  /** The sequence of steps for the task. */
  steps: Step[];
  /** Represents resources and data brought into a task at runtime by executor or task commands */
  inputs: InputType[];
  /** Represents resources and data output from a task at runtime by executor or task commands */
  outputs: OutputType[];
  /** The date and time (timestamp) when the task started. */
  timeStart?:
    | Date
    | undefined;
  /** The date and time (timestamp) when the task ended. */
  timeEnd?:
    | Date
    | undefined;
  /** A set of named filesystem or data resource shareable by workflow tasks. */
  workspaces: Workspace[];
  /** A graph of the component runtime topology for workflow's instance. */
  runtimeTopology: Dependency[];
}

/** Describes the inputs, sequence of steps and resources used to accomplish a task and its output. */
export interface Task {
  /** BOM unique reference to the resource. */
  bomRef: string;
  /** The unique identifier for the resource instance within its deployment context. */
  uid: string;
  /** The name of the resource instance. */
  name?:
    | string
    | undefined;
  /** A description of the resource instance. */
  description?:
    | string
    | undefined;
  /** Domain-specific task instance properties. */
  properties: Property[];
  /** References to component or service resources that are used to realize the resource instance. */
  resourceReferences: ResourceReferenceChoice[];
  /** Indicates the types of activities performed by the set of workflow tasks. */
  taskTypes: TaskType[];
  /** The trigger that initiated the task. */
  trigger?:
    | Trigger
    | undefined;
  /** "The sequence of steps for the task. */
  steps: Step[];
  /** Represents resources and data brought into a task at runtime by an executor or task commands */
  inputs: InputType[];
  /** Represents resources and data output from a task at runtime by an executor or task commands */
  outputs: OutputType[];
  /** The date and time (timestamp) when the task started. */
  timeStart?:
    | Date
    | undefined;
  /** The date and time (timestamp) when the task ended. */
  timeEnd?:
    | Date
    | undefined;
  /** A set of named filesystem or data resource shareable by workflow tasks. */
  workspaces: Workspace[];
  /** A graph of the component runtime topology for task's instance. */
  runtimeTopology: Dependency[];
}

/** Executes specific commands or tools in order to accomplish its owning task as part of a sequence. */
export interface Step {
  /** A name for the step. */
  name?:
    | string
    | undefined;
  /** A description of the step. */
  description?:
    | string
    | undefined;
  /** Ordered list of commands or directives for the step */
  commands: Command[];
  /** Domain-specific step properties. */
  properties: Property[];
}

export interface Command {
  /** A text representation of the executed command. */
  executed?:
    | string
    | undefined;
  /** Domain-specific command properties. */
  properties: Property[];
}

/** A named filesystem or data resource shareable by workflow tasks. */
export interface Workspace {
  /** BOM unique reference to the resource. */
  bomRef: string;
  /** The unique identifier for the resource instance within its deployment context. */
  uid: string;
  /** The name of the resource instance. */
  name?:
    | string
    | undefined;
  /** The names for the workspace as referenced by other workflow tasks. Effectively, a name mapping so other tasks can use their own local name in their steps. */
  aliases: string[];
  /** A description of the resource instance. */
  description?:
    | string
    | undefined;
  /** Domain-specific workspace instance properties. */
  properties: Property[];
  /** References to component or service resources that are used to realize the resource instance. */
  resourceReferences: ResourceReferenceChoice[];
  /** Describes the read-write access control for the workspace relative to the owning resource instance. */
  accessMode?:
    | Workspace_AccessMode
    | undefined;
  /** A path to a location on disk where the workspace will be available for the associated task's steps. */
  mountPath?:
    | string
    | undefined;
  /** The name of a domain-specific data type the workspace represents. */
  managedDataType?:
    | string
    | undefined;
  /** Identifies the reference to the request for a specific volume type and parameters. */
  volumeRequest?:
    | string
    | undefined;
  /** Information about the actual volume instance allocated to the workspace. */
  volume?: Volume | undefined;
}

export enum Workspace_AccessMode {
  /** ACCESS_MODE_READ_ONLY - buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema */
  ACCESS_MODE_READ_ONLY = 0,
  ACCESS_MODE_READ_WRITE = 1,
  ACCESS_MODE_READ_WRITE_ONCE = 2,
  ACCESS_MODE_WRITE_ONCE = 3,
  ACCESS_MODE_WRITE_ONLY = 4,
  UNRECOGNIZED = -1,
}

export function workspace_AccessModeFromJSON(object: any): Workspace_AccessMode {
  switch (object) {
    case 0:
    case "ACCESS_MODE_READ_ONLY":
      return Workspace_AccessMode.ACCESS_MODE_READ_ONLY;
    case 1:
    case "ACCESS_MODE_READ_WRITE":
      return Workspace_AccessMode.ACCESS_MODE_READ_WRITE;
    case 2:
    case "ACCESS_MODE_READ_WRITE_ONCE":
      return Workspace_AccessMode.ACCESS_MODE_READ_WRITE_ONCE;
    case 3:
    case "ACCESS_MODE_WRITE_ONCE":
      return Workspace_AccessMode.ACCESS_MODE_WRITE_ONCE;
    case 4:
    case "ACCESS_MODE_WRITE_ONLY":
      return Workspace_AccessMode.ACCESS_MODE_WRITE_ONLY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Workspace_AccessMode.UNRECOGNIZED;
  }
}

export function workspace_AccessModeToJSON(object: Workspace_AccessMode): string {
  switch (object) {
    case Workspace_AccessMode.ACCESS_MODE_READ_ONLY:
      return "ACCESS_MODE_READ_ONLY";
    case Workspace_AccessMode.ACCESS_MODE_READ_WRITE:
      return "ACCESS_MODE_READ_WRITE";
    case Workspace_AccessMode.ACCESS_MODE_READ_WRITE_ONCE:
      return "ACCESS_MODE_READ_WRITE_ONCE";
    case Workspace_AccessMode.ACCESS_MODE_WRITE_ONCE:
      return "ACCESS_MODE_WRITE_ONCE";
    case Workspace_AccessMode.ACCESS_MODE_WRITE_ONLY:
      return "ACCESS_MODE_WRITE_ONLY";
    case Workspace_AccessMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** An identifiable, logical unit of data storage tied to a physical device. */
export interface Volume {
  /** The unique identifier for the volume instance within its deployment context. */
  uid?:
    | string
    | undefined;
  /** The name of the volume instance */
  name?:
    | string
    | undefined;
  /** The volume mode for the volume instance. */
  mode?:
    | Volume_VolumeMode
    | undefined;
  /** The underlying path created from the actual volume. */
  path?:
    | string
    | undefined;
  /** The allocated size of the volume accessible to the associated workspace. This should include the scalar size as well as the IEC standard unit in either decimal or binary form. */
  sizeAllocated?:
    | string
    | undefined;
  /** Indicates if the volume persists beyond the life of the resource it is associated with. */
  persistent?:
    | boolean
    | undefined;
  /** Indicates if the volume is remotely (i.e., network) attached. */
  remote?:
    | boolean
    | undefined;
  /** Domain-specific volume instance properties. */
  properties: Property[];
}

export enum Volume_VolumeMode {
  /** VOLUME_MODE_FILESYSTEM - buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema */
  VOLUME_MODE_FILESYSTEM = 0,
  VOLUME_MODE_BLOCK = 1,
  UNRECOGNIZED = -1,
}

export function volume_VolumeModeFromJSON(object: any): Volume_VolumeMode {
  switch (object) {
    case 0:
    case "VOLUME_MODE_FILESYSTEM":
      return Volume_VolumeMode.VOLUME_MODE_FILESYSTEM;
    case 1:
    case "VOLUME_MODE_BLOCK":
      return Volume_VolumeMode.VOLUME_MODE_BLOCK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Volume_VolumeMode.UNRECOGNIZED;
  }
}

export function volume_VolumeModeToJSON(object: Volume_VolumeMode): string {
  switch (object) {
    case Volume_VolumeMode.VOLUME_MODE_FILESYSTEM:
      return "VOLUME_MODE_FILESYSTEM";
    case Volume_VolumeMode.VOLUME_MODE_BLOCK:
      return "VOLUME_MODE_BLOCK";
    case Volume_VolumeMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents a resource that can conditionally activate (or fire) tasks based upon associated events and their data. */
export interface Trigger {
  /** BOM unique reference to the resource. */
  bomRef: string;
  /** The unique identifier for the resource instance within its deployment context. */
  uid: string;
  /** The name of the resource instance. */
  name?:
    | string
    | undefined;
  /** A description of the resource instance. */
  description?:
    | string
    | undefined;
  /** Additional properties of the trigger. */
  properties: Property[];
  /** References to component or service resources that are used to realize the resource instance. */
  resourceReferences: ResourceReferenceChoice[];
  /** The source type of event which caused the trigger to fire. */
  type: Trigger_TriggerType;
  /** The event data that caused the associated trigger to activate. */
  event?:
    | Event
    | undefined;
  /** A list of conditions used to determine if a trigger should be activated. */
  conditions: Condition[];
  /** The date and time (timestamp) when the trigger was activated. */
  timeActivated?:
    | Date
    | undefined;
  /** Represents resources and data brought into a task at runtime by an executor or task commands */
  inputs: InputType[];
  /** Represents resources and data output from a task at runtime by an executor or task commands */
  outputs: OutputType[];
}

export enum Trigger_TriggerType {
  /** TRIGGER_TYPE_MANUAL - buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema */
  TRIGGER_TYPE_MANUAL = 0,
  TRIGGER_TYPE_API = 1,
  TRIGGER_TYPE_WEBHOOK = 2,
  TRIGGER_TYPE_SCHEDULED = 3,
  UNRECOGNIZED = -1,
}

export function trigger_TriggerTypeFromJSON(object: any): Trigger_TriggerType {
  switch (object) {
    case 0:
    case "TRIGGER_TYPE_MANUAL":
      return Trigger_TriggerType.TRIGGER_TYPE_MANUAL;
    case 1:
    case "TRIGGER_TYPE_API":
      return Trigger_TriggerType.TRIGGER_TYPE_API;
    case 2:
    case "TRIGGER_TYPE_WEBHOOK":
      return Trigger_TriggerType.TRIGGER_TYPE_WEBHOOK;
    case 3:
    case "TRIGGER_TYPE_SCHEDULED":
      return Trigger_TriggerType.TRIGGER_TYPE_SCHEDULED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Trigger_TriggerType.UNRECOGNIZED;
  }
}

export function trigger_TriggerTypeToJSON(object: Trigger_TriggerType): string {
  switch (object) {
    case Trigger_TriggerType.TRIGGER_TYPE_MANUAL:
      return "TRIGGER_TYPE_MANUAL";
    case Trigger_TriggerType.TRIGGER_TYPE_API:
      return "TRIGGER_TYPE_API";
    case Trigger_TriggerType.TRIGGER_TYPE_WEBHOOK:
      return "TRIGGER_TYPE_WEBHOOK";
    case Trigger_TriggerType.TRIGGER_TYPE_SCHEDULED:
      return "TRIGGER_TYPE_SCHEDULED";
    case Trigger_TriggerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Represents something that happened that may trigger a response. */
export interface Event {
  /** The unique identifier of the event. */
  uid?:
    | string
    | undefined;
  /** A description of the event. */
  description?:
    | string
    | undefined;
  /** The date and time (timestamp) when the event was received. */
  timeReceived?:
    | Date
    | undefined;
  /** Encoding of the raw event data. */
  data?:
    | AttachedText
    | undefined;
  /** References the component or service that was the source of the event */
  source?:
    | ResourceReferenceChoice
    | undefined;
  /** References the component or service that was the target of the event */
  target?:
    | ResourceReferenceChoice
    | undefined;
  /** Additional properties of the event. */
  properties: Property[];
}

/** Type that represents various input data types and formats. */
export interface InputType {
  /** A references to the component or service that provided the input to the task (e.g., reference to a service with a data flow value of `inbound`) */
  source?:
    | ResourceReferenceChoice
    | undefined;
  /** A reference to the component or service that received or stored the input if not the task itself (e.g., a local, named storage workspace) */
  target?:
    | ResourceReferenceChoice
    | undefined;
  /** A reference to an independent resource provided as an input to a task by the workflow runtime. */
  resource?:
    | ResourceReferenceChoice
    | undefined;
  /** Inputs that have the form of parameters with names and values. */
  parameters: Parameter[];
  /** Inputs that have the form of parameters with names and values. */
  environmentVars: EnvironmentVars[];
  /** Inputs that have the form of data. */
  data?:
    | AttachedText
    | undefined;
  /** Additional properties of the input data. */
  properties: Property[];
}

/** Type that represents various output data types and formats. */
export interface OutputType {
  /** Describes the type of data output. */
  type?:
    | OutputType_OutputTypeType
    | undefined;
  /** Component or service that generated or provided the output from the task (e.g., a build tool) */
  source?:
    | ResourceReferenceChoice
    | undefined;
  /** Component or service that received the output from the task (e.g., reference to an artifactory service with data flow value of `outbound`) */
  target?:
    | ResourceReferenceChoice
    | undefined;
  /** A reference to an independent resource generated as output by the task. */
  resource?:
    | ResourceReferenceChoice
    | undefined;
  /** Outputs that have the form of data. */
  data?:
    | AttachedText
    | undefined;
  /** Outputs that have the form of environment variables. */
  environmentVars: EnvironmentVars[];
  /** Additional properties of the output data. */
  properties: Property[];
}

/** buf:lint:ignore ENUM_VALUE_PREFIX -- Enum value names should be prefixed with "OUTPUT_TYPE_TYPE_" */
export enum OutputType_OutputTypeType {
  /** OUTPUT_TYPE_ARTIFACT - buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX -- value `0` is a fallback(meaning "unspecified") in protobuf3. this usage here is an error; it shall be fixed with v2.0 of this very schema */
  OUTPUT_TYPE_ARTIFACT = 0,
  OUTPUT_TYPE_ATTESTATION = 1,
  OUTPUT_TYPE_LOG = 2,
  OUTPUT_TYPE_EVIDENCE = 3,
  OUTPUT_TYPE_METRICS = 4,
  OUTPUT_TYPE_OTHER = 5,
  UNRECOGNIZED = -1,
}

export function outputType_OutputTypeTypeFromJSON(object: any): OutputType_OutputTypeType {
  switch (object) {
    case 0:
    case "OUTPUT_TYPE_ARTIFACT":
      return OutputType_OutputTypeType.OUTPUT_TYPE_ARTIFACT;
    case 1:
    case "OUTPUT_TYPE_ATTESTATION":
      return OutputType_OutputTypeType.OUTPUT_TYPE_ATTESTATION;
    case 2:
    case "OUTPUT_TYPE_LOG":
      return OutputType_OutputTypeType.OUTPUT_TYPE_LOG;
    case 3:
    case "OUTPUT_TYPE_EVIDENCE":
      return OutputType_OutputTypeType.OUTPUT_TYPE_EVIDENCE;
    case 4:
    case "OUTPUT_TYPE_METRICS":
      return OutputType_OutputTypeType.OUTPUT_TYPE_METRICS;
    case 5:
    case "OUTPUT_TYPE_OTHER":
      return OutputType_OutputTypeType.OUTPUT_TYPE_OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OutputType_OutputTypeType.UNRECOGNIZED;
  }
}

export function outputType_OutputTypeTypeToJSON(object: OutputType_OutputTypeType): string {
  switch (object) {
    case OutputType_OutputTypeType.OUTPUT_TYPE_ARTIFACT:
      return "OUTPUT_TYPE_ARTIFACT";
    case OutputType_OutputTypeType.OUTPUT_TYPE_ATTESTATION:
      return "OUTPUT_TYPE_ATTESTATION";
    case OutputType_OutputTypeType.OUTPUT_TYPE_LOG:
      return "OUTPUT_TYPE_LOG";
    case OutputType_OutputTypeType.OUTPUT_TYPE_EVIDENCE:
      return "OUTPUT_TYPE_EVIDENCE";
    case OutputType_OutputTypeType.OUTPUT_TYPE_METRICS:
      return "OUTPUT_TYPE_METRICS";
    case OutputType_OutputTypeType.OUTPUT_TYPE_OTHER:
      return "OUTPUT_TYPE_OTHER";
    case OutputType_OutputTypeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Type that permits a choice to reference a resource using an iternal bom-ref identifier or an external reference. */
export interface ResourceReferenceChoice {
  /** References an object by its bom-ref attribute */
  ref?:
    | string
    | undefined;
  /** Reference to an externally accessible resource */
  externalReference?: ExternalReference | undefined;
}

/** A condition that was used to determine a trigger should be activated. */
export interface Condition {
  /** Describes the set of conditions which cause the trigger to activate. */
  description?:
    | string
    | undefined;
  /** The logical expression that was evaluated that determined the trigger should be fired. */
  expression?:
    | string
    | undefined;
  /** Domain-specific condition instance properties. */
  properties: Property[];
}

/** A representation of a functional parameter. */
export interface Parameter {
  /** The name of the parameter. */
  name?:
    | string
    | undefined;
  /** The value of the parameter. */
  value?:
    | string
    | undefined;
  /** The data type of the parameter. */
  dataType?: string | undefined;
}

export interface EnvironmentVars {
  /** Name-value pair */
  property?:
    | Property
    | undefined;
  /** Value */
  value?: string | undefined;
}

/** The list of declarations which describe the conformance to standards. Each declaration may include attestations, claims, and evidence. */
export interface Declarations {
  /** The list of assessors evaluating claims and determining conformance to requirements and confidence in that assessment. */
  assessors: Declarations_Assessor[];
  /** The list of attestations asserted by an assessor that maps requirements to claims. */
  attestations: Declarations_Attestation[];
  /** The list of claims. */
  claims: Declarations_Claim[];
  /** The list of evidence */
  evidence: Declarations_Evidence[];
  /** The list of targets which claims are made against. */
  targets?:
    | Declarations_Targets
    | undefined;
  /** A concise statement affirmed by an individual regarding all declarations, often used for third-party auditor acceptance or recipient acknowledgment. It includes a list of authorized signatories who assert the validity of the document on behalf of the organization. */
  affirmation?: Declarations_Affirmation | undefined;
}

export interface Declarations_Assessor {
  /** An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element. */
  bomRef?:
    | string
    | undefined;
  /** The boolean indicating if the assessor is outside the organization generating claims. A value of false indicates a self assessor. */
  thirdParty?:
    | boolean
    | undefined;
  /** The entity issuing the assessment. */
  organization?: OrganizationalEntity | undefined;
}

/** Attestation */
export interface Declarations_Attestation {
  /** The short description explaining the main points of the attestation. */
  summary?:
    | string
    | undefined;
  /** The `bom-ref` to the assessor asserting the attestation. */
  assessor?:
    | string
    | undefined;
  /** The grouping of requirements to claims and the attestors' declared conformance and confidence thereof. */
  map: Declarations_Attestation_AttestationMap[];
}

/** Map */
export interface Declarations_Attestation_AttestationMap {
  /** The `bom-ref` to the requirement being attested to. */
  requirement?:
    | string
    | undefined;
  /** The list of `bom-ref` to the claims being attested to. */
  claims: string[];
  /** The list of  `bom-ref` to the counter claims being attested to. */
  counterClaims: string[];
  /** The conformance of the claim meeting a requirement. */
  conformance?:
    | Declarations_Attestation_AttestationMap_AttestationConformance
    | undefined;
  /** The confidence of the claim meeting the requirement. */
  confidence?: Declarations_Attestation_AttestationMap_AttestationConfidence | undefined;
}

/** Conformance */
export interface Declarations_Attestation_AttestationMap_AttestationConformance {
  /** The conformance of the claim between and inclusive of 0 and 1, where 1 is 100% conformance. */
  score?:
    | number
    | undefined;
  /** The rationale for the conformance score. */
  rationale?:
    | string
    | undefined;
  /** The list of  `bom-ref` to the evidence provided describing the mitigation strategies. */
  mitigationStrategies: string[];
}

/** Confidence */
export interface Declarations_Attestation_AttestationMap_AttestationConfidence {
  /** The confidence of the claim between and inclusive of 0 and 1, where 1 is 100% confidence. */
  score?:
    | number
    | undefined;
  /** The rationale for the confidence score. */
  rationale?: string | undefined;
}

export interface Declarations_Claim {
  /** An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element. */
  bomRef?:
    | string
    | undefined;
  /** The `bom-ref` to a target representing a specific system, application, API, module, team, person, process, business unit, company, etc...  that this claim is being applied to. */
  target?:
    | string
    | undefined;
  /** The specific statement or assertion about the target. */
  predicate?:
    | string
    | undefined;
  /** The list of  `bom-ref` to the evidence provided describing the mitigation strategies. Each mitigation strategy should include an explanation of how any weaknesses in the evidence will be mitigated. */
  mitigationStrategies: string[];
  /** The written explanation of why the evidence provided substantiates the claim. */
  reasoning?:
    | string
    | undefined;
  /** The list of `bom-ref` to evidence that supports this claim. */
  evidence: string[];
  /** The list of `bom-ref` to counterEvidence that supports this claim. */
  counterEvidence: string[];
  /** External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM. */
  externalReferences: ExternalReference[];
}

export interface Declarations_Evidence {
  /** An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element. */
  bomRef?:
    | string
    | undefined;
  /** The reference to the property name as defined in the CycloneDX Property Taxonomy: https://github.com/CycloneDX/cyclonedx-property-taxonomy/. */
  propertyName?:
    | string
    | undefined;
  /** The written description of what this evidence is and how it was created. */
  description?:
    | string
    | undefined;
  /** The output or analysis that supports claims. */
  data: Declarations_Evidence_Data[];
  /** The date and time (timestamp) when the evidence was created. */
  created?:
    | Date
    | undefined;
  /** The optional date and time (timestamp) when the evidence is no longer valid. */
  expires?:
    | Date
    | undefined;
  /** The author of the evidence. */
  author?:
    | OrganizationalContact
    | undefined;
  /** The reviewer of the evidence. */
  reviewer?: OrganizationalContact | undefined;
}

export interface Declarations_Evidence_Data {
  /** The name of the data. */
  name?:
    | string
    | undefined;
  /** The contents or references to the contents of the data being described. */
  contents?:
    | Declarations_Evidence_Data_Contents
    | undefined;
  /** Data classification tags data according to its type, sensitivity, and value if altered, stolen, or destroyed. */
  classification?:
    | string
    | undefined;
  /** A description of any sensitive data included. */
  sensitiveData: string[];
  /** Data Governance */
  governance?: DataGovernance | undefined;
}

export interface Declarations_Evidence_Data_Contents {
  /** An optional way to include textual or encoded data. */
  attachment?:
    | AttachedText
    | undefined;
  /** The URL to where the data can be retrieved. */
  url?: string | undefined;
}

export interface Declarations_Targets {
  /** The list of organizations which claims are made against. */
  organizations: OrganizationalEntity[];
  /** The list of components which claims are made against. */
  components: Component[];
  /** The list of services which claims are made against. */
  services: Service[];
}

export interface Declarations_Affirmation {
  /** The brief statement affirmed by an individual regarding all declarations. Notes: This could be an affirmation of acceptance by a third-party auditor or receiving individual of a file.  Example: "I certify, to the best of my knowledge, that all information is correct." */
  statement?:
    | string
    | undefined;
  /** The list of signatories authorized on behalf of an organization to assert validity of this document. */
  signatories: Declarations_Affirmation_Signatory[];
}

export interface Declarations_Affirmation_Signatory {
  /** The signatory's name. */
  name?:
    | string
    | undefined;
  /** The signatory's role within an organization. */
  role?:
    | string
    | undefined;
  /** The signatory's organization. */
  organization?:
    | OrganizationalEntity
    | undefined;
  /** An External reference provides a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM. */
  externalReference?: ExternalReference | undefined;
}

export interface Definition {
  /** The list of standards which may consist of regulations, industry or organizational-specific standards, maturity models, best practices, or any other requirements which can be evaluated against or attested to. */
  standards: Definition_Standard[];
}

/** A standard may consist of regulations, industry or organizational-specific standards, maturity models, best practices, or any other requirements which can be evaluated against or attested to. */
export interface Definition_Standard {
  /** An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element. */
  bomRef?:
    | string
    | undefined;
  /** The name of the standard. This will often be a shortened, single name of the standard. */
  name?:
    | string
    | undefined;
  /** The version of the standard. */
  version?:
    | string
    | undefined;
  /** The description of the standard. */
  description?:
    | string
    | undefined;
  /** The owner of the standard, often the entity responsible for its release. */
  owner?:
    | string
    | undefined;
  /** The list of requirements comprising the standard. */
  requirements: Definition_Standard_Requirement[];
  /** The list of levels associated with the standard. Some standards have different levels of compliance. */
  levels: Definition_Standard_Level[];
  /** External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM. */
  externalReferences: ExternalReference[];
}

export interface Definition_Standard_Requirement {
  /** An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element. */
  bomRef?:
    | string
    | undefined;
  /** The unique identifier used in the standard to identify a specific requirement. This should match what is in the standard and should not be the requirements bom-ref. */
  identifier?:
    | string
    | undefined;
  /** The title of the requirement. */
  title?:
    | string
    | undefined;
  /** The textual content of the requirement. */
  text?:
    | string
    | undefined;
  /** The supplemental text that provides additional guidance or context to the requirement but is not directly part of the requirement. */
  descriptions: string[];
  /** The Common Requirements Enumeration (CRE) identifier(s). CRE is a structured and standardized framework for uniting security standards and guidelines. CRE links each section of a resource to a shared topic identifier (a Common Requirement). Through this shared topic link, all resources map to each other. The use of CRE promotes clear and unambiguous communication among stakeholders. */
  openCre: string[];
  /** The optional `bom-ref` to a parent requirement. This establishes a hierarchy of requirements. Top-level requirements must not define a parent. Only child requirements should define parents. */
  parent?:
    | string
    | undefined;
  /** Specifies optional, custom, properties */
  properties: Property[];
  /** External references provide a way to document systems, sites, and information that may be relevant but are not included with the BOM. They may also establish specific relationships within or external to the BOM. */
  externalReferences: ExternalReference[];
}

export interface Definition_Standard_Level {
  /** An optional identifier which can be used to reference the component elsewhere in the BOM. Uniqueness is enforced within all elements and children of the root-level bom element. */
  bomRef?:
    | string
    | undefined;
  /** The identifier used in the standard to identify a specific level. */
  identifier?:
    | string
    | undefined;
  /** The title of the level. */
  title?:
    | string
    | undefined;
  /** The description of the level. */
  description?:
    | string
    | undefined;
  /** The list of requirement `bom-ref`s that comprise the level. */
  requirements: string[];
}

/** "Cryptographic Properties */
export interface CryptoProperties {
  /** Cryptographic assets occur in several forms. Algorithms and protocols are most commonly implemented in specialized cryptographic libraries. They may, however, also be 'hardcoded' in software components. Certificates and related cryptographic material like keys, tokens, secrets or passwords are other cryptographic assets to be modelled. */
  assetType: CryptoProperties_CryptoAssetType;
  /** Additional properties specific to a cryptographic algorithm. */
  algorithmProperties?:
    | CryptoProperties_AlgorithmProperties
    | undefined;
  /** Properties for cryptographic assets of asset type 'certificate' */
  certificateProperties?:
    | CryptoProperties_CertificateProperties
    | undefined;
  /** Properties for cryptographic assets of asset type: `related-crypto-material` */
  relatedCryptoMaterialProperties?:
    | CryptoProperties_RelatedCryptoMaterialProperties
    | undefined;
  /** Properties specific to cryptographic assets of type: `protocol`. */
  protocolProperties?:
    | CryptoProperties_ProtocolProperties
    | undefined;
  /** The object identifier (OID) of the cryptographic asset. */
  oid?: string | undefined;
}

/** Asset Type */
export enum CryptoProperties_CryptoAssetType {
  /** CRYPTO_ASSET_TYPE_UNSPECIFIED - ProtoBuff's default value */
  CRYPTO_ASSET_TYPE_UNSPECIFIED = 0,
  /** CRYPTO_ASSET_TYPE_ALGORITHM - Mathematical function commonly used for data encryption, authentication, and digital signatures. */
  CRYPTO_ASSET_TYPE_ALGORITHM = 1,
  /** CRYPTO_ASSET_TYPE_CERTIFICATE - An electronic document that is used to provide the identity or validate a public key. */
  CRYPTO_ASSET_TYPE_CERTIFICATE = 2,
  /** CRYPTO_ASSET_TYPE_PROTOCOL - A set of rules and guidelines that govern the behavior and communication with each other. */
  CRYPTO_ASSET_TYPE_PROTOCOL = 3,
  /** CRYPTO_ASSET_TYPE_RELATED_CRYPTO_MATERIAL - Other cryptographic assets related to algorithms, certificates, and protocols such as keys and tokens. */
  CRYPTO_ASSET_TYPE_RELATED_CRYPTO_MATERIAL = 4,
  UNRECOGNIZED = -1,
}

export function cryptoProperties_CryptoAssetTypeFromJSON(object: any): CryptoProperties_CryptoAssetType {
  switch (object) {
    case 0:
    case "CRYPTO_ASSET_TYPE_UNSPECIFIED":
      return CryptoProperties_CryptoAssetType.CRYPTO_ASSET_TYPE_UNSPECIFIED;
    case 1:
    case "CRYPTO_ASSET_TYPE_ALGORITHM":
      return CryptoProperties_CryptoAssetType.CRYPTO_ASSET_TYPE_ALGORITHM;
    case 2:
    case "CRYPTO_ASSET_TYPE_CERTIFICATE":
      return CryptoProperties_CryptoAssetType.CRYPTO_ASSET_TYPE_CERTIFICATE;
    case 3:
    case "CRYPTO_ASSET_TYPE_PROTOCOL":
      return CryptoProperties_CryptoAssetType.CRYPTO_ASSET_TYPE_PROTOCOL;
    case 4:
    case "CRYPTO_ASSET_TYPE_RELATED_CRYPTO_MATERIAL":
      return CryptoProperties_CryptoAssetType.CRYPTO_ASSET_TYPE_RELATED_CRYPTO_MATERIAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CryptoProperties_CryptoAssetType.UNRECOGNIZED;
  }
}

export function cryptoProperties_CryptoAssetTypeToJSON(object: CryptoProperties_CryptoAssetType): string {
  switch (object) {
    case CryptoProperties_CryptoAssetType.CRYPTO_ASSET_TYPE_UNSPECIFIED:
      return "CRYPTO_ASSET_TYPE_UNSPECIFIED";
    case CryptoProperties_CryptoAssetType.CRYPTO_ASSET_TYPE_ALGORITHM:
      return "CRYPTO_ASSET_TYPE_ALGORITHM";
    case CryptoProperties_CryptoAssetType.CRYPTO_ASSET_TYPE_CERTIFICATE:
      return "CRYPTO_ASSET_TYPE_CERTIFICATE";
    case CryptoProperties_CryptoAssetType.CRYPTO_ASSET_TYPE_PROTOCOL:
      return "CRYPTO_ASSET_TYPE_PROTOCOL";
    case CryptoProperties_CryptoAssetType.CRYPTO_ASSET_TYPE_RELATED_CRYPTO_MATERIAL:
      return "CRYPTO_ASSET_TYPE_RELATED_CRYPTO_MATERIAL";
    case CryptoProperties_CryptoAssetType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Algorithm Propertie */
export interface CryptoProperties_AlgorithmProperties {
  /** Cryptographic building blocks used in higher-level cryptographic systems and protocols. Primitives represent different cryptographic routines: deterministic random bit generators (drbg, e.g. CTR_DRBG from NIST SP800-90A-r1), message authentication codes (mac, e.g. HMAC-SHA-256), blockciphers (e.g. AES), streamciphers (e.g. Salsa20), signatures (e.g. ECDSA), hash functions (e.g. SHA-256), public-key encryption schemes (pke, e.g. RSA), extended output functions (xof, e.g. SHAKE256), key derivation functions (e.g. pbkdf2), key agreement algorithms (e.g. ECDH), key encapsulation mechanisms (e.g. ML-KEM), authenticated encryption (ae, e.g. AES-GCM) and the combination of multiple algorithms (combiner, e.g. SP800-56Cr2). */
  primitive?:
    | CryptoProperties_AlgorithmProperties_CryptoPrimitive
    | undefined;
  /** An identifier for the parameter set of the cryptographic algorithm. Examples: in AES128, '128' identifies the key length in bits, in SHA256, '256' identifies the digest length, '128' in SHAKE128 identifies its maximum security level in bits, and 'SHA2-128s' identifies a parameter set used in SLH-DSA (FIPS205). */
  parameterSetIdentifier?:
    | string
    | undefined;
  /** The specific underlying Elliptic Curve (EC) definition employed which is an indicator of the level of security strength, performance and complexity. Absent an authoritative source of curve names, CycloneDX recommends use of curve names as defined at [https://neuromancer.sk/std/](https://neuromancer.sk/std/), the source from which can be found at [https://github.com/J08nY/std-curves](https://github.com/J08nY/std-curves). */
  curve?:
    | string
    | undefined;
  /** The target and execution environment in which the algorithm is implemented in. */
  executionEnvironment?:
    | CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment
    | undefined;
  /** The target platform for which the algorithm is implemented. The implementation can be 'generic', running on any platform or for a specific platform. */
  implementationPlatform?:
    | CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform
    | undefined;
  /** The certification that the implementation of the cryptographic algorithm has received, if any. Certifications include revisions and levels of FIPS 140 or Common Criteria of different Extended Assurance Levels (CC-EAL). */
  certificationLevel: string[];
  /** The mode of operation in which the cryptographic algorithm (block cipher) is used. */
  mode?:
    | CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode
    | undefined;
  /** The padding scheme that is used for the cryptographic algorithm. */
  padding?:
    | CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding
    | undefined;
  /** The cryptographic functions implemented by the cryptographic algorithm. */
  cryptoFunctions: CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction[];
  /** The classical security level that a cryptographic algorithm provides (in bits). */
  classicalSecurityLevel?:
    | number
    | undefined;
  /** The NIST security strength category as defined in https://csrc.nist.gov/projects/post-quantum-cryptography/post-quantum-cryptography-standardization/evaluation-criteria/security-(evaluation-criteria). A value of 0 indicates that none of the categories are met. */
  nistQuantumSecurityLevel?: number | undefined;
}

/** Primitive */
export enum CryptoProperties_AlgorithmProperties_CryptoPrimitive {
  /** CRYPTO_PRIMITIVE_UNSPECIFIED - ProtoBuff's default value -- it differs from "unknown" */
  CRYPTO_PRIMITIVE_UNSPECIFIED = 0,
  /** CRYPTO_PRIMITIVE_UNKNOWN - The primitive is not known */
  CRYPTO_PRIMITIVE_UNKNOWN = 1,
  /** CRYPTO_PRIMITIVE_OTHER - Another primitive type - none of the following */
  CRYPTO_PRIMITIVE_OTHER = 2,
  /** CRYPTO_PRIMITIVE_DRBG - Deterministic Random Bit Generator (DRBG) is a type of pseudorandom number generator designed to produce a sequence of bits from an initial seed value. DRBGs are commonly used in cryptographic applications where reproducibility of random values is important. */
  CRYPTO_PRIMITIVE_DRBG = 3,
  /** CRYPTO_PRIMITIVE_MAC - In cryptography, a Message Authentication Code (MAC) is information used for authenticating and integrity-checking a message. */
  CRYPTO_PRIMITIVE_MAC = 4,
  /** CRYPTO_PRIMITIVE_BLOCK_CIPHER - A block cipher is a symmetric key algorithm that operates on fixed-size blocks of data. It encrypts or decrypts the data in block units, providing confidentiality. Block ciphers are widely used in various cryptographic modes and protocols for secure data transmission. */
  CRYPTO_PRIMITIVE_BLOCK_CIPHER = 5,
  /** CRYPTO_PRIMITIVE_STREAM_CIPHER - A stream cipher is a symmetric key cipher where plaintext digits are combined with a pseudorandom cipher digit stream (keystream). */
  CRYPTO_PRIMITIVE_STREAM_CIPHER = 6,
  /** CRYPTO_PRIMITIVE_SIGNATURE - In cryptography, a signature is a digital representation of a message or data that proves its origin, identity, and integrity. Digital signatures are generated using cryptographic algorithms and are widely used for authentication and verification in secure communication. */
  CRYPTO_PRIMITIVE_SIGNATURE = 7,
  /** CRYPTO_PRIMITIVE_HASH - A hash function is a mathematical algorithm that takes an input (or 'message') and produces a fixed-size string of characters, which is typically a hash value. Hash functions are commonly used in various cryptographic applications, including data integrity verification and password hashing. */
  CRYPTO_PRIMITIVE_HASH = 8,
  /** CRYPTO_PRIMITIVE_PKE - Public Key Encryption (PKE) is a type of encryption that uses a pair of public and private keys for secure communication. The public key is used for encryption, while the private key is used for decryption. PKE is a fundamental component of public-key cryptography. */
  CRYPTO_PRIMITIVE_PKE = 9,
  /** CRYPTO_PRIMITIVE_XOF - An XOF is an extendable output function that can take arbitrary input and creates a stream of output, up to a limit determined by the size of the internal state of the hash function that underlies the XOF. */
  CRYPTO_PRIMITIVE_XOF = 10,
  /** CRYPTO_PRIMITIVE_KDF - A Key Derivation Function (KDF) derives key material from another source of entropy while preserving the entropy of the input. */
  CRYPTO_PRIMITIVE_KDF = 11,
  /** CRYPTO_PRIMITIVE_KEY_AGREE - In cryptography, a key-agreement is a protocol whereby two or more parties agree on a cryptographic key in such a way that both influence the outcome. */
  CRYPTO_PRIMITIVE_KEY_AGREE = 12,
  /** CRYPTO_PRIMITIVE_KEM - A Key Encapsulation Mechanism (KEM) algorithm is a mechanism for transporting random keying material to a recipient using the recipient's public key. */
  CRYPTO_PRIMITIVE_KEM = 13,
  /** CRYPTO_PRIMITIVE_AE - Authenticated Encryption (AE) is a cryptographic process that provides both confidentiality and data integrity. It ensures that the encrypted data has not been tampered with and comes from a legitimate source. AE is commonly used in secure communication protocols. */
  CRYPTO_PRIMITIVE_AE = 14,
  /** CRYPTO_PRIMITIVE_COMBINER - A combiner aggregates many candidates for a cryptographic primitive and generates a new candidate for the same primitive. */
  CRYPTO_PRIMITIVE_COMBINER = 15,
  UNRECOGNIZED = -1,
}

export function cryptoProperties_AlgorithmProperties_CryptoPrimitiveFromJSON(
  object: any,
): CryptoProperties_AlgorithmProperties_CryptoPrimitive {
  switch (object) {
    case 0:
    case "CRYPTO_PRIMITIVE_UNSPECIFIED":
      return CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_UNSPECIFIED;
    case 1:
    case "CRYPTO_PRIMITIVE_UNKNOWN":
      return CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_UNKNOWN;
    case 2:
    case "CRYPTO_PRIMITIVE_OTHER":
      return CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_OTHER;
    case 3:
    case "CRYPTO_PRIMITIVE_DRBG":
      return CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_DRBG;
    case 4:
    case "CRYPTO_PRIMITIVE_MAC":
      return CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_MAC;
    case 5:
    case "CRYPTO_PRIMITIVE_BLOCK_CIPHER":
      return CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_BLOCK_CIPHER;
    case 6:
    case "CRYPTO_PRIMITIVE_STREAM_CIPHER":
      return CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_STREAM_CIPHER;
    case 7:
    case "CRYPTO_PRIMITIVE_SIGNATURE":
      return CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_SIGNATURE;
    case 8:
    case "CRYPTO_PRIMITIVE_HASH":
      return CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_HASH;
    case 9:
    case "CRYPTO_PRIMITIVE_PKE":
      return CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_PKE;
    case 10:
    case "CRYPTO_PRIMITIVE_XOF":
      return CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_XOF;
    case 11:
    case "CRYPTO_PRIMITIVE_KDF":
      return CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_KDF;
    case 12:
    case "CRYPTO_PRIMITIVE_KEY_AGREE":
      return CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_KEY_AGREE;
    case 13:
    case "CRYPTO_PRIMITIVE_KEM":
      return CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_KEM;
    case 14:
    case "CRYPTO_PRIMITIVE_AE":
      return CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_AE;
    case 15:
    case "CRYPTO_PRIMITIVE_COMBINER":
      return CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_COMBINER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CryptoProperties_AlgorithmProperties_CryptoPrimitive.UNRECOGNIZED;
  }
}

export function cryptoProperties_AlgorithmProperties_CryptoPrimitiveToJSON(
  object: CryptoProperties_AlgorithmProperties_CryptoPrimitive,
): string {
  switch (object) {
    case CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_UNSPECIFIED:
      return "CRYPTO_PRIMITIVE_UNSPECIFIED";
    case CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_UNKNOWN:
      return "CRYPTO_PRIMITIVE_UNKNOWN";
    case CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_OTHER:
      return "CRYPTO_PRIMITIVE_OTHER";
    case CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_DRBG:
      return "CRYPTO_PRIMITIVE_DRBG";
    case CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_MAC:
      return "CRYPTO_PRIMITIVE_MAC";
    case CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_BLOCK_CIPHER:
      return "CRYPTO_PRIMITIVE_BLOCK_CIPHER";
    case CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_STREAM_CIPHER:
      return "CRYPTO_PRIMITIVE_STREAM_CIPHER";
    case CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_SIGNATURE:
      return "CRYPTO_PRIMITIVE_SIGNATURE";
    case CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_HASH:
      return "CRYPTO_PRIMITIVE_HASH";
    case CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_PKE:
      return "CRYPTO_PRIMITIVE_PKE";
    case CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_XOF:
      return "CRYPTO_PRIMITIVE_XOF";
    case CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_KDF:
      return "CRYPTO_PRIMITIVE_KDF";
    case CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_KEY_AGREE:
      return "CRYPTO_PRIMITIVE_KEY_AGREE";
    case CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_KEM:
      return "CRYPTO_PRIMITIVE_KEM";
    case CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_AE:
      return "CRYPTO_PRIMITIVE_AE";
    case CryptoProperties_AlgorithmProperties_CryptoPrimitive.CRYPTO_PRIMITIVE_COMBINER:
      return "CRYPTO_PRIMITIVE_COMBINER";
    case CryptoProperties_AlgorithmProperties_CryptoPrimitive.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Execution Environment */
export enum CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment {
  /** CRYPTO_EXECUTION_ENVIRONMENT_UNSPECIFIED - ProtoBuff's default value -- it differs from "unknown" */
  CRYPTO_EXECUTION_ENVIRONMENT_UNSPECIFIED = 0,
  /** CRYPTO_EXECUTION_ENVIRONMENT_UNKNOWN - The execution environment is not known */
  CRYPTO_EXECUTION_ENVIRONMENT_UNKNOWN = 1,
  /** CRYPTO_EXECUTION_ENVIRONMENT_OTHER - Another implementation environment - none of the following */
  CRYPTO_EXECUTION_ENVIRONMENT_OTHER = 2,
  /** CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_PLAIN_RAM - A software implementation running in plain unencrypted RAM. */
  CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_PLAIN_RAM = 3,
  /** CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_ENCRYPTED_RAM - A software implementation running in encrypted RAM. */
  CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_ENCRYPTED_RAM = 4,
  /** CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_TEE - A software implementation running in a trusted execution environment. */
  CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_TEE = 5,
  /** CRYPTO_EXECUTION_ENVIRONMENT_HARDWARE - A hardware implementation. */
  CRYPTO_EXECUTION_ENVIRONMENT_HARDWARE = 6,
  UNRECOGNIZED = -1,
}

export function cryptoProperties_AlgorithmProperties_CryptoExecutionEnvironmentFromJSON(
  object: any,
): CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment {
  switch (object) {
    case 0:
    case "CRYPTO_EXECUTION_ENVIRONMENT_UNSPECIFIED":
      return CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment.CRYPTO_EXECUTION_ENVIRONMENT_UNSPECIFIED;
    case 1:
    case "CRYPTO_EXECUTION_ENVIRONMENT_UNKNOWN":
      return CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment.CRYPTO_EXECUTION_ENVIRONMENT_UNKNOWN;
    case 2:
    case "CRYPTO_EXECUTION_ENVIRONMENT_OTHER":
      return CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment.CRYPTO_EXECUTION_ENVIRONMENT_OTHER;
    case 3:
    case "CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_PLAIN_RAM":
      return CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment
        .CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_PLAIN_RAM;
    case 4:
    case "CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_ENCRYPTED_RAM":
      return CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment
        .CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_ENCRYPTED_RAM;
    case 5:
    case "CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_TEE":
      return CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment.CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_TEE;
    case 6:
    case "CRYPTO_EXECUTION_ENVIRONMENT_HARDWARE":
      return CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment.CRYPTO_EXECUTION_ENVIRONMENT_HARDWARE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment.UNRECOGNIZED;
  }
}

export function cryptoProperties_AlgorithmProperties_CryptoExecutionEnvironmentToJSON(
  object: CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment,
): string {
  switch (object) {
    case CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment.CRYPTO_EXECUTION_ENVIRONMENT_UNSPECIFIED:
      return "CRYPTO_EXECUTION_ENVIRONMENT_UNSPECIFIED";
    case CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment.CRYPTO_EXECUTION_ENVIRONMENT_UNKNOWN:
      return "CRYPTO_EXECUTION_ENVIRONMENT_UNKNOWN";
    case CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment.CRYPTO_EXECUTION_ENVIRONMENT_OTHER:
      return "CRYPTO_EXECUTION_ENVIRONMENT_OTHER";
    case CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment
      .CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_PLAIN_RAM:
      return "CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_PLAIN_RAM";
    case CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment
      .CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_ENCRYPTED_RAM:
      return "CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_ENCRYPTED_RAM";
    case CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment.CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_TEE:
      return "CRYPTO_EXECUTION_ENVIRONMENT_SOFTWARE_TEE";
    case CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment.CRYPTO_EXECUTION_ENVIRONMENT_HARDWARE:
      return "CRYPTO_EXECUTION_ENVIRONMENT_HARDWARE";
    case CryptoProperties_AlgorithmProperties_CryptoExecutionEnvironment.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Implementation platform */
export enum CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform {
  /** CRYPTO_IMPLEMENTATION_PLATFORM_UNSPECIFIED - ProtoBuff's default value -- it differs from "unknown" */
  CRYPTO_IMPLEMENTATION_PLATFORM_UNSPECIFIED = 0,
  /** CRYPTO_IMPLEMENTATION_PLATFORM_UNKNOWN - the platform is not known */
  CRYPTO_IMPLEMENTATION_PLATFORM_UNKNOWN = 1,
  /** CRYPTO_IMPLEMENTATION_PLATFORM_OTHER - none of the following */
  CRYPTO_IMPLEMENTATION_PLATFORM_OTHER = 2,
  CRYPTO_IMPLEMENTATION_PLATFORM_GENERIC = 3,
  CRYPTO_IMPLEMENTATION_PLATFORM_X86_32 = 4,
  CRYPTO_IMPLEMENTATION_PLATFORM_X86_64 = 5,
  CRYPTO_IMPLEMENTATION_PLATFORM_ARMV7A = 6,
  CRYPTO_IMPLEMENTATION_PLATFORM_ARMV7M = 7,
  CRYPTO_IMPLEMENTATION_PLATFORM_ARMV8A = 8,
  CRYPTO_IMPLEMENTATION_PLATFORM_ARMV8M = 9,
  CRYPTO_IMPLEMENTATION_PLATFORM_ARMV9A = 10,
  CRYPTO_IMPLEMENTATION_PLATFORM_ARMV9M = 11,
  CRYPTO_IMPLEMENTATION_PLATFORM_X390X = 12,
  CRYPTO_IMPLEMENTATION_PLATFORM_PPC64 = 13,
  CRYPTO_IMPLEMENTATION_PLATFORM_PPC64LE = 14,
  UNRECOGNIZED = -1,
}

export function cryptoProperties_AlgorithmProperties_CryptoImplementationPlatformFromJSON(
  object: any,
): CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform {
  switch (object) {
    case 0:
    case "CRYPTO_IMPLEMENTATION_PLATFORM_UNSPECIFIED":
      return CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform
        .CRYPTO_IMPLEMENTATION_PLATFORM_UNSPECIFIED;
    case 1:
    case "CRYPTO_IMPLEMENTATION_PLATFORM_UNKNOWN":
      return CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_UNKNOWN;
    case 2:
    case "CRYPTO_IMPLEMENTATION_PLATFORM_OTHER":
      return CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_OTHER;
    case 3:
    case "CRYPTO_IMPLEMENTATION_PLATFORM_GENERIC":
      return CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_GENERIC;
    case 4:
    case "CRYPTO_IMPLEMENTATION_PLATFORM_X86_32":
      return CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_X86_32;
    case 5:
    case "CRYPTO_IMPLEMENTATION_PLATFORM_X86_64":
      return CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_X86_64;
    case 6:
    case "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV7A":
      return CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_ARMV7A;
    case 7:
    case "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV7M":
      return CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_ARMV7M;
    case 8:
    case "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV8A":
      return CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_ARMV8A;
    case 9:
    case "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV8M":
      return CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_ARMV8M;
    case 10:
    case "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV9A":
      return CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_ARMV9A;
    case 11:
    case "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV9M":
      return CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_ARMV9M;
    case 12:
    case "CRYPTO_IMPLEMENTATION_PLATFORM_X390X":
      return CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_X390X;
    case 13:
    case "CRYPTO_IMPLEMENTATION_PLATFORM_PPC64":
      return CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_PPC64;
    case 14:
    case "CRYPTO_IMPLEMENTATION_PLATFORM_PPC64LE":
      return CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_PPC64LE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.UNRECOGNIZED;
  }
}

export function cryptoProperties_AlgorithmProperties_CryptoImplementationPlatformToJSON(
  object: CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform,
): string {
  switch (object) {
    case CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_UNSPECIFIED:
      return "CRYPTO_IMPLEMENTATION_PLATFORM_UNSPECIFIED";
    case CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_UNKNOWN:
      return "CRYPTO_IMPLEMENTATION_PLATFORM_UNKNOWN";
    case CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_OTHER:
      return "CRYPTO_IMPLEMENTATION_PLATFORM_OTHER";
    case CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_GENERIC:
      return "CRYPTO_IMPLEMENTATION_PLATFORM_GENERIC";
    case CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_X86_32:
      return "CRYPTO_IMPLEMENTATION_PLATFORM_X86_32";
    case CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_X86_64:
      return "CRYPTO_IMPLEMENTATION_PLATFORM_X86_64";
    case CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_ARMV7A:
      return "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV7A";
    case CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_ARMV7M:
      return "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV7M";
    case CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_ARMV8A:
      return "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV8A";
    case CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_ARMV8M:
      return "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV8M";
    case CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_ARMV9A:
      return "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV9A";
    case CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_ARMV9M:
      return "CRYPTO_IMPLEMENTATION_PLATFORM_ARMV9M";
    case CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_X390X:
      return "CRYPTO_IMPLEMENTATION_PLATFORM_X390X";
    case CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_PPC64:
      return "CRYPTO_IMPLEMENTATION_PLATFORM_PPC64";
    case CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.CRYPTO_IMPLEMENTATION_PLATFORM_PPC64LE:
      return "CRYPTO_IMPLEMENTATION_PLATFORM_PPC64LE";
    case CryptoProperties_AlgorithmProperties_CryptoImplementationPlatform.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Mode */
export enum CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode {
  /** CRYPTO_ALGORITHM_MODE_UNSPECIFIED - ProtoBuff's default value -- it differs from "unknown" */
  CRYPTO_ALGORITHM_MODE_UNSPECIFIED = 0,
  /** CRYPTO_ALGORITHM_MODE_UNKNOWN - The mode of operation is not known */
  CRYPTO_ALGORITHM_MODE_UNKNOWN = 1,
  /** CRYPTO_ALGORITHM_MODE_OTHER - Another mode of operation - none of the following */
  CRYPTO_ALGORITHM_MODE_OTHER = 2,
  /** CRYPTO_ALGORITHM_MODE_CBC - Cipher block chaining */
  CRYPTO_ALGORITHM_MODE_CBC = 3,
  /** CRYPTO_ALGORITHM_MODE_ECB - Electronic codebook */
  CRYPTO_ALGORITHM_MODE_ECB = 4,
  /** CRYPTO_ALGORITHM_MODE_CCM - Counter with cipher block chaining message authentication code */
  CRYPTO_ALGORITHM_MODE_CCM = 5,
  /** CRYPTO_ALGORITHM_MODE_GCM - Galois/counter */
  CRYPTO_ALGORITHM_MODE_GCM = 6,
  /** CRYPTO_ALGORITHM_MODE_CFB - Cipher feedback */
  CRYPTO_ALGORITHM_MODE_CFB = 7,
  /** CRYPTO_ALGORITHM_MODE_OFB - Output feedback */
  CRYPTO_ALGORITHM_MODE_OFB = 8,
  /** CRYPTO_ALGORITHM_MODE_CTR - Counter */
  CRYPTO_ALGORITHM_MODE_CTR = 9,
  UNRECOGNIZED = -1,
}

export function cryptoProperties_AlgorithmProperties_CryptoAlgorithmModeFromJSON(
  object: any,
): CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode {
  switch (object) {
    case 0:
    case "CRYPTO_ALGORITHM_MODE_UNSPECIFIED":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_UNSPECIFIED;
    case 1:
    case "CRYPTO_ALGORITHM_MODE_UNKNOWN":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_UNKNOWN;
    case 2:
    case "CRYPTO_ALGORITHM_MODE_OTHER":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_OTHER;
    case 3:
    case "CRYPTO_ALGORITHM_MODE_CBC":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_CBC;
    case 4:
    case "CRYPTO_ALGORITHM_MODE_ECB":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_ECB;
    case 5:
    case "CRYPTO_ALGORITHM_MODE_CCM":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_CCM;
    case 6:
    case "CRYPTO_ALGORITHM_MODE_GCM":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_GCM;
    case 7:
    case "CRYPTO_ALGORITHM_MODE_CFB":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_CFB;
    case 8:
    case "CRYPTO_ALGORITHM_MODE_OFB":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_OFB;
    case 9:
    case "CRYPTO_ALGORITHM_MODE_CTR":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_CTR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.UNRECOGNIZED;
  }
}

export function cryptoProperties_AlgorithmProperties_CryptoAlgorithmModeToJSON(
  object: CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode,
): string {
  switch (object) {
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_UNSPECIFIED:
      return "CRYPTO_ALGORITHM_MODE_UNSPECIFIED";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_UNKNOWN:
      return "CRYPTO_ALGORITHM_MODE_UNKNOWN";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_OTHER:
      return "CRYPTO_ALGORITHM_MODE_OTHER";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_CBC:
      return "CRYPTO_ALGORITHM_MODE_CBC";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_ECB:
      return "CRYPTO_ALGORITHM_MODE_ECB";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_CCM:
      return "CRYPTO_ALGORITHM_MODE_CCM";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_GCM:
      return "CRYPTO_ALGORITHM_MODE_GCM";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_CFB:
      return "CRYPTO_ALGORITHM_MODE_CFB";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_OFB:
      return "CRYPTO_ALGORITHM_MODE_OFB";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.CRYPTO_ALGORITHM_MODE_CTR:
      return "CRYPTO_ALGORITHM_MODE_CTR";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Padding */
export enum CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding {
  /** CRYPTO_ALGORITHM_PADDING_UNSPECIFIED - ProtoBuff's default value -- it differs from "unknown" */
  CRYPTO_ALGORITHM_PADDING_UNSPECIFIED = 0,
  /** CRYPTO_ALGORITHM_PADDING_UNKNOWN - The padding scheme is not known */
  CRYPTO_ALGORITHM_PADDING_UNKNOWN = 1,
  /** CRYPTO_ALGORITHM_PADDING_OTHER - Another padding scheme - none of the following */
  CRYPTO_ALGORITHM_PADDING_OTHER = 2,
  /** CRYPTO_ALGORITHM_PADDING_PKCS5 - Public Key Cryptography Standard: Password-Based Cryptography */
  CRYPTO_ALGORITHM_PADDING_PKCS5 = 3,
  /** CRYPTO_ALGORITHM_PADDING_PKCS7 - Public Key Cryptography Standard: Cryptographic Message Syntax */
  CRYPTO_ALGORITHM_PADDING_PKCS7 = 4,
  /** CRYPTO_ALGORITHM_PADDING_PKCS1V15 - Public Key Cryptography Standard: RSA Cryptography v1.5 */
  CRYPTO_ALGORITHM_PADDING_PKCS1V15 = 5,
  /** CRYPTO_ALGORITHM_PADDING_OAEP - Optimal asymmetric encryption padding */
  CRYPTO_ALGORITHM_PADDING_OAEP = 6,
  /** CRYPTO_ALGORITHM_PADDING_RAW - Raw */
  CRYPTO_ALGORITHM_PADDING_RAW = 7,
  UNRECOGNIZED = -1,
}

export function cryptoProperties_AlgorithmProperties_CryptoAlgorithmPaddingFromJSON(
  object: any,
): CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding {
  switch (object) {
    case 0:
    case "CRYPTO_ALGORITHM_PADDING_UNSPECIFIED":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.CRYPTO_ALGORITHM_PADDING_UNSPECIFIED;
    case 1:
    case "CRYPTO_ALGORITHM_PADDING_UNKNOWN":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.CRYPTO_ALGORITHM_PADDING_UNKNOWN;
    case 2:
    case "CRYPTO_ALGORITHM_PADDING_OTHER":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.CRYPTO_ALGORITHM_PADDING_OTHER;
    case 3:
    case "CRYPTO_ALGORITHM_PADDING_PKCS5":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.CRYPTO_ALGORITHM_PADDING_PKCS5;
    case 4:
    case "CRYPTO_ALGORITHM_PADDING_PKCS7":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.CRYPTO_ALGORITHM_PADDING_PKCS7;
    case 5:
    case "CRYPTO_ALGORITHM_PADDING_PKCS1V15":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.CRYPTO_ALGORITHM_PADDING_PKCS1V15;
    case 6:
    case "CRYPTO_ALGORITHM_PADDING_OAEP":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.CRYPTO_ALGORITHM_PADDING_OAEP;
    case 7:
    case "CRYPTO_ALGORITHM_PADDING_RAW":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.CRYPTO_ALGORITHM_PADDING_RAW;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.UNRECOGNIZED;
  }
}

export function cryptoProperties_AlgorithmProperties_CryptoAlgorithmPaddingToJSON(
  object: CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding,
): string {
  switch (object) {
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.CRYPTO_ALGORITHM_PADDING_UNSPECIFIED:
      return "CRYPTO_ALGORITHM_PADDING_UNSPECIFIED";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.CRYPTO_ALGORITHM_PADDING_UNKNOWN:
      return "CRYPTO_ALGORITHM_PADDING_UNKNOWN";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.CRYPTO_ALGORITHM_PADDING_OTHER:
      return "CRYPTO_ALGORITHM_PADDING_OTHER";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.CRYPTO_ALGORITHM_PADDING_PKCS5:
      return "CRYPTO_ALGORITHM_PADDING_PKCS5";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.CRYPTO_ALGORITHM_PADDING_PKCS7:
      return "CRYPTO_ALGORITHM_PADDING_PKCS7";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.CRYPTO_ALGORITHM_PADDING_PKCS1V15:
      return "CRYPTO_ALGORITHM_PADDING_PKCS1V15";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.CRYPTO_ALGORITHM_PADDING_OAEP:
      return "CRYPTO_ALGORITHM_PADDING_OAEP";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.CRYPTO_ALGORITHM_PADDING_RAW:
      return "CRYPTO_ALGORITHM_PADDING_RAW";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmPadding.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Cryptographic functions */
export enum CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction {
  /** CRYPTO_ALGORITHM_FUNCTION_UNSPECIFIED - ProtoBuff's default value -- it differs from "unknown" */
  CRYPTO_ALGORITHM_FUNCTION_UNSPECIFIED = 0,
  /** CRYPTO_ALGORITHM_FUNCTION_UNKNOWN - meaning "there is some, but it is unclear which one" */
  CRYPTO_ALGORITHM_FUNCTION_UNKNOWN = 1,
  /** CRYPTO_ALGORITHM_FUNCTION_OTHER - none of the following */
  CRYPTO_ALGORITHM_FUNCTION_OTHER = 2,
  CRYPTO_ALGORITHM_FUNCTION_GENERATE = 3,
  CRYPTO_ALGORITHM_FUNCTION_KEYGEN = 4,
  CRYPTO_ALGORITHM_FUNCTION_ENCRYPT = 5,
  CRYPTO_ALGORITHM_FUNCTION_DECRYPT = 6,
  CRYPTO_ALGORITHM_FUNCTION_DIGEST = 7,
  CRYPTO_ALGORITHM_FUNCTION_TAG = 8,
  CRYPTO_ALGORITHM_FUNCTION_KEYDERIVE = 9,
  CRYPTO_ALGORITHM_FUNCTION_SIGN = 10,
  CRYPTO_ALGORITHM_FUNCTION_VERIFY = 11,
  CRYPTO_ALGORITHM_FUNCTION_ENCAPSULATE = 12,
  CRYPTO_ALGORITHM_FUNCTION_DECAPSULATE = 13,
  UNRECOGNIZED = -1,
}

export function cryptoProperties_AlgorithmProperties_CryptoAlgorithmFunctionFromJSON(
  object: any,
): CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction {
  switch (object) {
    case 0:
    case "CRYPTO_ALGORITHM_FUNCTION_UNSPECIFIED":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_UNSPECIFIED;
    case 1:
    case "CRYPTO_ALGORITHM_FUNCTION_UNKNOWN":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_UNKNOWN;
    case 2:
    case "CRYPTO_ALGORITHM_FUNCTION_OTHER":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_OTHER;
    case 3:
    case "CRYPTO_ALGORITHM_FUNCTION_GENERATE":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_GENERATE;
    case 4:
    case "CRYPTO_ALGORITHM_FUNCTION_KEYGEN":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_KEYGEN;
    case 5:
    case "CRYPTO_ALGORITHM_FUNCTION_ENCRYPT":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_ENCRYPT;
    case 6:
    case "CRYPTO_ALGORITHM_FUNCTION_DECRYPT":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_DECRYPT;
    case 7:
    case "CRYPTO_ALGORITHM_FUNCTION_DIGEST":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_DIGEST;
    case 8:
    case "CRYPTO_ALGORITHM_FUNCTION_TAG":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_TAG;
    case 9:
    case "CRYPTO_ALGORITHM_FUNCTION_KEYDERIVE":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_KEYDERIVE;
    case 10:
    case "CRYPTO_ALGORITHM_FUNCTION_SIGN":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_SIGN;
    case 11:
    case "CRYPTO_ALGORITHM_FUNCTION_VERIFY":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_VERIFY;
    case 12:
    case "CRYPTO_ALGORITHM_FUNCTION_ENCAPSULATE":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_ENCAPSULATE;
    case 13:
    case "CRYPTO_ALGORITHM_FUNCTION_DECAPSULATE":
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_DECAPSULATE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.UNRECOGNIZED;
  }
}

export function cryptoProperties_AlgorithmProperties_CryptoAlgorithmFunctionToJSON(
  object: CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction,
): string {
  switch (object) {
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_UNSPECIFIED:
      return "CRYPTO_ALGORITHM_FUNCTION_UNSPECIFIED";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_UNKNOWN:
      return "CRYPTO_ALGORITHM_FUNCTION_UNKNOWN";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_OTHER:
      return "CRYPTO_ALGORITHM_FUNCTION_OTHER";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_GENERATE:
      return "CRYPTO_ALGORITHM_FUNCTION_GENERATE";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_KEYGEN:
      return "CRYPTO_ALGORITHM_FUNCTION_KEYGEN";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_ENCRYPT:
      return "CRYPTO_ALGORITHM_FUNCTION_ENCRYPT";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_DECRYPT:
      return "CRYPTO_ALGORITHM_FUNCTION_DECRYPT";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_DIGEST:
      return "CRYPTO_ALGORITHM_FUNCTION_DIGEST";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_TAG:
      return "CRYPTO_ALGORITHM_FUNCTION_TAG";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_KEYDERIVE:
      return "CRYPTO_ALGORITHM_FUNCTION_KEYDERIVE";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_SIGN:
      return "CRYPTO_ALGORITHM_FUNCTION_SIGN";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_VERIFY:
      return "CRYPTO_ALGORITHM_FUNCTION_VERIFY";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_ENCAPSULATE:
      return "CRYPTO_ALGORITHM_FUNCTION_ENCAPSULATE";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.CRYPTO_ALGORITHM_FUNCTION_DECAPSULATE:
      return "CRYPTO_ALGORITHM_FUNCTION_DECAPSULATE";
    case CryptoProperties_AlgorithmProperties_CryptoAlgorithmFunction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Certificate Properties */
export interface CryptoProperties_CertificateProperties {
  /** The subject name for the certificate */
  subjectName?:
    | string
    | undefined;
  /** The issuer name for the certificate */
  issuerName?:
    | string
    | undefined;
  /** The date and time according to ISO-8601 standard from which the certificate is valid */
  notValidBefore?:
    | Date
    | undefined;
  /** The date and time according to ISO-8601 standard from which the certificate is not valid anymore */
  notValidAfter?:
    | Date
    | undefined;
  /** The bom-ref to signature algorithm used by the certificate */
  signatureAlgorithmRef?:
    | string
    | undefined;
  /** The bom-ref to the public key of the subject */
  subjectPublicKeyRef?:
    | string
    | undefined;
  /** The format of the certificate. Examples include X.509, PEM, DER, and CVC. */
  certificateFormat?:
    | string
    | undefined;
  /** The file extension of the certificate. Examples include crt, pem, cer, der, and p12. */
  certificateExtension?: string | undefined;
}

/** Related Cryptographic Material Properties */
export interface CryptoProperties_RelatedCryptoMaterialProperties {
  /** The type for the related cryptographic material */
  type?:
    | CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType
    | undefined;
  /** The optional unique identifier for the related cryptographic material. */
  id?:
    | string
    | undefined;
  /** The key state as defined by NIST SP 800-57. */
  state?:
    | CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState
    | undefined;
  /** The bom-ref to the algorithm used to generate the related cryptographic material. */
  algorithmRef?:
    | string
    | undefined;
  /** The date and time (timestamp) when the related cryptographic material was created. */
  creationDate?:
    | Date
    | undefined;
  /** The date and time (timestamp) when the related cryptographic material was activated. */
  activationDate?:
    | Date
    | undefined;
  /** The date and time (timestamp) when the related cryptographic material was updated. */
  updateDate?:
    | Date
    | undefined;
  /** The date and time (timestamp) when the related cryptographic material expires. */
  expirationDate?:
    | Date
    | undefined;
  /** The associated value of the cryptographic material. */
  value?:
    | string
    | undefined;
  /** The size of the cryptographic asset (in bits). */
  size?:
    | string
    | undefined;
  /** The format of the related cryptographic material (e.g. P8, PEM, DER). */
  format?:
    | string
    | undefined;
  /** The mechanism by which the cryptographic asset is secured. */
  securedBy?: CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy | undefined;
}

/** relatedCryptoMaterialType */
export enum CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType {
  /** CRYPTO_RELATED_TYPE_UNSPECIFIED - ProtoBuff's default value -- it differs from "unknown" */
  CRYPTO_RELATED_TYPE_UNSPECIFIED = 0,
  /** CRYPTO_RELATED_TYPE_UNKNOWN - The type of cryptographic asset is not known. */
  CRYPTO_RELATED_TYPE_UNKNOWN = 1,
  /** CRYPTO_RELATED_TYPE_OTHER - Another type of cryptographic asset - none of the following */
  CRYPTO_RELATED_TYPE_OTHER = 2,
  CRYPTO_RELATED_TYPE_PRIVATE_KEY = 3,
  CRYPTO_RELATED_TYPE_PUBLIC_KEY = 4,
  CRYPTO_RELATED_TYPE_SECRET_KEY = 5,
  CRYPTO_RELATED_TYPE_KEY = 6,
  CRYPTO_RELATED_TYPE_CIPHERTEXT = 7,
  CRYPTO_RELATED_TYPE_SIGNATURE = 8,
  CRYPTO_RELATED_TYPE_DIGEST = 9,
  CRYPTO_RELATED_TYPE_INITIALIZATION_VECTOR = 10,
  CRYPTO_RELATED_TYPE_NONCE = 11,
  CRYPTO_RELATED_TYPE_SEED = 12,
  CRYPTO_RELATED_TYPE_SALT = 13,
  CRYPTO_RELATED_TYPE_SHARED_SECRET = 14,
  CRYPTO_RELATED_TYPE_TAG = 15,
  CRYPTO_RELATED_TYPE_ADDITIONAL_DATA = 16,
  CRYPTO_RELATED_TYPE_PASSWORD = 17,
  CRYPTO_RELATED_TYPE_CREDENTIAL = 18,
  CRYPTO_RELATED_TYPE_TOKEN = 19,
  UNRECOGNIZED = -1,
}

export function cryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedTypeFromJSON(
  object: any,
): CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType {
  switch (object) {
    case 0:
    case "CRYPTO_RELATED_TYPE_UNSPECIFIED":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_UNSPECIFIED;
    case 1:
    case "CRYPTO_RELATED_TYPE_UNKNOWN":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_UNKNOWN;
    case 2:
    case "CRYPTO_RELATED_TYPE_OTHER":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_OTHER;
    case 3:
    case "CRYPTO_RELATED_TYPE_PRIVATE_KEY":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_PRIVATE_KEY;
    case 4:
    case "CRYPTO_RELATED_TYPE_PUBLIC_KEY":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_PUBLIC_KEY;
    case 5:
    case "CRYPTO_RELATED_TYPE_SECRET_KEY":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_SECRET_KEY;
    case 6:
    case "CRYPTO_RELATED_TYPE_KEY":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_KEY;
    case 7:
    case "CRYPTO_RELATED_TYPE_CIPHERTEXT":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_CIPHERTEXT;
    case 8:
    case "CRYPTO_RELATED_TYPE_SIGNATURE":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_SIGNATURE;
    case 9:
    case "CRYPTO_RELATED_TYPE_DIGEST":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_DIGEST;
    case 10:
    case "CRYPTO_RELATED_TYPE_INITIALIZATION_VECTOR":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType
        .CRYPTO_RELATED_TYPE_INITIALIZATION_VECTOR;
    case 11:
    case "CRYPTO_RELATED_TYPE_NONCE":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_NONCE;
    case 12:
    case "CRYPTO_RELATED_TYPE_SEED":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_SEED;
    case 13:
    case "CRYPTO_RELATED_TYPE_SALT":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_SALT;
    case 14:
    case "CRYPTO_RELATED_TYPE_SHARED_SECRET":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_SHARED_SECRET;
    case 15:
    case "CRYPTO_RELATED_TYPE_TAG":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_TAG;
    case 16:
    case "CRYPTO_RELATED_TYPE_ADDITIONAL_DATA":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_ADDITIONAL_DATA;
    case 17:
    case "CRYPTO_RELATED_TYPE_PASSWORD":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_PASSWORD;
    case 18:
    case "CRYPTO_RELATED_TYPE_CREDENTIAL":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_CREDENTIAL;
    case 19:
    case "CRYPTO_RELATED_TYPE_TOKEN":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_TOKEN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.UNRECOGNIZED;
  }
}

export function cryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedTypeToJSON(
  object: CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType,
): string {
  switch (object) {
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_UNSPECIFIED:
      return "CRYPTO_RELATED_TYPE_UNSPECIFIED";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_UNKNOWN:
      return "CRYPTO_RELATED_TYPE_UNKNOWN";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_OTHER:
      return "CRYPTO_RELATED_TYPE_OTHER";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_PRIVATE_KEY:
      return "CRYPTO_RELATED_TYPE_PRIVATE_KEY";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_PUBLIC_KEY:
      return "CRYPTO_RELATED_TYPE_PUBLIC_KEY";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_SECRET_KEY:
      return "CRYPTO_RELATED_TYPE_SECRET_KEY";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_KEY:
      return "CRYPTO_RELATED_TYPE_KEY";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_CIPHERTEXT:
      return "CRYPTO_RELATED_TYPE_CIPHERTEXT";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_SIGNATURE:
      return "CRYPTO_RELATED_TYPE_SIGNATURE";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_DIGEST:
      return "CRYPTO_RELATED_TYPE_DIGEST";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_INITIALIZATION_VECTOR:
      return "CRYPTO_RELATED_TYPE_INITIALIZATION_VECTOR";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_NONCE:
      return "CRYPTO_RELATED_TYPE_NONCE";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_SEED:
      return "CRYPTO_RELATED_TYPE_SEED";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_SALT:
      return "CRYPTO_RELATED_TYPE_SALT";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_SHARED_SECRET:
      return "CRYPTO_RELATED_TYPE_SHARED_SECRET";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_TAG:
      return "CRYPTO_RELATED_TYPE_TAG";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_ADDITIONAL_DATA:
      return "CRYPTO_RELATED_TYPE_ADDITIONAL_DATA";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_PASSWORD:
      return "CRYPTO_RELATED_TYPE_PASSWORD";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_CREDENTIAL:
      return "CRYPTO_RELATED_TYPE_CREDENTIAL";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.CRYPTO_RELATED_TYPE_TOKEN:
      return "CRYPTO_RELATED_TYPE_TOKEN";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** State */
export enum CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState {
  /** CRYPTO_RELATED_STATE_UNSPECIFIED - Default */
  CRYPTO_RELATED_STATE_UNSPECIFIED = 0,
  CRYPTO_RELATED_STATE_PRE_ACTIVATION = 1,
  CRYPTO_RELATED_STATE_ACTIVE = 2,
  CRYPTO_RELATED_STATE_SUSPENDED = 3,
  CRYPTO_RELATED_STATE_DEACTIVATED = 4,
  CRYPTO_RELATED_STATE_COMPROMISED = 5,
  CRYPTO_RELATED_STATE_DESTROYED = 6,
  UNRECOGNIZED = -1,
}

export function cryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedStateFromJSON(
  object: any,
): CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState {
  switch (object) {
    case 0:
    case "CRYPTO_RELATED_STATE_UNSPECIFIED":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState.CRYPTO_RELATED_STATE_UNSPECIFIED;
    case 1:
    case "CRYPTO_RELATED_STATE_PRE_ACTIVATION":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState.CRYPTO_RELATED_STATE_PRE_ACTIVATION;
    case 2:
    case "CRYPTO_RELATED_STATE_ACTIVE":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState.CRYPTO_RELATED_STATE_ACTIVE;
    case 3:
    case "CRYPTO_RELATED_STATE_SUSPENDED":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState.CRYPTO_RELATED_STATE_SUSPENDED;
    case 4:
    case "CRYPTO_RELATED_STATE_DEACTIVATED":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState.CRYPTO_RELATED_STATE_DEACTIVATED;
    case 5:
    case "CRYPTO_RELATED_STATE_COMPROMISED":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState.CRYPTO_RELATED_STATE_COMPROMISED;
    case 6:
    case "CRYPTO_RELATED_STATE_DESTROYED":
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState.CRYPTO_RELATED_STATE_DESTROYED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState.UNRECOGNIZED;
  }
}

export function cryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedStateToJSON(
  object: CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState,
): string {
  switch (object) {
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState.CRYPTO_RELATED_STATE_UNSPECIFIED:
      return "CRYPTO_RELATED_STATE_UNSPECIFIED";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState.CRYPTO_RELATED_STATE_PRE_ACTIVATION:
      return "CRYPTO_RELATED_STATE_PRE_ACTIVATION";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState.CRYPTO_RELATED_STATE_ACTIVE:
      return "CRYPTO_RELATED_STATE_ACTIVE";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState.CRYPTO_RELATED_STATE_SUSPENDED:
      return "CRYPTO_RELATED_STATE_SUSPENDED";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState.CRYPTO_RELATED_STATE_DEACTIVATED:
      return "CRYPTO_RELATED_STATE_DEACTIVATED";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState.CRYPTO_RELATED_STATE_COMPROMISED:
      return "CRYPTO_RELATED_STATE_COMPROMISED";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState.CRYPTO_RELATED_STATE_DESTROYED:
      return "CRYPTO_RELATED_STATE_DESTROYED";
    case CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Secured By */
export interface CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy {
  /** Specifies the mechanism by which the cryptographic asset is secured. Examples include HSM, TPM, SGX, Software, and None */
  mechanism?:
    | string
    | undefined;
  /** The bom-ref to the algorithm. */
  algorithmRef?: string | undefined;
}

/** Protocol Properties */
export interface CryptoProperties_ProtocolProperties {
  /** The concrete protocol type. */
  type?:
    | CryptoProperties_ProtocolProperties_CryptoProtocolType
    | undefined;
  /** The version of the protocol. Examples include 1.0, 1.2, and 1.99. */
  version?:
    | string
    | undefined;
  /** A list of cipher suites related to the protocol. */
  cipherSuites: CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite[];
  /** The IKEv2 transform types supported (types 1-4), defined in RFC7296 section 3.3.2, and additional properties. */
  ikev2TransformTypes?:
    | CryptoProperties_ProtocolProperties_Ikev2TransformTypes
    | undefined;
  /** The bom-ref(s) to protocol-related cryptographic assets */
  cryptoRef: string[];
}

export enum CryptoProperties_ProtocolProperties_CryptoProtocolType {
  /** CRYPTO_PROTOCOL_TYPE_UNSPECIFIED - ProtoBuff's default value -- it differs from "unknown" */
  CRYPTO_PROTOCOL_TYPE_UNSPECIFIED = 0,
  /** CRYPTO_PROTOCOL_TYPE_UNKNOWN - The protocol type is not known */
  CRYPTO_PROTOCOL_TYPE_UNKNOWN = 1,
  /** CRYPTO_PROTOCOL_TYPE_OTHER - Another protocol type - none of the following */
  CRYPTO_PROTOCOL_TYPE_OTHER = 2,
  /** CRYPTO_PROTOCOL_TYPE_TLS - Transport Layer Security */
  CRYPTO_PROTOCOL_TYPE_TLS = 3,
  /** CRYPTO_PROTOCOL_TYPE_SSH - Secure Shell */
  CRYPTO_PROTOCOL_TYPE_SSH = 4,
  /** CRYPTO_PROTOCOL_TYPE_IPSEC - Internet Protocol Security */
  CRYPTO_PROTOCOL_TYPE_IPSEC = 5,
  /** CRYPTO_PROTOCOL_TYPE_IKE - Internet Key Exchange */
  CRYPTO_PROTOCOL_TYPE_IKE = 6,
  /** CRYPTO_PROTOCOL_TYPE_SSTP - Secure Socket Tunneling Protocol */
  CRYPTO_PROTOCOL_TYPE_SSTP = 7,
  /** CRYPTO_PROTOCOL_TYPE_WPA - Wi-Fi Protected Access */
  CRYPTO_PROTOCOL_TYPE_WPA = 8,
  UNRECOGNIZED = -1,
}

export function cryptoProperties_ProtocolProperties_CryptoProtocolTypeFromJSON(
  object: any,
): CryptoProperties_ProtocolProperties_CryptoProtocolType {
  switch (object) {
    case 0:
    case "CRYPTO_PROTOCOL_TYPE_UNSPECIFIED":
      return CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_UNSPECIFIED;
    case 1:
    case "CRYPTO_PROTOCOL_TYPE_UNKNOWN":
      return CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_UNKNOWN;
    case 2:
    case "CRYPTO_PROTOCOL_TYPE_OTHER":
      return CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_OTHER;
    case 3:
    case "CRYPTO_PROTOCOL_TYPE_TLS":
      return CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_TLS;
    case 4:
    case "CRYPTO_PROTOCOL_TYPE_SSH":
      return CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_SSH;
    case 5:
    case "CRYPTO_PROTOCOL_TYPE_IPSEC":
      return CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_IPSEC;
    case 6:
    case "CRYPTO_PROTOCOL_TYPE_IKE":
      return CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_IKE;
    case 7:
    case "CRYPTO_PROTOCOL_TYPE_SSTP":
      return CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_SSTP;
    case 8:
    case "CRYPTO_PROTOCOL_TYPE_WPA":
      return CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_WPA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CryptoProperties_ProtocolProperties_CryptoProtocolType.UNRECOGNIZED;
  }
}

export function cryptoProperties_ProtocolProperties_CryptoProtocolTypeToJSON(
  object: CryptoProperties_ProtocolProperties_CryptoProtocolType,
): string {
  switch (object) {
    case CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_UNSPECIFIED:
      return "CRYPTO_PROTOCOL_TYPE_UNSPECIFIED";
    case CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_UNKNOWN:
      return "CRYPTO_PROTOCOL_TYPE_UNKNOWN";
    case CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_OTHER:
      return "CRYPTO_PROTOCOL_TYPE_OTHER";
    case CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_TLS:
      return "CRYPTO_PROTOCOL_TYPE_TLS";
    case CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_SSH:
      return "CRYPTO_PROTOCOL_TYPE_SSH";
    case CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_IPSEC:
      return "CRYPTO_PROTOCOL_TYPE_IPSEC";
    case CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_IKE:
      return "CRYPTO_PROTOCOL_TYPE_IKE";
    case CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_SSTP:
      return "CRYPTO_PROTOCOL_TYPE_SSTP";
    case CryptoProperties_ProtocolProperties_CryptoProtocolType.CRYPTO_PROTOCOL_TYPE_WPA:
      return "CRYPTO_PROTOCOL_TYPE_WPA";
    case CryptoProperties_ProtocolProperties_CryptoProtocolType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Object representing a cipher suite */
export interface CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite {
  /** A common name for the cipher suite. For example: TLS_DHE_RSA_WITH_AES_128_CCM */
  name?:
    | string
    | undefined;
  /** A list of algorithms related to the cipher suite. Use the bom-ref to the algorithm cryptographic asset. */
  algorithms: string[];
  /** A list of common identifiers for the cipher suite. For example: 0xC0 and 0x9E */
  identifiers: string[];
}

/** IKEv2 Transform Types */
export interface CryptoProperties_ProtocolProperties_Ikev2TransformTypes {
  /** Transform Type 1: encryption algorithms */
  encr: string[];
  /** Transform Type 2: pseudorandom functions */
  prf: string[];
  /** Transform Type 3: integrity algorithms */
  integ: string[];
  /** Transform Type 4: Key Exchange Method (KE) per RFC9370, formerly called Diffie-Hellman Group (D-H) */
  ke: string[];
  /** Specifies if an Extended Sequence Number (ESN) is used. */
  esn?:
    | boolean
    | undefined;
  /** IKEv2 Authentication method */
  auth: string[];
}

function createBaseAttachedText(): AttachedText {
  return { contentType: undefined, encoding: undefined, value: "" };
}

export const AttachedText: MessageFns<AttachedText> = {
  encode(message: AttachedText, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.contentType !== undefined) {
      writer.uint32(10).string(message.contentType);
    }
    if (message.encoding !== undefined) {
      writer.uint32(18).string(message.encoding);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttachedText {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttachedText();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.encoding = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttachedText {
    return {
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : undefined,
      encoding: isSet(object.encoding) ? globalThis.String(object.encoding) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AttachedText): unknown {
    const obj: any = {};
    if (message.contentType !== undefined) {
      obj.contentType = message.contentType;
    }
    if (message.encoding !== undefined) {
      obj.encoding = message.encoding;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttachedText>, I>>(base?: I): AttachedText {
    return AttachedText.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttachedText>, I>>(object: I): AttachedText {
    const message = createBaseAttachedText();
    message.contentType = object.contentType ?? undefined;
    message.encoding = object.encoding ?? undefined;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBom(): Bom {
  return {
    specVersion: "",
    version: undefined,
    serialNumber: undefined,
    metadata: undefined,
    components: [],
    services: [],
    externalReferences: [],
    dependencies: [],
    compositions: [],
    vulnerabilities: [],
    annotations: [],
    properties: [],
    formulation: [],
    declarations: [],
    definitions: [],
  };
}

export const Bom: MessageFns<Bom> = {
  encode(message: Bom, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.specVersion !== "") {
      writer.uint32(10).string(message.specVersion);
    }
    if (message.version !== undefined) {
      writer.uint32(16).int32(message.version);
    }
    if (message.serialNumber !== undefined) {
      writer.uint32(26).string(message.serialNumber);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    for (const v of message.components) {
      Component.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.services) {
      Service.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.externalReferences) {
      ExternalReference.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.dependencies) {
      Dependency.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.compositions) {
      Composition.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.vulnerabilities) {
      Vulnerability.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.annotations) {
      Annotation.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.formulation) {
      Formula.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.declarations) {
      Declarations.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.definitions) {
      Definition.encode(v!, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Bom {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBom();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.specVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.version = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serialNumber = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.components.push(Component.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.services.push(Service.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.externalReferences.push(ExternalReference.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.dependencies.push(Dependency.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.compositions.push(Composition.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.vulnerabilities.push(Vulnerability.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.annotations.push(Annotation.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.formulation.push(Formula.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.declarations.push(Declarations.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.definitions.push(Definition.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Bom {
    return {
      specVersion: isSet(object.specVersion) ? globalThis.String(object.specVersion) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : undefined,
      serialNumber: isSet(object.serialNumber) ? globalThis.String(object.serialNumber) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => Component.fromJSON(e))
        : [],
      services: globalThis.Array.isArray(object?.services) ? object.services.map((e: any) => Service.fromJSON(e)) : [],
      externalReferences: globalThis.Array.isArray(object?.externalReferences)
        ? object.externalReferences.map((e: any) => ExternalReference.fromJSON(e))
        : [],
      dependencies: globalThis.Array.isArray(object?.dependencies)
        ? object.dependencies.map((e: any) => Dependency.fromJSON(e))
        : [],
      compositions: globalThis.Array.isArray(object?.compositions)
        ? object.compositions.map((e: any) => Composition.fromJSON(e))
        : [],
      vulnerabilities: globalThis.Array.isArray(object?.vulnerabilities)
        ? object.vulnerabilities.map((e: any) => Vulnerability.fromJSON(e))
        : [],
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => Annotation.fromJSON(e))
        : [],
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
      formulation: globalThis.Array.isArray(object?.formulation)
        ? object.formulation.map((e: any) => Formula.fromJSON(e))
        : [],
      declarations: globalThis.Array.isArray(object?.declarations)
        ? object.declarations.map((e: any) => Declarations.fromJSON(e))
        : [],
      definitions: globalThis.Array.isArray(object?.definitions)
        ? object.definitions.map((e: any) => Definition.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Bom): unknown {
    const obj: any = {};
    if (message.specVersion !== "") {
      obj.specVersion = message.specVersion;
    }
    if (message.version !== undefined) {
      obj.version = Math.round(message.version);
    }
    if (message.serialNumber !== undefined) {
      obj.serialNumber = message.serialNumber;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => Component.toJSON(e));
    }
    if (message.services?.length) {
      obj.services = message.services.map((e) => Service.toJSON(e));
    }
    if (message.externalReferences?.length) {
      obj.externalReferences = message.externalReferences.map((e) => ExternalReference.toJSON(e));
    }
    if (message.dependencies?.length) {
      obj.dependencies = message.dependencies.map((e) => Dependency.toJSON(e));
    }
    if (message.compositions?.length) {
      obj.compositions = message.compositions.map((e) => Composition.toJSON(e));
    }
    if (message.vulnerabilities?.length) {
      obj.vulnerabilities = message.vulnerabilities.map((e) => Vulnerability.toJSON(e));
    }
    if (message.annotations?.length) {
      obj.annotations = message.annotations.map((e) => Annotation.toJSON(e));
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    if (message.formulation?.length) {
      obj.formulation = message.formulation.map((e) => Formula.toJSON(e));
    }
    if (message.declarations?.length) {
      obj.declarations = message.declarations.map((e) => Declarations.toJSON(e));
    }
    if (message.definitions?.length) {
      obj.definitions = message.definitions.map((e) => Definition.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Bom>, I>>(base?: I): Bom {
    return Bom.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Bom>, I>>(object: I): Bom {
    const message = createBaseBom();
    message.specVersion = object.specVersion ?? "";
    message.version = object.version ?? undefined;
    message.serialNumber = object.serialNumber ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.components = object.components?.map((e) => Component.fromPartial(e)) || [];
    message.services = object.services?.map((e) => Service.fromPartial(e)) || [];
    message.externalReferences = object.externalReferences?.map((e) => ExternalReference.fromPartial(e)) || [];
    message.dependencies = object.dependencies?.map((e) => Dependency.fromPartial(e)) || [];
    message.compositions = object.compositions?.map((e) => Composition.fromPartial(e)) || [];
    message.vulnerabilities = object.vulnerabilities?.map((e) => Vulnerability.fromPartial(e)) || [];
    message.annotations = object.annotations?.map((e) => Annotation.fromPartial(e)) || [];
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    message.formulation = object.formulation?.map((e) => Formula.fromPartial(e)) || [];
    message.declarations = object.declarations?.map((e) => Declarations.fromPartial(e)) || [];
    message.definitions = object.definitions?.map((e) => Definition.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCommit(): Commit {
  return { uid: undefined, url: undefined, author: undefined, committer: undefined, message: undefined };
}

export const Commit: MessageFns<Commit> = {
  encode(message: Commit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== undefined) {
      writer.uint32(10).string(message.uid);
    }
    if (message.url !== undefined) {
      writer.uint32(18).string(message.url);
    }
    if (message.author !== undefined) {
      IdentifiableAction.encode(message.author, writer.uint32(26).fork()).join();
    }
    if (message.committer !== undefined) {
      IdentifiableAction.encode(message.committer, writer.uint32(34).fork()).join();
    }
    if (message.message !== undefined) {
      writer.uint32(42).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Commit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.author = IdentifiableAction.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.committer = IdentifiableAction.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Commit {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : undefined,
      author: isSet(object.author) ? IdentifiableAction.fromJSON(object.author) : undefined,
      committer: isSet(object.committer) ? IdentifiableAction.fromJSON(object.committer) : undefined,
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
    };
  },

  toJSON(message: Commit): unknown {
    const obj: any = {};
    if (message.uid !== undefined) {
      obj.uid = message.uid;
    }
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    if (message.author !== undefined) {
      obj.author = IdentifiableAction.toJSON(message.author);
    }
    if (message.committer !== undefined) {
      obj.committer = IdentifiableAction.toJSON(message.committer);
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Commit>, I>>(base?: I): Commit {
    return Commit.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Commit>, I>>(object: I): Commit {
    const message = createBaseCommit();
    message.uid = object.uid ?? undefined;
    message.url = object.url ?? undefined;
    message.author = (object.author !== undefined && object.author !== null)
      ? IdentifiableAction.fromPartial(object.author)
      : undefined;
    message.committer = (object.committer !== undefined && object.committer !== null)
      ? IdentifiableAction.fromPartial(object.committer)
      : undefined;
    message.message = object.message ?? undefined;
    return message;
  },
};

function createBaseComponent(): Component {
  return {
    type: 0,
    mimeType: undefined,
    bomRef: undefined,
    supplier: undefined,
    author: undefined,
    publisher: undefined,
    group: undefined,
    name: "",
    version: "",
    description: undefined,
    scope: undefined,
    hashes: [],
    licenses: [],
    copyright: undefined,
    cpe: undefined,
    purl: undefined,
    swid: undefined,
    modified: undefined,
    pedigree: undefined,
    externalReferences: [],
    components: [],
    properties: [],
    evidence: undefined,
    releaseNotes: undefined,
    modelCard: undefined,
    data: [],
    cryptoProperties: undefined,
    manufacturer: undefined,
    authors: [],
    tags: [],
    omniborId: [],
    swhid: [],
  };
}

export const Component: MessageFns<Component> = {
  encode(message: Component, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.mimeType !== undefined) {
      writer.uint32(18).string(message.mimeType);
    }
    if (message.bomRef !== undefined) {
      writer.uint32(26).string(message.bomRef);
    }
    if (message.supplier !== undefined) {
      OrganizationalEntity.encode(message.supplier, writer.uint32(34).fork()).join();
    }
    if (message.author !== undefined) {
      writer.uint32(42).string(message.author);
    }
    if (message.publisher !== undefined) {
      writer.uint32(50).string(message.publisher);
    }
    if (message.group !== undefined) {
      writer.uint32(58).string(message.group);
    }
    if (message.name !== "") {
      writer.uint32(66).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(74).string(message.version);
    }
    if (message.description !== undefined) {
      writer.uint32(82).string(message.description);
    }
    if (message.scope !== undefined) {
      writer.uint32(88).int32(message.scope);
    }
    for (const v of message.hashes) {
      Hash.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.licenses) {
      LicenseChoice.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.copyright !== undefined) {
      writer.uint32(114).string(message.copyright);
    }
    if (message.cpe !== undefined) {
      writer.uint32(122).string(message.cpe);
    }
    if (message.purl !== undefined) {
      writer.uint32(130).string(message.purl);
    }
    if (message.swid !== undefined) {
      Swid.encode(message.swid, writer.uint32(138).fork()).join();
    }
    if (message.modified !== undefined) {
      writer.uint32(144).bool(message.modified);
    }
    if (message.pedigree !== undefined) {
      Pedigree.encode(message.pedigree, writer.uint32(154).fork()).join();
    }
    for (const v of message.externalReferences) {
      ExternalReference.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.components) {
      Component.encode(v!, writer.uint32(170).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(178).fork()).join();
    }
    if (message.evidence !== undefined) {
      Evidence.encode(message.evidence, writer.uint32(186).fork()).join();
    }
    if (message.releaseNotes !== undefined) {
      ReleaseNotes.encode(message.releaseNotes, writer.uint32(194).fork()).join();
    }
    if (message.modelCard !== undefined) {
      ModelCard.encode(message.modelCard, writer.uint32(202).fork()).join();
    }
    for (const v of message.data) {
      ComponentData.encode(v!, writer.uint32(210).fork()).join();
    }
    if (message.cryptoProperties !== undefined) {
      CryptoProperties.encode(message.cryptoProperties, writer.uint32(218).fork()).join();
    }
    if (message.manufacturer !== undefined) {
      OrganizationalEntity.encode(message.manufacturer, writer.uint32(226).fork()).join();
    }
    for (const v of message.authors) {
      OrganizationalContact.encode(v!, writer.uint32(234).fork()).join();
    }
    for (const v of message.tags) {
      writer.uint32(242).string(v!);
    }
    for (const v of message.omniborId) {
      writer.uint32(250).string(v!);
    }
    for (const v of message.swhid) {
      writer.uint32(258).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Component {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.supplier = OrganizationalEntity.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.author = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.publisher = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.group = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.hashes.push(Hash.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.licenses.push(LicenseChoice.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.copyright = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.cpe = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.purl = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.swid = Swid.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.modified = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.pedigree = Pedigree.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.externalReferences.push(ExternalReference.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.components.push(Component.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.evidence = Evidence.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.releaseNotes = ReleaseNotes.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.modelCard = ModelCard.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.data.push(ComponentData.decode(reader, reader.uint32()));
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.cryptoProperties = CryptoProperties.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.manufacturer = OrganizationalEntity.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.authors.push(OrganizationalContact.decode(reader, reader.uint32()));
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.omniborId.push(reader.string());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.swhid.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Component {
    return {
      type: isSet(object.type) ? classificationFromJSON(object.type) : 0,
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : undefined,
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      supplier: isSet(object.supplier) ? OrganizationalEntity.fromJSON(object.supplier) : undefined,
      author: isSet(object.author) ? globalThis.String(object.author) : undefined,
      publisher: isSet(object.publisher) ? globalThis.String(object.publisher) : undefined,
      group: isSet(object.group) ? globalThis.String(object.group) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      scope: isSet(object.scope) ? scopeFromJSON(object.scope) : undefined,
      hashes: globalThis.Array.isArray(object?.hashes) ? object.hashes.map((e: any) => Hash.fromJSON(e)) : [],
      licenses: globalThis.Array.isArray(object?.licenses)
        ? object.licenses.map((e: any) => LicenseChoice.fromJSON(e))
        : [],
      copyright: isSet(object.copyright) ? globalThis.String(object.copyright) : undefined,
      cpe: isSet(object.cpe) ? globalThis.String(object.cpe) : undefined,
      purl: isSet(object.purl) ? globalThis.String(object.purl) : undefined,
      swid: isSet(object.swid) ? Swid.fromJSON(object.swid) : undefined,
      modified: isSet(object.modified) ? globalThis.Boolean(object.modified) : undefined,
      pedigree: isSet(object.pedigree) ? Pedigree.fromJSON(object.pedigree) : undefined,
      externalReferences: globalThis.Array.isArray(object?.externalReferences)
        ? object.externalReferences.map((e: any) => ExternalReference.fromJSON(e))
        : [],
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => Component.fromJSON(e))
        : [],
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
      evidence: isSet(object.evidence) ? Evidence.fromJSON(object.evidence) : undefined,
      releaseNotes: isSet(object.releaseNotes) ? ReleaseNotes.fromJSON(object.releaseNotes) : undefined,
      modelCard: isSet(object.modelCard) ? ModelCard.fromJSON(object.modelCard) : undefined,
      data: globalThis.Array.isArray(object?.data)
        ? object.data.map((e: any) => ComponentData.fromJSON(e))
        : [],
      cryptoProperties: isSet(object.cryptoProperties) ? CryptoProperties.fromJSON(object.cryptoProperties) : undefined,
      manufacturer: isSet(object.manufacturer) ? OrganizationalEntity.fromJSON(object.manufacturer) : undefined,
      authors: globalThis.Array.isArray(object?.authors)
        ? object.authors.map((e: any) => OrganizationalContact.fromJSON(e))
        : [],
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      omniborId: globalThis.Array.isArray(object?.omniborId)
        ? object.omniborId.map((e: any) => globalThis.String(e))
        : [],
      swhid: globalThis.Array.isArray(object?.swhid)
        ? object.swhid.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Component): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = classificationToJSON(message.type);
    }
    if (message.mimeType !== undefined) {
      obj.mimeType = message.mimeType;
    }
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.supplier !== undefined) {
      obj.supplier = OrganizationalEntity.toJSON(message.supplier);
    }
    if (message.author !== undefined) {
      obj.author = message.author;
    }
    if (message.publisher !== undefined) {
      obj.publisher = message.publisher;
    }
    if (message.group !== undefined) {
      obj.group = message.group;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.scope !== undefined) {
      obj.scope = scopeToJSON(message.scope);
    }
    if (message.hashes?.length) {
      obj.hashes = message.hashes.map((e) => Hash.toJSON(e));
    }
    if (message.licenses?.length) {
      obj.licenses = message.licenses.map((e) => LicenseChoice.toJSON(e));
    }
    if (message.copyright !== undefined) {
      obj.copyright = message.copyright;
    }
    if (message.cpe !== undefined) {
      obj.cpe = message.cpe;
    }
    if (message.purl !== undefined) {
      obj.purl = message.purl;
    }
    if (message.swid !== undefined) {
      obj.swid = Swid.toJSON(message.swid);
    }
    if (message.modified !== undefined) {
      obj.modified = message.modified;
    }
    if (message.pedigree !== undefined) {
      obj.pedigree = Pedigree.toJSON(message.pedigree);
    }
    if (message.externalReferences?.length) {
      obj.externalReferences = message.externalReferences.map((e) => ExternalReference.toJSON(e));
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => Component.toJSON(e));
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    if (message.evidence !== undefined) {
      obj.evidence = Evidence.toJSON(message.evidence);
    }
    if (message.releaseNotes !== undefined) {
      obj.releaseNotes = ReleaseNotes.toJSON(message.releaseNotes);
    }
    if (message.modelCard !== undefined) {
      obj.modelCard = ModelCard.toJSON(message.modelCard);
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => ComponentData.toJSON(e));
    }
    if (message.cryptoProperties !== undefined) {
      obj.cryptoProperties = CryptoProperties.toJSON(message.cryptoProperties);
    }
    if (message.manufacturer !== undefined) {
      obj.manufacturer = OrganizationalEntity.toJSON(message.manufacturer);
    }
    if (message.authors?.length) {
      obj.authors = message.authors.map((e) => OrganizationalContact.toJSON(e));
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.omniborId?.length) {
      obj.omniborId = message.omniborId;
    }
    if (message.swhid?.length) {
      obj.swhid = message.swhid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Component>, I>>(base?: I): Component {
    return Component.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Component>, I>>(object: I): Component {
    const message = createBaseComponent();
    message.type = object.type ?? 0;
    message.mimeType = object.mimeType ?? undefined;
    message.bomRef = object.bomRef ?? undefined;
    message.supplier = (object.supplier !== undefined && object.supplier !== null)
      ? OrganizationalEntity.fromPartial(object.supplier)
      : undefined;
    message.author = object.author ?? undefined;
    message.publisher = object.publisher ?? undefined;
    message.group = object.group ?? undefined;
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.description = object.description ?? undefined;
    message.scope = object.scope ?? undefined;
    message.hashes = object.hashes?.map((e) => Hash.fromPartial(e)) || [];
    message.licenses = object.licenses?.map((e) => LicenseChoice.fromPartial(e)) || [];
    message.copyright = object.copyright ?? undefined;
    message.cpe = object.cpe ?? undefined;
    message.purl = object.purl ?? undefined;
    message.swid = (object.swid !== undefined && object.swid !== null) ? Swid.fromPartial(object.swid) : undefined;
    message.modified = object.modified ?? undefined;
    message.pedigree = (object.pedigree !== undefined && object.pedigree !== null)
      ? Pedigree.fromPartial(object.pedigree)
      : undefined;
    message.externalReferences = object.externalReferences?.map((e) => ExternalReference.fromPartial(e)) || [];
    message.components = object.components?.map((e) => Component.fromPartial(e)) || [];
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    message.evidence = (object.evidence !== undefined && object.evidence !== null)
      ? Evidence.fromPartial(object.evidence)
      : undefined;
    message.releaseNotes = (object.releaseNotes !== undefined && object.releaseNotes !== null)
      ? ReleaseNotes.fromPartial(object.releaseNotes)
      : undefined;
    message.modelCard = (object.modelCard !== undefined && object.modelCard !== null)
      ? ModelCard.fromPartial(object.modelCard)
      : undefined;
    message.data = object.data?.map((e) => ComponentData.fromPartial(e)) || [];
    message.cryptoProperties = (object.cryptoProperties !== undefined && object.cryptoProperties !== null)
      ? CryptoProperties.fromPartial(object.cryptoProperties)
      : undefined;
    message.manufacturer = (object.manufacturer !== undefined && object.manufacturer !== null)
      ? OrganizationalEntity.fromPartial(object.manufacturer)
      : undefined;
    message.authors = object.authors?.map((e) => OrganizationalContact.fromPartial(e)) || [];
    message.tags = object.tags?.map((e) => e) || [];
    message.omniborId = object.omniborId?.map((e) => e) || [];
    message.swhid = object.swhid?.map((e) => e) || [];
    return message;
  },
};

function createBaseDataFlow(): DataFlow {
  return {
    flow: 0,
    value: "",
    name: undefined,
    description: undefined,
    source: [],
    destination: [],
    governance: undefined,
  };
}

export const DataFlow: MessageFns<DataFlow> = {
  encode(message: DataFlow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.flow !== 0) {
      writer.uint32(8).int32(message.flow);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.source) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.destination) {
      writer.uint32(50).string(v!);
    }
    if (message.governance !== undefined) {
      DataGovernance.encode(message.governance, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataFlow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataFlow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.flow = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.source.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.destination.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.governance = DataGovernance.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataFlow {
    return {
      flow: isSet(object.flow) ? dataFlowDirectionFromJSON(object.flow) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      source: globalThis.Array.isArray(object?.source) ? object.source.map((e: any) => globalThis.String(e)) : [],
      destination: globalThis.Array.isArray(object?.destination)
        ? object.destination.map((e: any) => globalThis.String(e))
        : [],
      governance: isSet(object.governance) ? DataGovernance.fromJSON(object.governance) : undefined,
    };
  },

  toJSON(message: DataFlow): unknown {
    const obj: any = {};
    if (message.flow !== 0) {
      obj.flow = dataFlowDirectionToJSON(message.flow);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.source?.length) {
      obj.source = message.source;
    }
    if (message.destination?.length) {
      obj.destination = message.destination;
    }
    if (message.governance !== undefined) {
      obj.governance = DataGovernance.toJSON(message.governance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataFlow>, I>>(base?: I): DataFlow {
    return DataFlow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataFlow>, I>>(object: I): DataFlow {
    const message = createBaseDataFlow();
    message.flow = object.flow ?? 0;
    message.value = object.value ?? "";
    message.name = object.name ?? undefined;
    message.description = object.description ?? undefined;
    message.source = object.source?.map((e) => e) || [];
    message.destination = object.destination?.map((e) => e) || [];
    message.governance = (object.governance !== undefined && object.governance !== null)
      ? DataGovernance.fromPartial(object.governance)
      : undefined;
    return message;
  },
};

function createBaseDependency(): Dependency {
  return { ref: "", dependencies: [], provides: [] };
}

export const Dependency: MessageFns<Dependency> = {
  encode(message: Dependency, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ref !== "") {
      writer.uint32(10).string(message.ref);
    }
    for (const v of message.dependencies) {
      Dependency.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.provides) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Dependency {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDependency();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ref = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dependencies.push(Dependency.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.provides.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Dependency {
    return {
      ref: isSet(object.ref) ? globalThis.String(object.ref) : "",
      dependencies: globalThis.Array.isArray(object?.dependencies)
        ? object.dependencies.map((e: any) => Dependency.fromJSON(e))
        : [],
      provides: globalThis.Array.isArray(object?.provides) ? object.provides.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Dependency): unknown {
    const obj: any = {};
    if (message.ref !== "") {
      obj.ref = message.ref;
    }
    if (message.dependencies?.length) {
      obj.dependencies = message.dependencies.map((e) => Dependency.toJSON(e));
    }
    if (message.provides?.length) {
      obj.provides = message.provides;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Dependency>, I>>(base?: I): Dependency {
    return Dependency.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Dependency>, I>>(object: I): Dependency {
    const message = createBaseDependency();
    message.ref = object.ref ?? "";
    message.dependencies = object.dependencies?.map((e) => Dependency.fromPartial(e)) || [];
    message.provides = object.provides?.map((e) => e) || [];
    return message;
  },
};

function createBaseDiff(): Diff {
  return { text: undefined, url: undefined };
}

export const Diff: MessageFns<Diff> = {
  encode(message: Diff, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== undefined) {
      AttachedText.encode(message.text, writer.uint32(10).fork()).join();
    }
    if (message.url !== undefined) {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Diff {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = AttachedText.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Diff {
    return {
      text: isSet(object.text) ? AttachedText.fromJSON(object.text) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : undefined,
    };
  },

  toJSON(message: Diff): unknown {
    const obj: any = {};
    if (message.text !== undefined) {
      obj.text = AttachedText.toJSON(message.text);
    }
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Diff>, I>>(base?: I): Diff {
    return Diff.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Diff>, I>>(object: I): Diff {
    const message = createBaseDiff();
    message.text = (object.text !== undefined && object.text !== null)
      ? AttachedText.fromPartial(object.text)
      : undefined;
    message.url = object.url ?? undefined;
    return message;
  },
};

function createBaseExternalReference(): ExternalReference {
  return { type: 0, url: "", comment: undefined, hashes: [] };
}

export const ExternalReference: MessageFns<ExternalReference> = {
  encode(message: ExternalReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.comment !== undefined) {
      writer.uint32(26).string(message.comment);
    }
    for (const v of message.hashes) {
      Hash.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.comment = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hashes.push(Hash.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExternalReference {
    return {
      type: isSet(object.type) ? externalReferenceTypeFromJSON(object.type) : 0,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      comment: isSet(object.comment) ? globalThis.String(object.comment) : undefined,
      hashes: globalThis.Array.isArray(object?.hashes) ? object.hashes.map((e: any) => Hash.fromJSON(e)) : [],
    };
  },

  toJSON(message: ExternalReference): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = externalReferenceTypeToJSON(message.type);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.comment !== undefined) {
      obj.comment = message.comment;
    }
    if (message.hashes?.length) {
      obj.hashes = message.hashes.map((e) => Hash.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExternalReference>, I>>(base?: I): ExternalReference {
    return ExternalReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExternalReference>, I>>(object: I): ExternalReference {
    const message = createBaseExternalReference();
    message.type = object.type ?? 0;
    message.url = object.url ?? "";
    message.comment = object.comment ?? undefined;
    message.hashes = object.hashes?.map((e) => Hash.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHash(): Hash {
  return { alg: 0, value: "" };
}

export const Hash: MessageFns<Hash> = {
  encode(message: Hash, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.alg !== 0) {
      writer.uint32(8).int32(message.alg);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hash {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.alg = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hash {
    return {
      alg: isSet(object.alg) ? hashAlgFromJSON(object.alg) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Hash): unknown {
    const obj: any = {};
    if (message.alg !== 0) {
      obj.alg = hashAlgToJSON(message.alg);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Hash>, I>>(base?: I): Hash {
    return Hash.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Hash>, I>>(object: I): Hash {
    const message = createBaseHash();
    message.alg = object.alg ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseIdentifiableAction(): IdentifiableAction {
  return { timestamp: undefined, name: undefined, email: undefined };
}

export const IdentifiableAction: MessageFns<IdentifiableAction> = {
  encode(message: IdentifiableAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.email !== undefined) {
      writer.uint32(26).string(message.email);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdentifiableAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdentifiableAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdentifiableAction {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
    };
  },

  toJSON(message: IdentifiableAction): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdentifiableAction>, I>>(base?: I): IdentifiableAction {
    return IdentifiableAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdentifiableAction>, I>>(object: I): IdentifiableAction {
    const message = createBaseIdentifiableAction();
    message.timestamp = object.timestamp ?? undefined;
    message.name = object.name ?? undefined;
    message.email = object.email ?? undefined;
    return message;
  },
};

function createBaseIssue(): Issue {
  return { type: 0, id: undefined, name: undefined, description: undefined, source: undefined, references: [] };
}

export const Issue: MessageFns<Issue> = {
  encode(message: Issue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== undefined) {
      writer.uint32(18).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.source !== undefined) {
      Source.encode(message.source, writer.uint32(42).fork()).join();
    }
    for (const v of message.references) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Issue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIssue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.source = Source.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.references.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Issue {
    return {
      type: isSet(object.type) ? issueClassificationFromJSON(object.type) : 0,
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      source: isSet(object.source) ? Source.fromJSON(object.source) : undefined,
      references: globalThis.Array.isArray(object?.references)
        ? object.references.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Issue): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = issueClassificationToJSON(message.type);
    }
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.source !== undefined) {
      obj.source = Source.toJSON(message.source);
    }
    if (message.references?.length) {
      obj.references = message.references;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Issue>, I>>(base?: I): Issue {
    return Issue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Issue>, I>>(object: I): Issue {
    const message = createBaseIssue();
    message.type = object.type ?? 0;
    message.id = object.id ?? undefined;
    message.name = object.name ?? undefined;
    message.description = object.description ?? undefined;
    message.source = (object.source !== undefined && object.source !== null)
      ? Source.fromPartial(object.source)
      : undefined;
    message.references = object.references?.map((e) => e) || [];
    return message;
  },
};

function createBaseSource(): Source {
  return { name: undefined, url: undefined };
}

export const Source: MessageFns<Source> = {
  encode(message: Source, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.url !== undefined) {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Source {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Source {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : undefined,
    };
  },

  toJSON(message: Source): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Source>, I>>(base?: I): Source {
    return Source.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Source>, I>>(object: I): Source {
    const message = createBaseSource();
    message.name = object.name ?? undefined;
    message.url = object.url ?? undefined;
    return message;
  },
};

function createBaseLicenseChoice(): LicenseChoice {
  return { license: undefined, expression: undefined, acknowledgement: undefined, bomRef: undefined };
}

export const LicenseChoice: MessageFns<LicenseChoice> = {
  encode(message: LicenseChoice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.license !== undefined) {
      License.encode(message.license, writer.uint32(10).fork()).join();
    }
    if (message.expression !== undefined) {
      writer.uint32(18).string(message.expression);
    }
    if (message.acknowledgement !== undefined) {
      writer.uint32(24).int32(message.acknowledgement);
    }
    if (message.bomRef !== undefined) {
      writer.uint32(34).string(message.bomRef);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LicenseChoice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLicenseChoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.license = License.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expression = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.acknowledgement = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LicenseChoice {
    return {
      license: isSet(object.license) ? License.fromJSON(object.license) : undefined,
      expression: isSet(object.expression) ? globalThis.String(object.expression) : undefined,
      acknowledgement: isSet(object.acknowledgement)
        ? licenseAcknowledgementEnumerationFromJSON(object.acknowledgement)
        : undefined,
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
    };
  },

  toJSON(message: LicenseChoice): unknown {
    const obj: any = {};
    if (message.license !== undefined) {
      obj.license = License.toJSON(message.license);
    }
    if (message.expression !== undefined) {
      obj.expression = message.expression;
    }
    if (message.acknowledgement !== undefined) {
      obj.acknowledgement = licenseAcknowledgementEnumerationToJSON(message.acknowledgement);
    }
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LicenseChoice>, I>>(base?: I): LicenseChoice {
    return LicenseChoice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LicenseChoice>, I>>(object: I): LicenseChoice {
    const message = createBaseLicenseChoice();
    message.license = (object.license !== undefined && object.license !== null)
      ? License.fromPartial(object.license)
      : undefined;
    message.expression = object.expression ?? undefined;
    message.acknowledgement = object.acknowledgement ?? undefined;
    message.bomRef = object.bomRef ?? undefined;
    return message;
  },
};

function createBaseLicense(): License {
  return {
    id: undefined,
    name: undefined,
    text: undefined,
    url: undefined,
    bomRef: undefined,
    licensing: undefined,
    properties: [],
    acknowledgement: undefined,
  };
}

export const License: MessageFns<License> = {
  encode(message: License, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.text !== undefined) {
      AttachedText.encode(message.text, writer.uint32(26).fork()).join();
    }
    if (message.url !== undefined) {
      writer.uint32(34).string(message.url);
    }
    if (message.bomRef !== undefined) {
      writer.uint32(42).string(message.bomRef);
    }
    if (message.licensing !== undefined) {
      Licensing.encode(message.licensing, writer.uint32(50).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.acknowledgement !== undefined) {
      writer.uint32(64).int32(message.acknowledgement);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): License {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLicense();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.text = AttachedText.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.licensing = Licensing.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.acknowledgement = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): License {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      text: isSet(object.text) ? AttachedText.fromJSON(object.text) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : undefined,
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      licensing: isSet(object.licensing) ? Licensing.fromJSON(object.licensing) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
      acknowledgement: isSet(object.acknowledgement)
        ? licenseAcknowledgementEnumerationFromJSON(object.acknowledgement)
        : undefined,
    };
  },

  toJSON(message: License): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.text !== undefined) {
      obj.text = AttachedText.toJSON(message.text);
    }
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.licensing !== undefined) {
      obj.licensing = Licensing.toJSON(message.licensing);
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    if (message.acknowledgement !== undefined) {
      obj.acknowledgement = licenseAcknowledgementEnumerationToJSON(message.acknowledgement);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<License>, I>>(base?: I): License {
    return License.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<License>, I>>(object: I): License {
    const message = createBaseLicense();
    message.id = object.id ?? undefined;
    message.name = object.name ?? undefined;
    message.text = (object.text !== undefined && object.text !== null)
      ? AttachedText.fromPartial(object.text)
      : undefined;
    message.url = object.url ?? undefined;
    message.bomRef = object.bomRef ?? undefined;
    message.licensing = (object.licensing !== undefined && object.licensing !== null)
      ? Licensing.fromPartial(object.licensing)
      : undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    message.acknowledgement = object.acknowledgement ?? undefined;
    return message;
  },
};

function createBaseLicensing(): Licensing {
  return {
    altIds: [],
    licensor: undefined,
    licensee: undefined,
    purchaser: undefined,
    purchaseOrder: undefined,
    licenseTypes: [],
    lastRenewal: undefined,
    expiration: undefined,
  };
}

export const Licensing: MessageFns<Licensing> = {
  encode(message: Licensing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.altIds) {
      writer.uint32(10).string(v!);
    }
    if (message.licensor !== undefined) {
      OrganizationalEntityOrContact.encode(message.licensor, writer.uint32(18).fork()).join();
    }
    if (message.licensee !== undefined) {
      OrganizationalEntityOrContact.encode(message.licensee, writer.uint32(26).fork()).join();
    }
    if (message.purchaser !== undefined) {
      OrganizationalEntityOrContact.encode(message.purchaser, writer.uint32(34).fork()).join();
    }
    if (message.purchaseOrder !== undefined) {
      writer.uint32(42).string(message.purchaseOrder);
    }
    writer.uint32(50).fork();
    for (const v of message.licenseTypes) {
      writer.int32(v);
    }
    writer.join();
    if (message.lastRenewal !== undefined) {
      Timestamp.encode(toTimestamp(message.lastRenewal), writer.uint32(58).fork()).join();
    }
    if (message.expiration !== undefined) {
      Timestamp.encode(toTimestamp(message.expiration), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Licensing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLicensing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.altIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.licensor = OrganizationalEntityOrContact.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.licensee = OrganizationalEntityOrContact.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.purchaser = OrganizationalEntityOrContact.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.purchaseOrder = reader.string();
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.licenseTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.licenseTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.lastRenewal = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.expiration = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Licensing {
    return {
      altIds: globalThis.Array.isArray(object?.altIds) ? object.altIds.map((e: any) => globalThis.String(e)) : [],
      licensor: isSet(object.licensor) ? OrganizationalEntityOrContact.fromJSON(object.licensor) : undefined,
      licensee: isSet(object.licensee) ? OrganizationalEntityOrContact.fromJSON(object.licensee) : undefined,
      purchaser: isSet(object.purchaser) ? OrganizationalEntityOrContact.fromJSON(object.purchaser) : undefined,
      purchaseOrder: isSet(object.purchaseOrder) ? globalThis.String(object.purchaseOrder) : undefined,
      licenseTypes: globalThis.Array.isArray(object?.licenseTypes)
        ? object.licenseTypes.map((e: any) => licensingTypeEnumFromJSON(e))
        : [],
      lastRenewal: isSet(object.lastRenewal) ? fromJsonTimestamp(object.lastRenewal) : undefined,
      expiration: isSet(object.expiration) ? fromJsonTimestamp(object.expiration) : undefined,
    };
  },

  toJSON(message: Licensing): unknown {
    const obj: any = {};
    if (message.altIds?.length) {
      obj.altIds = message.altIds;
    }
    if (message.licensor !== undefined) {
      obj.licensor = OrganizationalEntityOrContact.toJSON(message.licensor);
    }
    if (message.licensee !== undefined) {
      obj.licensee = OrganizationalEntityOrContact.toJSON(message.licensee);
    }
    if (message.purchaser !== undefined) {
      obj.purchaser = OrganizationalEntityOrContact.toJSON(message.purchaser);
    }
    if (message.purchaseOrder !== undefined) {
      obj.purchaseOrder = message.purchaseOrder;
    }
    if (message.licenseTypes?.length) {
      obj.licenseTypes = message.licenseTypes.map((e) => licensingTypeEnumToJSON(e));
    }
    if (message.lastRenewal !== undefined) {
      obj.lastRenewal = message.lastRenewal.toISOString();
    }
    if (message.expiration !== undefined) {
      obj.expiration = message.expiration.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Licensing>, I>>(base?: I): Licensing {
    return Licensing.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Licensing>, I>>(object: I): Licensing {
    const message = createBaseLicensing();
    message.altIds = object.altIds?.map((e) => e) || [];
    message.licensor = (object.licensor !== undefined && object.licensor !== null)
      ? OrganizationalEntityOrContact.fromPartial(object.licensor)
      : undefined;
    message.licensee = (object.licensee !== undefined && object.licensee !== null)
      ? OrganizationalEntityOrContact.fromPartial(object.licensee)
      : undefined;
    message.purchaser = (object.purchaser !== undefined && object.purchaser !== null)
      ? OrganizationalEntityOrContact.fromPartial(object.purchaser)
      : undefined;
    message.purchaseOrder = object.purchaseOrder ?? undefined;
    message.licenseTypes = object.licenseTypes?.map((e) => e) || [];
    message.lastRenewal = object.lastRenewal ?? undefined;
    message.expiration = object.expiration ?? undefined;
    return message;
  },
};

function createBaseOrganizationalEntityOrContact(): OrganizationalEntityOrContact {
  return { organization: undefined, individual: undefined };
}

export const OrganizationalEntityOrContact: MessageFns<OrganizationalEntityOrContact> = {
  encode(message: OrganizationalEntityOrContact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organization !== undefined) {
      OrganizationalEntity.encode(message.organization, writer.uint32(10).fork()).join();
    }
    if (message.individual !== undefined) {
      OrganizationalContact.encode(message.individual, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrganizationalEntityOrContact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrganizationalEntityOrContact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organization = OrganizationalEntity.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.individual = OrganizationalContact.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrganizationalEntityOrContact {
    return {
      organization: isSet(object.organization) ? OrganizationalEntity.fromJSON(object.organization) : undefined,
      individual: isSet(object.individual) ? OrganizationalContact.fromJSON(object.individual) : undefined,
    };
  },

  toJSON(message: OrganizationalEntityOrContact): unknown {
    const obj: any = {};
    if (message.organization !== undefined) {
      obj.organization = OrganizationalEntity.toJSON(message.organization);
    }
    if (message.individual !== undefined) {
      obj.individual = OrganizationalContact.toJSON(message.individual);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrganizationalEntityOrContact>, I>>(base?: I): OrganizationalEntityOrContact {
    return OrganizationalEntityOrContact.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrganizationalEntityOrContact>, I>>(
    object: I,
  ): OrganizationalEntityOrContact {
    const message = createBaseOrganizationalEntityOrContact();
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? OrganizationalEntity.fromPartial(object.organization)
      : undefined;
    message.individual = (object.individual !== undefined && object.individual !== null)
      ? OrganizationalContact.fromPartial(object.individual)
      : undefined;
    return message;
  },
};

function createBaseMetadata(): Metadata {
  return {
    timestamp: undefined,
    tools: undefined,
    authors: [],
    component: undefined,
    manufacture: undefined,
    supplier: undefined,
    licenses: [],
    properties: [],
    lifecycles: [],
    manufacturer: undefined,
  };
}

export const Metadata: MessageFns<Metadata> = {
  encode(message: Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    if (message.tools !== undefined) {
      Tool.encode(message.tools, writer.uint32(18).fork()).join();
    }
    for (const v of message.authors) {
      OrganizationalContact.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.component !== undefined) {
      Component.encode(message.component, writer.uint32(34).fork()).join();
    }
    if (message.manufacture !== undefined) {
      OrganizationalEntity.encode(message.manufacture, writer.uint32(42).fork()).join();
    }
    if (message.supplier !== undefined) {
      OrganizationalEntity.encode(message.supplier, writer.uint32(50).fork()).join();
    }
    for (const v of message.licenses) {
      LicenseChoice.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.lifecycles) {
      Lifecycles.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.manufacturer !== undefined) {
      OrganizationalEntity.encode(message.manufacturer, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tools = Tool.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authors.push(OrganizationalContact.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.component = Component.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.manufacture = OrganizationalEntity.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.supplier = OrganizationalEntity.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.licenses.push(LicenseChoice.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.lifecycles.push(Lifecycles.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.manufacturer = OrganizationalEntity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata {
    return {
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      tools: isSet(object.tools) ? Tool.fromJSON(object.tools) : undefined,
      authors: globalThis.Array.isArray(object?.authors)
        ? object.authors.map((e: any) => OrganizationalContact.fromJSON(e))
        : [],
      component: isSet(object.component) ? Component.fromJSON(object.component) : undefined,
      manufacture: isSet(object.manufacture) ? OrganizationalEntity.fromJSON(object.manufacture) : undefined,
      supplier: isSet(object.supplier) ? OrganizationalEntity.fromJSON(object.supplier) : undefined,
      licenses: globalThis.Array.isArray(object?.licenses)
        ? object.licenses.map((e: any) => LicenseChoice.fromJSON(e))
        : [],
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
      lifecycles: globalThis.Array.isArray(object?.lifecycles)
        ? object.lifecycles.map((e: any) => Lifecycles.fromJSON(e))
        : [],
      manufacturer: isSet(object.manufacturer) ? OrganizationalEntity.fromJSON(object.manufacturer) : undefined,
    };
  },

  toJSON(message: Metadata): unknown {
    const obj: any = {};
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.tools !== undefined) {
      obj.tools = Tool.toJSON(message.tools);
    }
    if (message.authors?.length) {
      obj.authors = message.authors.map((e) => OrganizationalContact.toJSON(e));
    }
    if (message.component !== undefined) {
      obj.component = Component.toJSON(message.component);
    }
    if (message.manufacture !== undefined) {
      obj.manufacture = OrganizationalEntity.toJSON(message.manufacture);
    }
    if (message.supplier !== undefined) {
      obj.supplier = OrganizationalEntity.toJSON(message.supplier);
    }
    if (message.licenses?.length) {
      obj.licenses = message.licenses.map((e) => LicenseChoice.toJSON(e));
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    if (message.lifecycles?.length) {
      obj.lifecycles = message.lifecycles.map((e) => Lifecycles.toJSON(e));
    }
    if (message.manufacturer !== undefined) {
      obj.manufacturer = OrganizationalEntity.toJSON(message.manufacturer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Metadata>, I>>(base?: I): Metadata {
    return Metadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Metadata>, I>>(object: I): Metadata {
    const message = createBaseMetadata();
    message.timestamp = object.timestamp ?? undefined;
    message.tools = (object.tools !== undefined && object.tools !== null) ? Tool.fromPartial(object.tools) : undefined;
    message.authors = object.authors?.map((e) => OrganizationalContact.fromPartial(e)) || [];
    message.component = (object.component !== undefined && object.component !== null)
      ? Component.fromPartial(object.component)
      : undefined;
    message.manufacture = (object.manufacture !== undefined && object.manufacture !== null)
      ? OrganizationalEntity.fromPartial(object.manufacture)
      : undefined;
    message.supplier = (object.supplier !== undefined && object.supplier !== null)
      ? OrganizationalEntity.fromPartial(object.supplier)
      : undefined;
    message.licenses = object.licenses?.map((e) => LicenseChoice.fromPartial(e)) || [];
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    message.lifecycles = object.lifecycles?.map((e) => Lifecycles.fromPartial(e)) || [];
    message.manufacturer = (object.manufacturer !== undefined && object.manufacturer !== null)
      ? OrganizationalEntity.fromPartial(object.manufacturer)
      : undefined;
    return message;
  },
};

function createBaseLifecycles(): Lifecycles {
  return { phase: undefined, name: undefined, description: undefined };
}

export const Lifecycles: MessageFns<Lifecycles> = {
  encode(message: Lifecycles, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.phase !== undefined) {
      writer.uint32(8).int32(message.phase);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Lifecycles {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLifecycles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.phase = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Lifecycles {
    return {
      phase: isSet(object.phase) ? lifecyclePhaseFromJSON(object.phase) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
    };
  },

  toJSON(message: Lifecycles): unknown {
    const obj: any = {};
    if (message.phase !== undefined) {
      obj.phase = lifecyclePhaseToJSON(message.phase);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Lifecycles>, I>>(base?: I): Lifecycles {
    return Lifecycles.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Lifecycles>, I>>(object: I): Lifecycles {
    const message = createBaseLifecycles();
    message.phase = object.phase ?? undefined;
    message.name = object.name ?? undefined;
    message.description = object.description ?? undefined;
    return message;
  },
};

function createBaseOrganizationalContact(): OrganizationalContact {
  return { name: undefined, email: undefined, phone: undefined, bomRef: undefined };
}

export const OrganizationalContact: MessageFns<OrganizationalContact> = {
  encode(message: OrganizationalContact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.email !== undefined) {
      writer.uint32(18).string(message.email);
    }
    if (message.phone !== undefined) {
      writer.uint32(26).string(message.phone);
    }
    if (message.bomRef !== undefined) {
      writer.uint32(34).string(message.bomRef);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrganizationalContact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrganizationalContact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.phone = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrganizationalContact {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      phone: isSet(object.phone) ? globalThis.String(object.phone) : undefined,
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
    };
  },

  toJSON(message: OrganizationalContact): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.phone !== undefined) {
      obj.phone = message.phone;
    }
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrganizationalContact>, I>>(base?: I): OrganizationalContact {
    return OrganizationalContact.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrganizationalContact>, I>>(object: I): OrganizationalContact {
    const message = createBaseOrganizationalContact();
    message.name = object.name ?? undefined;
    message.email = object.email ?? undefined;
    message.phone = object.phone ?? undefined;
    message.bomRef = object.bomRef ?? undefined;
    return message;
  },
};

function createBaseOrganizationalEntity(): OrganizationalEntity {
  return { name: undefined, url: [], contact: [], bomRef: undefined, address: undefined };
}

export const OrganizationalEntity: MessageFns<OrganizationalEntity> = {
  encode(message: OrganizationalEntity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.url) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.contact) {
      OrganizationalContact.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.bomRef !== undefined) {
      writer.uint32(34).string(message.bomRef);
    }
    if (message.address !== undefined) {
      PostalAddressType.encode(message.address, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrganizationalEntity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrganizationalEntity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contact.push(OrganizationalContact.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.address = PostalAddressType.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrganizationalEntity {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      url: globalThis.Array.isArray(object?.url) ? object.url.map((e: any) => globalThis.String(e)) : [],
      contact: globalThis.Array.isArray(object?.contact)
        ? object.contact.map((e: any) => OrganizationalContact.fromJSON(e))
        : [],
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      address: isSet(object.address) ? PostalAddressType.fromJSON(object.address) : undefined,
    };
  },

  toJSON(message: OrganizationalEntity): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.url?.length) {
      obj.url = message.url;
    }
    if (message.contact?.length) {
      obj.contact = message.contact.map((e) => OrganizationalContact.toJSON(e));
    }
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.address !== undefined) {
      obj.address = PostalAddressType.toJSON(message.address);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrganizationalEntity>, I>>(base?: I): OrganizationalEntity {
    return OrganizationalEntity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrganizationalEntity>, I>>(object: I): OrganizationalEntity {
    const message = createBaseOrganizationalEntity();
    message.name = object.name ?? undefined;
    message.url = object.url?.map((e) => e) || [];
    message.contact = object.contact?.map((e) => OrganizationalContact.fromPartial(e)) || [];
    message.bomRef = object.bomRef ?? undefined;
    message.address = (object.address !== undefined && object.address !== null)
      ? PostalAddressType.fromPartial(object.address)
      : undefined;
    return message;
  },
};

function createBasePatch(): Patch {
  return { type: 0, diff: undefined, resolves: [] };
}

export const Patch: MessageFns<Patch> = {
  encode(message: Patch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.diff !== undefined) {
      Diff.encode(message.diff, writer.uint32(18).fork()).join();
    }
    for (const v of message.resolves) {
      Issue.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Patch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.diff = Diff.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resolves.push(Issue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Patch {
    return {
      type: isSet(object.type) ? patchClassificationFromJSON(object.type) : 0,
      diff: isSet(object.diff) ? Diff.fromJSON(object.diff) : undefined,
      resolves: globalThis.Array.isArray(object?.resolves) ? object.resolves.map((e: any) => Issue.fromJSON(e)) : [],
    };
  },

  toJSON(message: Patch): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = patchClassificationToJSON(message.type);
    }
    if (message.diff !== undefined) {
      obj.diff = Diff.toJSON(message.diff);
    }
    if (message.resolves?.length) {
      obj.resolves = message.resolves.map((e) => Issue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Patch>, I>>(base?: I): Patch {
    return Patch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Patch>, I>>(object: I): Patch {
    const message = createBasePatch();
    message.type = object.type ?? 0;
    message.diff = (object.diff !== undefined && object.diff !== null) ? Diff.fromPartial(object.diff) : undefined;
    message.resolves = object.resolves?.map((e) => Issue.fromPartial(e)) || [];
    return message;
  },
};

function createBasePedigree(): Pedigree {
  return { ancestors: [], descendants: [], variants: [], commits: [], patches: [], notes: undefined };
}

export const Pedigree: MessageFns<Pedigree> = {
  encode(message: Pedigree, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.ancestors) {
      Component.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.descendants) {
      Component.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.variants) {
      Component.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.commits) {
      Commit.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.patches) {
      Patch.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.notes !== undefined) {
      writer.uint32(50).string(message.notes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pedigree {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePedigree();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ancestors.push(Component.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.descendants.push(Component.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.variants.push(Component.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.commits.push(Commit.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.patches.push(Patch.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pedigree {
    return {
      ancestors: globalThis.Array.isArray(object?.ancestors)
        ? object.ancestors.map((e: any) => Component.fromJSON(e))
        : [],
      descendants: globalThis.Array.isArray(object?.descendants)
        ? object.descendants.map((e: any) => Component.fromJSON(e))
        : [],
      variants: globalThis.Array.isArray(object?.variants)
        ? object.variants.map((e: any) => Component.fromJSON(e))
        : [],
      commits: globalThis.Array.isArray(object?.commits) ? object.commits.map((e: any) => Commit.fromJSON(e)) : [],
      patches: globalThis.Array.isArray(object?.patches) ? object.patches.map((e: any) => Patch.fromJSON(e)) : [],
      notes: isSet(object.notes) ? globalThis.String(object.notes) : undefined,
    };
  },

  toJSON(message: Pedigree): unknown {
    const obj: any = {};
    if (message.ancestors?.length) {
      obj.ancestors = message.ancestors.map((e) => Component.toJSON(e));
    }
    if (message.descendants?.length) {
      obj.descendants = message.descendants.map((e) => Component.toJSON(e));
    }
    if (message.variants?.length) {
      obj.variants = message.variants.map((e) => Component.toJSON(e));
    }
    if (message.commits?.length) {
      obj.commits = message.commits.map((e) => Commit.toJSON(e));
    }
    if (message.patches?.length) {
      obj.patches = message.patches.map((e) => Patch.toJSON(e));
    }
    if (message.notes !== undefined) {
      obj.notes = message.notes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pedigree>, I>>(base?: I): Pedigree {
    return Pedigree.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pedigree>, I>>(object: I): Pedigree {
    const message = createBasePedigree();
    message.ancestors = object.ancestors?.map((e) => Component.fromPartial(e)) || [];
    message.descendants = object.descendants?.map((e) => Component.fromPartial(e)) || [];
    message.variants = object.variants?.map((e) => Component.fromPartial(e)) || [];
    message.commits = object.commits?.map((e) => Commit.fromPartial(e)) || [];
    message.patches = object.patches?.map((e) => Patch.fromPartial(e)) || [];
    message.notes = object.notes ?? undefined;
    return message;
  },
};

function createBaseService(): Service {
  return {
    bomRef: undefined,
    provider: undefined,
    group: undefined,
    name: "",
    version: undefined,
    description: undefined,
    endpoints: [],
    authenticated: undefined,
    xTrustBoundary: undefined,
    data: [],
    licenses: [],
    externalReferences: [],
    services: [],
    properties: [],
    releaseNotes: undefined,
    trustZone: undefined,
    tags: [],
  };
}

export const Service: MessageFns<Service> = {
  encode(message: Service, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== undefined) {
      writer.uint32(10).string(message.bomRef);
    }
    if (message.provider !== undefined) {
      OrganizationalEntity.encode(message.provider, writer.uint32(18).fork()).join();
    }
    if (message.group !== undefined) {
      writer.uint32(26).string(message.group);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.version !== undefined) {
      writer.uint32(42).string(message.version);
    }
    if (message.description !== undefined) {
      writer.uint32(50).string(message.description);
    }
    for (const v of message.endpoints) {
      writer.uint32(58).string(v!);
    }
    if (message.authenticated !== undefined) {
      writer.uint32(64).bool(message.authenticated);
    }
    if (message.xTrustBoundary !== undefined) {
      writer.uint32(72).bool(message.xTrustBoundary);
    }
    for (const v of message.data) {
      DataFlow.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.licenses) {
      LicenseChoice.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.externalReferences) {
      ExternalReference.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.services) {
      Service.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.releaseNotes !== undefined) {
      ReleaseNotes.encode(message.releaseNotes, writer.uint32(122).fork()).join();
    }
    if (message.trustZone !== undefined) {
      writer.uint32(130).string(message.trustZone);
    }
    for (const v of message.tags) {
      writer.uint32(138).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Service {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseService();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.provider = OrganizationalEntity.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.group = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.endpoints.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.authenticated = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.xTrustBoundary = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.data.push(DataFlow.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.licenses.push(LicenseChoice.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.externalReferences.push(ExternalReference.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.services.push(Service.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.releaseNotes = ReleaseNotes.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.trustZone = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Service {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      provider: isSet(object.provider) ? OrganizationalEntity.fromJSON(object.provider) : undefined,
      group: isSet(object.group) ? globalThis.String(object.group) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      endpoints: globalThis.Array.isArray(object?.endpoints)
        ? object.endpoints.map((e: any) => globalThis.String(e))
        : [],
      authenticated: isSet(object.authenticated) ? globalThis.Boolean(object.authenticated) : undefined,
      xTrustBoundary: isSet(object.xTrustBoundary) ? globalThis.Boolean(object.xTrustBoundary) : undefined,
      data: globalThis.Array.isArray(object?.data) ? object.data.map((e: any) => DataFlow.fromJSON(e)) : [],
      licenses: globalThis.Array.isArray(object?.licenses)
        ? object.licenses.map((e: any) => LicenseChoice.fromJSON(e))
        : [],
      externalReferences: globalThis.Array.isArray(object?.externalReferences)
        ? object.externalReferences.map((e: any) => ExternalReference.fromJSON(e))
        : [],
      services: globalThis.Array.isArray(object?.services) ? object.services.map((e: any) => Service.fromJSON(e)) : [],
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
      releaseNotes: isSet(object.releaseNotes) ? ReleaseNotes.fromJSON(object.releaseNotes) : undefined,
      trustZone: isSet(object.trustZone) ? globalThis.String(object.trustZone) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: Service): unknown {
    const obj: any = {};
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.provider !== undefined) {
      obj.provider = OrganizationalEntity.toJSON(message.provider);
    }
    if (message.group !== undefined) {
      obj.group = message.group;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== undefined) {
      obj.version = message.version;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.endpoints?.length) {
      obj.endpoints = message.endpoints;
    }
    if (message.authenticated !== undefined) {
      obj.authenticated = message.authenticated;
    }
    if (message.xTrustBoundary !== undefined) {
      obj.xTrustBoundary = message.xTrustBoundary;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => DataFlow.toJSON(e));
    }
    if (message.licenses?.length) {
      obj.licenses = message.licenses.map((e) => LicenseChoice.toJSON(e));
    }
    if (message.externalReferences?.length) {
      obj.externalReferences = message.externalReferences.map((e) => ExternalReference.toJSON(e));
    }
    if (message.services?.length) {
      obj.services = message.services.map((e) => Service.toJSON(e));
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    if (message.releaseNotes !== undefined) {
      obj.releaseNotes = ReleaseNotes.toJSON(message.releaseNotes);
    }
    if (message.trustZone !== undefined) {
      obj.trustZone = message.trustZone;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Service>, I>>(base?: I): Service {
    return Service.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Service>, I>>(object: I): Service {
    const message = createBaseService();
    message.bomRef = object.bomRef ?? undefined;
    message.provider = (object.provider !== undefined && object.provider !== null)
      ? OrganizationalEntity.fromPartial(object.provider)
      : undefined;
    message.group = object.group ?? undefined;
    message.name = object.name ?? "";
    message.version = object.version ?? undefined;
    message.description = object.description ?? undefined;
    message.endpoints = object.endpoints?.map((e) => e) || [];
    message.authenticated = object.authenticated ?? undefined;
    message.xTrustBoundary = object.xTrustBoundary ?? undefined;
    message.data = object.data?.map((e) => DataFlow.fromPartial(e)) || [];
    message.licenses = object.licenses?.map((e) => LicenseChoice.fromPartial(e)) || [];
    message.externalReferences = object.externalReferences?.map((e) => ExternalReference.fromPartial(e)) || [];
    message.services = object.services?.map((e) => Service.fromPartial(e)) || [];
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    message.releaseNotes = (object.releaseNotes !== undefined && object.releaseNotes !== null)
      ? ReleaseNotes.fromPartial(object.releaseNotes)
      : undefined;
    message.trustZone = object.trustZone ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    return message;
  },
};

function createBaseSwid(): Swid {
  return {
    tagId: "",
    name: "",
    version: undefined,
    tagVersion: undefined,
    patch: undefined,
    text: undefined,
    url: undefined,
  };
}

export const Swid: MessageFns<Swid> = {
  encode(message: Swid, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tagId !== "") {
      writer.uint32(10).string(message.tagId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.version !== undefined) {
      writer.uint32(26).string(message.version);
    }
    if (message.tagVersion !== undefined) {
      writer.uint32(32).int32(message.tagVersion);
    }
    if (message.patch !== undefined) {
      writer.uint32(40).bool(message.patch);
    }
    if (message.text !== undefined) {
      AttachedText.encode(message.text, writer.uint32(50).fork()).join();
    }
    if (message.url !== undefined) {
      writer.uint32(58).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Swid {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSwid();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tagId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.tagVersion = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.patch = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.text = AttachedText.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Swid {
    return {
      tagId: isSet(object.tagId) ? globalThis.String(object.tagId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : undefined,
      tagVersion: isSet(object.tagVersion) ? globalThis.Number(object.tagVersion) : undefined,
      patch: isSet(object.patch) ? globalThis.Boolean(object.patch) : undefined,
      text: isSet(object.text) ? AttachedText.fromJSON(object.text) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : undefined,
    };
  },

  toJSON(message: Swid): unknown {
    const obj: any = {};
    if (message.tagId !== "") {
      obj.tagId = message.tagId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== undefined) {
      obj.version = message.version;
    }
    if (message.tagVersion !== undefined) {
      obj.tagVersion = Math.round(message.tagVersion);
    }
    if (message.patch !== undefined) {
      obj.patch = message.patch;
    }
    if (message.text !== undefined) {
      obj.text = AttachedText.toJSON(message.text);
    }
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Swid>, I>>(base?: I): Swid {
    return Swid.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Swid>, I>>(object: I): Swid {
    const message = createBaseSwid();
    message.tagId = object.tagId ?? "";
    message.name = object.name ?? "";
    message.version = object.version ?? undefined;
    message.tagVersion = object.tagVersion ?? undefined;
    message.patch = object.patch ?? undefined;
    message.text = (object.text !== undefined && object.text !== null)
      ? AttachedText.fromPartial(object.text)
      : undefined;
    message.url = object.url ?? undefined;
    return message;
  },
};

function createBaseTool(): Tool {
  return {
    vendor: undefined,
    name: undefined,
    version: undefined,
    hashes: [],
    externalReferences: [],
    components: [],
    services: [],
  };
}

export const Tool: MessageFns<Tool> = {
  encode(message: Tool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vendor !== undefined) {
      writer.uint32(10).string(message.vendor);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.version !== undefined) {
      writer.uint32(26).string(message.version);
    }
    for (const v of message.hashes) {
      Hash.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.externalReferences) {
      ExternalReference.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.components) {
      Component.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.services) {
      Service.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vendor = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hashes.push(Hash.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.externalReferences.push(ExternalReference.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.components.push(Component.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.services.push(Service.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tool {
    return {
      vendor: isSet(object.vendor) ? globalThis.String(object.vendor) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : undefined,
      hashes: globalThis.Array.isArray(object?.hashes) ? object.hashes.map((e: any) => Hash.fromJSON(e)) : [],
      externalReferences: globalThis.Array.isArray(object?.externalReferences)
        ? object.externalReferences.map((e: any) => ExternalReference.fromJSON(e))
        : [],
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => Component.fromJSON(e))
        : [],
      services: globalThis.Array.isArray(object?.services) ? object.services.map((e: any) => Service.fromJSON(e)) : [],
    };
  },

  toJSON(message: Tool): unknown {
    const obj: any = {};
    if (message.vendor !== undefined) {
      obj.vendor = message.vendor;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.version !== undefined) {
      obj.version = message.version;
    }
    if (message.hashes?.length) {
      obj.hashes = message.hashes.map((e) => Hash.toJSON(e));
    }
    if (message.externalReferences?.length) {
      obj.externalReferences = message.externalReferences.map((e) => ExternalReference.toJSON(e));
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => Component.toJSON(e));
    }
    if (message.services?.length) {
      obj.services = message.services.map((e) => Service.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tool>, I>>(base?: I): Tool {
    return Tool.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tool>, I>>(object: I): Tool {
    const message = createBaseTool();
    message.vendor = object.vendor ?? undefined;
    message.name = object.name ?? undefined;
    message.version = object.version ?? undefined;
    message.hashes = object.hashes?.map((e) => Hash.fromPartial(e)) || [];
    message.externalReferences = object.externalReferences?.map((e) => ExternalReference.fromPartial(e)) || [];
    message.components = object.components?.map((e) => Component.fromPartial(e)) || [];
    message.services = object.services?.map((e) => Service.fromPartial(e)) || [];
    return message;
  },
};

function createBaseProperty(): Property {
  return { name: "", value: undefined };
}

export const Property: MessageFns<Property> = {
  encode(message: Property, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Property {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProperty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Property {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
    };
  },

  toJSON(message: Property): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Property>, I>>(base?: I): Property {
    return Property.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Property>, I>>(object: I): Property {
    const message = createBaseProperty();
    message.name = object.name ?? "";
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseComposition(): Composition {
  return { aggregate: 0, assemblies: [], dependencies: [], vulnerabilities: [], bomRef: undefined };
}

export const Composition: MessageFns<Composition> = {
  encode(message: Composition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aggregate !== 0) {
      writer.uint32(8).int32(message.aggregate);
    }
    for (const v of message.assemblies) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.dependencies) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.vulnerabilities) {
      writer.uint32(34).string(v!);
    }
    if (message.bomRef !== undefined) {
      writer.uint32(42).string(message.bomRef);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Composition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComposition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.aggregate = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assemblies.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dependencies.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.vulnerabilities.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Composition {
    return {
      aggregate: isSet(object.aggregate) ? aggregateFromJSON(object.aggregate) : 0,
      assemblies: globalThis.Array.isArray(object?.assemblies)
        ? object.assemblies.map((e: any) => globalThis.String(e))
        : [],
      dependencies: globalThis.Array.isArray(object?.dependencies)
        ? object.dependencies.map((e: any) => globalThis.String(e))
        : [],
      vulnerabilities: globalThis.Array.isArray(object?.vulnerabilities)
        ? object.vulnerabilities.map((e: any) => globalThis.String(e))
        : [],
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
    };
  },

  toJSON(message: Composition): unknown {
    const obj: any = {};
    if (message.aggregate !== 0) {
      obj.aggregate = aggregateToJSON(message.aggregate);
    }
    if (message.assemblies?.length) {
      obj.assemblies = message.assemblies;
    }
    if (message.dependencies?.length) {
      obj.dependencies = message.dependencies;
    }
    if (message.vulnerabilities?.length) {
      obj.vulnerabilities = message.vulnerabilities;
    }
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Composition>, I>>(base?: I): Composition {
    return Composition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Composition>, I>>(object: I): Composition {
    const message = createBaseComposition();
    message.aggregate = object.aggregate ?? 0;
    message.assemblies = object.assemblies?.map((e) => e) || [];
    message.dependencies = object.dependencies?.map((e) => e) || [];
    message.vulnerabilities = object.vulnerabilities?.map((e) => e) || [];
    message.bomRef = object.bomRef ?? undefined;
    return message;
  },
};

function createBaseEvidenceCopyright(): EvidenceCopyright {
  return { text: "" };
}

export const EvidenceCopyright: MessageFns<EvidenceCopyright> = {
  encode(message: EvidenceCopyright, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvidenceCopyright {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvidenceCopyright();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvidenceCopyright {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: EvidenceCopyright): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvidenceCopyright>, I>>(base?: I): EvidenceCopyright {
    return EvidenceCopyright.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvidenceCopyright>, I>>(object: I): EvidenceCopyright {
    const message = createBaseEvidenceCopyright();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseEvidence(): Evidence {
  return { licenses: [], copyright: [], identity: [], occurrences: [], callstack: undefined };
}

export const Evidence: MessageFns<Evidence> = {
  encode(message: Evidence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.licenses) {
      LicenseChoice.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.copyright) {
      EvidenceCopyright.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.identity) {
      EvidenceIdentity.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.occurrences) {
      EvidenceOccurrences.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.callstack !== undefined) {
      Callstack.encode(message.callstack, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Evidence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvidence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.licenses.push(LicenseChoice.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.copyright.push(EvidenceCopyright.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identity.push(EvidenceIdentity.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.occurrences.push(EvidenceOccurrences.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.callstack = Callstack.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Evidence {
    return {
      licenses: globalThis.Array.isArray(object?.licenses)
        ? object.licenses.map((e: any) => LicenseChoice.fromJSON(e))
        : [],
      copyright: globalThis.Array.isArray(object?.copyright)
        ? object.copyright.map((e: any) => EvidenceCopyright.fromJSON(e))
        : [],
      identity: globalThis.Array.isArray(object?.identity)
        ? object.identity.map((e: any) => EvidenceIdentity.fromJSON(e))
        : [],
      occurrences: globalThis.Array.isArray(object?.occurrences)
        ? object.occurrences.map((e: any) => EvidenceOccurrences.fromJSON(e))
        : [],
      callstack: isSet(object.callstack) ? Callstack.fromJSON(object.callstack) : undefined,
    };
  },

  toJSON(message: Evidence): unknown {
    const obj: any = {};
    if (message.licenses?.length) {
      obj.licenses = message.licenses.map((e) => LicenseChoice.toJSON(e));
    }
    if (message.copyright?.length) {
      obj.copyright = message.copyright.map((e) => EvidenceCopyright.toJSON(e));
    }
    if (message.identity?.length) {
      obj.identity = message.identity.map((e) => EvidenceIdentity.toJSON(e));
    }
    if (message.occurrences?.length) {
      obj.occurrences = message.occurrences.map((e) => EvidenceOccurrences.toJSON(e));
    }
    if (message.callstack !== undefined) {
      obj.callstack = Callstack.toJSON(message.callstack);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Evidence>, I>>(base?: I): Evidence {
    return Evidence.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Evidence>, I>>(object: I): Evidence {
    const message = createBaseEvidence();
    message.licenses = object.licenses?.map((e) => LicenseChoice.fromPartial(e)) || [];
    message.copyright = object.copyright?.map((e) => EvidenceCopyright.fromPartial(e)) || [];
    message.identity = object.identity?.map((e) => EvidenceIdentity.fromPartial(e)) || [];
    message.occurrences = object.occurrences?.map((e) => EvidenceOccurrences.fromPartial(e)) || [];
    message.callstack = (object.callstack !== undefined && object.callstack !== null)
      ? Callstack.fromPartial(object.callstack)
      : undefined;
    return message;
  },
};

function createBaseCallstack(): Callstack {
  return { frames: [] };
}

export const Callstack: MessageFns<Callstack> = {
  encode(message: Callstack, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.frames) {
      Callstack_Frames.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Callstack {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallstack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.frames.push(Callstack_Frames.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Callstack {
    return {
      frames: globalThis.Array.isArray(object?.frames)
        ? object.frames.map((e: any) => Callstack_Frames.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Callstack): unknown {
    const obj: any = {};
    if (message.frames?.length) {
      obj.frames = message.frames.map((e) => Callstack_Frames.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Callstack>, I>>(base?: I): Callstack {
    return Callstack.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Callstack>, I>>(object: I): Callstack {
    const message = createBaseCallstack();
    message.frames = object.frames?.map((e) => Callstack_Frames.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCallstack_Frames(): Callstack_Frames {
  return {
    package: undefined,
    module: "",
    function: undefined,
    parameters: [],
    line: undefined,
    column: undefined,
    fullFilename: undefined,
  };
}

export const Callstack_Frames: MessageFns<Callstack_Frames> = {
  encode(message: Callstack_Frames, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.package !== undefined) {
      writer.uint32(10).string(message.package);
    }
    if (message.module !== "") {
      writer.uint32(18).string(message.module);
    }
    if (message.function !== undefined) {
      writer.uint32(26).string(message.function);
    }
    for (const v of message.parameters) {
      writer.uint32(34).string(v!);
    }
    if (message.line !== undefined) {
      writer.uint32(40).int32(message.line);
    }
    if (message.column !== undefined) {
      writer.uint32(48).int32(message.column);
    }
    if (message.fullFilename !== undefined) {
      writer.uint32(58).string(message.fullFilename);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Callstack_Frames {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallstack_Frames();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.package = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.module = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.function = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parameters.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.line = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.column = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.fullFilename = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Callstack_Frames {
    return {
      package: isSet(object.package) ? globalThis.String(object.package) : undefined,
      module: isSet(object.module) ? globalThis.String(object.module) : "",
      function: isSet(object.function) ? globalThis.String(object.function) : undefined,
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => globalThis.String(e))
        : [],
      line: isSet(object.line) ? globalThis.Number(object.line) : undefined,
      column: isSet(object.column) ? globalThis.Number(object.column) : undefined,
      fullFilename: isSet(object.fullFilename) ? globalThis.String(object.fullFilename) : undefined,
    };
  },

  toJSON(message: Callstack_Frames): unknown {
    const obj: any = {};
    if (message.package !== undefined) {
      obj.package = message.package;
    }
    if (message.module !== "") {
      obj.module = message.module;
    }
    if (message.function !== undefined) {
      obj.function = message.function;
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters;
    }
    if (message.line !== undefined) {
      obj.line = Math.round(message.line);
    }
    if (message.column !== undefined) {
      obj.column = Math.round(message.column);
    }
    if (message.fullFilename !== undefined) {
      obj.fullFilename = message.fullFilename;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Callstack_Frames>, I>>(base?: I): Callstack_Frames {
    return Callstack_Frames.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Callstack_Frames>, I>>(object: I): Callstack_Frames {
    const message = createBaseCallstack_Frames();
    message.package = object.package ?? undefined;
    message.module = object.module ?? "";
    message.function = object.function ?? undefined;
    message.parameters = object.parameters?.map((e) => e) || [];
    message.line = object.line ?? undefined;
    message.column = object.column ?? undefined;
    message.fullFilename = object.fullFilename ?? undefined;
    return message;
  },
};

function createBaseEvidenceIdentity(): EvidenceIdentity {
  return { field: 0, confidence: undefined, methods: [], tools: [], concludedValue: undefined };
}

export const EvidenceIdentity: MessageFns<EvidenceIdentity> = {
  encode(message: EvidenceIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.field !== 0) {
      writer.uint32(8).int32(message.field);
    }
    if (message.confidence !== undefined) {
      writer.uint32(21).float(message.confidence);
    }
    for (const v of message.methods) {
      EvidenceMethods.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.tools) {
      writer.uint32(34).string(v!);
    }
    if (message.concludedValue !== undefined) {
      writer.uint32(42).string(message.concludedValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvidenceIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvidenceIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.field = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.methods.push(EvidenceMethods.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tools.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.concludedValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvidenceIdentity {
    return {
      field: isSet(object.field) ? evidenceFieldTypeFromJSON(object.field) : 0,
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : undefined,
      methods: globalThis.Array.isArray(object?.methods)
        ? object.methods.map((e: any) => EvidenceMethods.fromJSON(e))
        : [],
      tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => globalThis.String(e)) : [],
      concludedValue: isSet(object.concludedValue) ? globalThis.String(object.concludedValue) : undefined,
    };
  },

  toJSON(message: EvidenceIdentity): unknown {
    const obj: any = {};
    if (message.field !== 0) {
      obj.field = evidenceFieldTypeToJSON(message.field);
    }
    if (message.confidence !== undefined) {
      obj.confidence = message.confidence;
    }
    if (message.methods?.length) {
      obj.methods = message.methods.map((e) => EvidenceMethods.toJSON(e));
    }
    if (message.tools?.length) {
      obj.tools = message.tools;
    }
    if (message.concludedValue !== undefined) {
      obj.concludedValue = message.concludedValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvidenceIdentity>, I>>(base?: I): EvidenceIdentity {
    return EvidenceIdentity.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvidenceIdentity>, I>>(object: I): EvidenceIdentity {
    const message = createBaseEvidenceIdentity();
    message.field = object.field ?? 0;
    message.confidence = object.confidence ?? undefined;
    message.methods = object.methods?.map((e) => EvidenceMethods.fromPartial(e)) || [];
    message.tools = object.tools?.map((e) => e) || [];
    message.concludedValue = object.concludedValue ?? undefined;
    return message;
  },
};

function createBaseEvidenceMethods(): EvidenceMethods {
  return { technique: 0, confidence: 0, value: undefined };
}

export const EvidenceMethods: MessageFns<EvidenceMethods> = {
  encode(message: EvidenceMethods, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.technique !== 0) {
      writer.uint32(8).int32(message.technique);
    }
    if (message.confidence !== 0) {
      writer.uint32(21).float(message.confidence);
    }
    if (message.value !== undefined) {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvidenceMethods {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvidenceMethods();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.technique = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.confidence = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvidenceMethods {
    return {
      technique: isSet(object.technique) ? evidenceTechniqueFromJSON(object.technique) : 0,
      confidence: isSet(object.confidence) ? globalThis.Number(object.confidence) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
    };
  },

  toJSON(message: EvidenceMethods): unknown {
    const obj: any = {};
    if (message.technique !== 0) {
      obj.technique = evidenceTechniqueToJSON(message.technique);
    }
    if (message.confidence !== 0) {
      obj.confidence = message.confidence;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvidenceMethods>, I>>(base?: I): EvidenceMethods {
    return EvidenceMethods.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvidenceMethods>, I>>(object: I): EvidenceMethods {
    const message = createBaseEvidenceMethods();
    message.technique = object.technique ?? 0;
    message.confidence = object.confidence ?? 0;
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseEvidenceOccurrences(): EvidenceOccurrences {
  return {
    bomRef: undefined,
    location: "",
    line: undefined,
    offset: undefined,
    symbol: undefined,
    additionalContext: undefined,
  };
}

export const EvidenceOccurrences: MessageFns<EvidenceOccurrences> = {
  encode(message: EvidenceOccurrences, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== undefined) {
      writer.uint32(10).string(message.bomRef);
    }
    if (message.location !== "") {
      writer.uint32(18).string(message.location);
    }
    if (message.line !== undefined) {
      writer.uint32(24).int32(message.line);
    }
    if (message.offset !== undefined) {
      writer.uint32(32).int32(message.offset);
    }
    if (message.symbol !== undefined) {
      writer.uint32(42).string(message.symbol);
    }
    if (message.additionalContext !== undefined) {
      writer.uint32(50).string(message.additionalContext);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvidenceOccurrences {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvidenceOccurrences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.location = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.line = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.additionalContext = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvidenceOccurrences {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      location: isSet(object.location) ? globalThis.String(object.location) : "",
      line: isSet(object.line) ? globalThis.Number(object.line) : undefined,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : undefined,
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : undefined,
      additionalContext: isSet(object.additionalContext) ? globalThis.String(object.additionalContext) : undefined,
    };
  },

  toJSON(message: EvidenceOccurrences): unknown {
    const obj: any = {};
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.location !== "") {
      obj.location = message.location;
    }
    if (message.line !== undefined) {
      obj.line = Math.round(message.line);
    }
    if (message.offset !== undefined) {
      obj.offset = Math.round(message.offset);
    }
    if (message.symbol !== undefined) {
      obj.symbol = message.symbol;
    }
    if (message.additionalContext !== undefined) {
      obj.additionalContext = message.additionalContext;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvidenceOccurrences>, I>>(base?: I): EvidenceOccurrences {
    return EvidenceOccurrences.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvidenceOccurrences>, I>>(object: I): EvidenceOccurrences {
    const message = createBaseEvidenceOccurrences();
    message.bomRef = object.bomRef ?? undefined;
    message.location = object.location ?? "";
    message.line = object.line ?? undefined;
    message.offset = object.offset ?? undefined;
    message.symbol = object.symbol ?? undefined;
    message.additionalContext = object.additionalContext ?? undefined;
    return message;
  },
};

function createBaseNote(): Note {
  return { locale: undefined, text: undefined };
}

export const Note: MessageFns<Note> = {
  encode(message: Note, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.locale !== undefined) {
      writer.uint32(10).string(message.locale);
    }
    if (message.text !== undefined) {
      AttachedText.encode(message.text, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Note {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.locale = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = AttachedText.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Note {
    return {
      locale: isSet(object.locale) ? globalThis.String(object.locale) : undefined,
      text: isSet(object.text) ? AttachedText.fromJSON(object.text) : undefined,
    };
  },

  toJSON(message: Note): unknown {
    const obj: any = {};
    if (message.locale !== undefined) {
      obj.locale = message.locale;
    }
    if (message.text !== undefined) {
      obj.text = AttachedText.toJSON(message.text);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Note>, I>>(base?: I): Note {
    return Note.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Note>, I>>(object: I): Note {
    const message = createBaseNote();
    message.locale = object.locale ?? undefined;
    message.text = (object.text !== undefined && object.text !== null)
      ? AttachedText.fromPartial(object.text)
      : undefined;
    return message;
  },
};

function createBaseReleaseNotes(): ReleaseNotes {
  return {
    type: "",
    title: undefined,
    featuredImage: undefined,
    socialImage: undefined,
    description: undefined,
    timestamp: undefined,
    aliases: [],
    tags: [],
    resolves: [],
    notes: [],
    properties: [],
  };
}

export const ReleaseNotes: MessageFns<ReleaseNotes> = {
  encode(message: ReleaseNotes, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.title !== undefined) {
      writer.uint32(18).string(message.title);
    }
    if (message.featuredImage !== undefined) {
      writer.uint32(26).string(message.featuredImage);
    }
    if (message.socialImage !== undefined) {
      writer.uint32(34).string(message.socialImage);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(50).fork()).join();
    }
    for (const v of message.aliases) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.resolves) {
      Issue.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.notes) {
      Note.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReleaseNotes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReleaseNotes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.featuredImage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.socialImage = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.aliases.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.resolves.push(Issue.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.notes.push(Note.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReleaseNotes {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : undefined,
      featuredImage: isSet(object.featuredImage) ? globalThis.String(object.featuredImage) : undefined,
      socialImage: isSet(object.socialImage) ? globalThis.String(object.socialImage) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      aliases: globalThis.Array.isArray(object?.aliases) ? object.aliases.map((e: any) => globalThis.String(e)) : [],
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      resolves: globalThis.Array.isArray(object?.resolves) ? object.resolves.map((e: any) => Issue.fromJSON(e)) : [],
      notes: globalThis.Array.isArray(object?.notes) ? object.notes.map((e: any) => Note.fromJSON(e)) : [],
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReleaseNotes): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.title !== undefined) {
      obj.title = message.title;
    }
    if (message.featuredImage !== undefined) {
      obj.featuredImage = message.featuredImage;
    }
    if (message.socialImage !== undefined) {
      obj.socialImage = message.socialImage;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.aliases?.length) {
      obj.aliases = message.aliases;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.resolves?.length) {
      obj.resolves = message.resolves.map((e) => Issue.toJSON(e));
    }
    if (message.notes?.length) {
      obj.notes = message.notes.map((e) => Note.toJSON(e));
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReleaseNotes>, I>>(base?: I): ReleaseNotes {
    return ReleaseNotes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReleaseNotes>, I>>(object: I): ReleaseNotes {
    const message = createBaseReleaseNotes();
    message.type = object.type ?? "";
    message.title = object.title ?? undefined;
    message.featuredImage = object.featuredImage ?? undefined;
    message.socialImage = object.socialImage ?? undefined;
    message.description = object.description ?? undefined;
    message.timestamp = object.timestamp ?? undefined;
    message.aliases = object.aliases?.map((e) => e) || [];
    message.tags = object.tags?.map((e) => e) || [];
    message.resolves = object.resolves?.map((e) => Issue.fromPartial(e)) || [];
    message.notes = object.notes?.map((e) => Note.fromPartial(e)) || [];
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVulnerability(): Vulnerability {
  return {
    bomRef: undefined,
    id: undefined,
    source: undefined,
    references: [],
    ratings: [],
    cwes: [],
    description: undefined,
    detail: undefined,
    recommendation: undefined,
    advisories: [],
    created: undefined,
    published: undefined,
    updated: undefined,
    credits: undefined,
    tools: undefined,
    analysis: undefined,
    affects: [],
    properties: [],
    rejected: undefined,
    proofOfConcept: undefined,
    workaround: undefined,
  };
}

export const Vulnerability: MessageFns<Vulnerability> = {
  encode(message: Vulnerability, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== undefined) {
      writer.uint32(10).string(message.bomRef);
    }
    if (message.id !== undefined) {
      writer.uint32(18).string(message.id);
    }
    if (message.source !== undefined) {
      Source.encode(message.source, writer.uint32(26).fork()).join();
    }
    for (const v of message.references) {
      VulnerabilityReference.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.ratings) {
      VulnerabilityRating.encode(v!, writer.uint32(42).fork()).join();
    }
    writer.uint32(50).fork();
    for (const v of message.cwes) {
      writer.int32(v);
    }
    writer.join();
    if (message.description !== undefined) {
      writer.uint32(58).string(message.description);
    }
    if (message.detail !== undefined) {
      writer.uint32(66).string(message.detail);
    }
    if (message.recommendation !== undefined) {
      writer.uint32(74).string(message.recommendation);
    }
    for (const v of message.advisories) {
      Advisory.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.created !== undefined) {
      Timestamp.encode(toTimestamp(message.created), writer.uint32(90).fork()).join();
    }
    if (message.published !== undefined) {
      Timestamp.encode(toTimestamp(message.published), writer.uint32(98).fork()).join();
    }
    if (message.updated !== undefined) {
      Timestamp.encode(toTimestamp(message.updated), writer.uint32(106).fork()).join();
    }
    if (message.credits !== undefined) {
      VulnerabilityCredits.encode(message.credits, writer.uint32(114).fork()).join();
    }
    if (message.tools !== undefined) {
      Tool.encode(message.tools, writer.uint32(122).fork()).join();
    }
    if (message.analysis !== undefined) {
      VulnerabilityAnalysis.encode(message.analysis, writer.uint32(130).fork()).join();
    }
    for (const v of message.affects) {
      VulnerabilityAffects.encode(v!, writer.uint32(138).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(146).fork()).join();
    }
    if (message.rejected !== undefined) {
      Timestamp.encode(toTimestamp(message.rejected), writer.uint32(154).fork()).join();
    }
    if (message.proofOfConcept !== undefined) {
      ProofOfConcept.encode(message.proofOfConcept, writer.uint32(162).fork()).join();
    }
    if (message.workaround !== undefined) {
      writer.uint32(170).string(message.workaround);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Vulnerability {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerability();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.source = Source.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.references.push(VulnerabilityReference.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ratings.push(VulnerabilityRating.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag === 48) {
            message.cwes.push(reader.int32());

            continue;
          }

          if (tag === 50) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.cwes.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.detail = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.recommendation = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.advisories.push(Advisory.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.created = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.published = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.updated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.credits = VulnerabilityCredits.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.tools = Tool.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.analysis = VulnerabilityAnalysis.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.affects.push(VulnerabilityAffects.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.rejected = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.proofOfConcept = ProofOfConcept.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.workaround = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vulnerability {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      source: isSet(object.source) ? Source.fromJSON(object.source) : undefined,
      references: globalThis.Array.isArray(object?.references)
        ? object.references.map((e: any) => VulnerabilityReference.fromJSON(e))
        : [],
      ratings: globalThis.Array.isArray(object?.ratings)
        ? object.ratings.map((e: any) => VulnerabilityRating.fromJSON(e))
        : [],
      cwes: globalThis.Array.isArray(object?.cwes) ? object.cwes.map((e: any) => globalThis.Number(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      detail: isSet(object.detail) ? globalThis.String(object.detail) : undefined,
      recommendation: isSet(object.recommendation) ? globalThis.String(object.recommendation) : undefined,
      advisories: globalThis.Array.isArray(object?.advisories)
        ? object.advisories.map((e: any) => Advisory.fromJSON(e))
        : [],
      created: isSet(object.created) ? fromJsonTimestamp(object.created) : undefined,
      published: isSet(object.published) ? fromJsonTimestamp(object.published) : undefined,
      updated: isSet(object.updated) ? fromJsonTimestamp(object.updated) : undefined,
      credits: isSet(object.credits) ? VulnerabilityCredits.fromJSON(object.credits) : undefined,
      tools: isSet(object.tools) ? Tool.fromJSON(object.tools) : undefined,
      analysis: isSet(object.analysis) ? VulnerabilityAnalysis.fromJSON(object.analysis) : undefined,
      affects: globalThis.Array.isArray(object?.affects)
        ? object.affects.map((e: any) => VulnerabilityAffects.fromJSON(e))
        : [],
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
      rejected: isSet(object.rejected) ? fromJsonTimestamp(object.rejected) : undefined,
      proofOfConcept: isSet(object.proofOfConcept) ? ProofOfConcept.fromJSON(object.proofOfConcept) : undefined,
      workaround: isSet(object.workaround) ? globalThis.String(object.workaround) : undefined,
    };
  },

  toJSON(message: Vulnerability): unknown {
    const obj: any = {};
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.source !== undefined) {
      obj.source = Source.toJSON(message.source);
    }
    if (message.references?.length) {
      obj.references = message.references.map((e) => VulnerabilityReference.toJSON(e));
    }
    if (message.ratings?.length) {
      obj.ratings = message.ratings.map((e) => VulnerabilityRating.toJSON(e));
    }
    if (message.cwes?.length) {
      obj.cwes = message.cwes.map((e) => Math.round(e));
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.detail !== undefined) {
      obj.detail = message.detail;
    }
    if (message.recommendation !== undefined) {
      obj.recommendation = message.recommendation;
    }
    if (message.advisories?.length) {
      obj.advisories = message.advisories.map((e) => Advisory.toJSON(e));
    }
    if (message.created !== undefined) {
      obj.created = message.created.toISOString();
    }
    if (message.published !== undefined) {
      obj.published = message.published.toISOString();
    }
    if (message.updated !== undefined) {
      obj.updated = message.updated.toISOString();
    }
    if (message.credits !== undefined) {
      obj.credits = VulnerabilityCredits.toJSON(message.credits);
    }
    if (message.tools !== undefined) {
      obj.tools = Tool.toJSON(message.tools);
    }
    if (message.analysis !== undefined) {
      obj.analysis = VulnerabilityAnalysis.toJSON(message.analysis);
    }
    if (message.affects?.length) {
      obj.affects = message.affects.map((e) => VulnerabilityAffects.toJSON(e));
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    if (message.rejected !== undefined) {
      obj.rejected = message.rejected.toISOString();
    }
    if (message.proofOfConcept !== undefined) {
      obj.proofOfConcept = ProofOfConcept.toJSON(message.proofOfConcept);
    }
    if (message.workaround !== undefined) {
      obj.workaround = message.workaround;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vulnerability>, I>>(base?: I): Vulnerability {
    return Vulnerability.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vulnerability>, I>>(object: I): Vulnerability {
    const message = createBaseVulnerability();
    message.bomRef = object.bomRef ?? undefined;
    message.id = object.id ?? undefined;
    message.source = (object.source !== undefined && object.source !== null)
      ? Source.fromPartial(object.source)
      : undefined;
    message.references = object.references?.map((e) => VulnerabilityReference.fromPartial(e)) || [];
    message.ratings = object.ratings?.map((e) => VulnerabilityRating.fromPartial(e)) || [];
    message.cwes = object.cwes?.map((e) => e) || [];
    message.description = object.description ?? undefined;
    message.detail = object.detail ?? undefined;
    message.recommendation = object.recommendation ?? undefined;
    message.advisories = object.advisories?.map((e) => Advisory.fromPartial(e)) || [];
    message.created = object.created ?? undefined;
    message.published = object.published ?? undefined;
    message.updated = object.updated ?? undefined;
    message.credits = (object.credits !== undefined && object.credits !== null)
      ? VulnerabilityCredits.fromPartial(object.credits)
      : undefined;
    message.tools = (object.tools !== undefined && object.tools !== null) ? Tool.fromPartial(object.tools) : undefined;
    message.analysis = (object.analysis !== undefined && object.analysis !== null)
      ? VulnerabilityAnalysis.fromPartial(object.analysis)
      : undefined;
    message.affects = object.affects?.map((e) => VulnerabilityAffects.fromPartial(e)) || [];
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    message.rejected = object.rejected ?? undefined;
    message.proofOfConcept = (object.proofOfConcept !== undefined && object.proofOfConcept !== null)
      ? ProofOfConcept.fromPartial(object.proofOfConcept)
      : undefined;
    message.workaround = object.workaround ?? undefined;
    return message;
  },
};

function createBaseProofOfConcept(): ProofOfConcept {
  return { reproductionSteps: undefined, environment: undefined, supportingMaterial: [] };
}

export const ProofOfConcept: MessageFns<ProofOfConcept> = {
  encode(message: ProofOfConcept, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reproductionSteps !== undefined) {
      writer.uint32(10).string(message.reproductionSteps);
    }
    if (message.environment !== undefined) {
      writer.uint32(18).string(message.environment);
    }
    for (const v of message.supportingMaterial) {
      AttachedText.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProofOfConcept {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProofOfConcept();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reproductionSteps = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.environment = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.supportingMaterial.push(AttachedText.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProofOfConcept {
    return {
      reproductionSteps: isSet(object.reproductionSteps) ? globalThis.String(object.reproductionSteps) : undefined,
      environment: isSet(object.environment) ? globalThis.String(object.environment) : undefined,
      supportingMaterial: globalThis.Array.isArray(object?.supportingMaterial)
        ? object.supportingMaterial.map((e: any) => AttachedText.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ProofOfConcept): unknown {
    const obj: any = {};
    if (message.reproductionSteps !== undefined) {
      obj.reproductionSteps = message.reproductionSteps;
    }
    if (message.environment !== undefined) {
      obj.environment = message.environment;
    }
    if (message.supportingMaterial?.length) {
      obj.supportingMaterial = message.supportingMaterial.map((e) => AttachedText.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProofOfConcept>, I>>(base?: I): ProofOfConcept {
    return ProofOfConcept.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProofOfConcept>, I>>(object: I): ProofOfConcept {
    const message = createBaseProofOfConcept();
    message.reproductionSteps = object.reproductionSteps ?? undefined;
    message.environment = object.environment ?? undefined;
    message.supportingMaterial = object.supportingMaterial?.map((e) => AttachedText.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVulnerabilityReference(): VulnerabilityReference {
  return { id: "", source: undefined };
}

export const VulnerabilityReference: MessageFns<VulnerabilityReference> = {
  encode(message: VulnerabilityReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.source !== undefined) {
      Source.encode(message.source, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = Source.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityReference {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      source: isSet(object.source) ? Source.fromJSON(object.source) : undefined,
    };
  },

  toJSON(message: VulnerabilityReference): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.source !== undefined) {
      obj.source = Source.toJSON(message.source);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VulnerabilityReference>, I>>(base?: I): VulnerabilityReference {
    return VulnerabilityReference.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VulnerabilityReference>, I>>(object: I): VulnerabilityReference {
    const message = createBaseVulnerabilityReference();
    message.id = object.id ?? "";
    message.source = (object.source !== undefined && object.source !== null)
      ? Source.fromPartial(object.source)
      : undefined;
    return message;
  },
};

function createBaseVulnerabilityRating(): VulnerabilityRating {
  return {
    source: undefined,
    score: undefined,
    severity: undefined,
    method: undefined,
    vector: undefined,
    justification: undefined,
  };
}

export const VulnerabilityRating: MessageFns<VulnerabilityRating> = {
  encode(message: VulnerabilityRating, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      Source.encode(message.source, writer.uint32(10).fork()).join();
    }
    if (message.score !== undefined) {
      writer.uint32(17).double(message.score);
    }
    if (message.severity !== undefined) {
      writer.uint32(24).int32(message.severity);
    }
    if (message.method !== undefined) {
      writer.uint32(32).int32(message.method);
    }
    if (message.vector !== undefined) {
      writer.uint32(42).string(message.vector);
    }
    if (message.justification !== undefined) {
      writer.uint32(50).string(message.justification);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityRating {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityRating();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = Source.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.score = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.severity = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.method = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.vector = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.justification = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityRating {
    return {
      source: isSet(object.source) ? Source.fromJSON(object.source) : undefined,
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      severity: isSet(object.severity) ? severityFromJSON(object.severity) : undefined,
      method: isSet(object.method) ? scoreMethodFromJSON(object.method) : undefined,
      vector: isSet(object.vector) ? globalThis.String(object.vector) : undefined,
      justification: isSet(object.justification) ? globalThis.String(object.justification) : undefined,
    };
  },

  toJSON(message: VulnerabilityRating): unknown {
    const obj: any = {};
    if (message.source !== undefined) {
      obj.source = Source.toJSON(message.source);
    }
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.severity !== undefined) {
      obj.severity = severityToJSON(message.severity);
    }
    if (message.method !== undefined) {
      obj.method = scoreMethodToJSON(message.method);
    }
    if (message.vector !== undefined) {
      obj.vector = message.vector;
    }
    if (message.justification !== undefined) {
      obj.justification = message.justification;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VulnerabilityRating>, I>>(base?: I): VulnerabilityRating {
    return VulnerabilityRating.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VulnerabilityRating>, I>>(object: I): VulnerabilityRating {
    const message = createBaseVulnerabilityRating();
    message.source = (object.source !== undefined && object.source !== null)
      ? Source.fromPartial(object.source)
      : undefined;
    message.score = object.score ?? undefined;
    message.severity = object.severity ?? undefined;
    message.method = object.method ?? undefined;
    message.vector = object.vector ?? undefined;
    message.justification = object.justification ?? undefined;
    return message;
  },
};

function createBaseAdvisory(): Advisory {
  return { title: undefined, url: "" };
}

export const Advisory: MessageFns<Advisory> = {
  encode(message: Advisory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== undefined) {
      writer.uint32(10).string(message.title);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Advisory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdvisory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Advisory {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
    };
  },

  toJSON(message: Advisory): unknown {
    const obj: any = {};
    if (message.title !== undefined) {
      obj.title = message.title;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Advisory>, I>>(base?: I): Advisory {
    return Advisory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Advisory>, I>>(object: I): Advisory {
    const message = createBaseAdvisory();
    message.title = object.title ?? undefined;
    message.url = object.url ?? "";
    return message;
  },
};

function createBaseVulnerabilityCredits(): VulnerabilityCredits {
  return { organizations: [], individuals: [] };
}

export const VulnerabilityCredits: MessageFns<VulnerabilityCredits> = {
  encode(message: VulnerabilityCredits, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.organizations) {
      OrganizationalEntity.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.individuals) {
      OrganizationalContact.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityCredits {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityCredits();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organizations.push(OrganizationalEntity.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.individuals.push(OrganizationalContact.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityCredits {
    return {
      organizations: globalThis.Array.isArray(object?.organizations)
        ? object.organizations.map((e: any) => OrganizationalEntity.fromJSON(e))
        : [],
      individuals: globalThis.Array.isArray(object?.individuals)
        ? object.individuals.map((e: any) => OrganizationalContact.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VulnerabilityCredits): unknown {
    const obj: any = {};
    if (message.organizations?.length) {
      obj.organizations = message.organizations.map((e) => OrganizationalEntity.toJSON(e));
    }
    if (message.individuals?.length) {
      obj.individuals = message.individuals.map((e) => OrganizationalContact.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VulnerabilityCredits>, I>>(base?: I): VulnerabilityCredits {
    return VulnerabilityCredits.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VulnerabilityCredits>, I>>(object: I): VulnerabilityCredits {
    const message = createBaseVulnerabilityCredits();
    message.organizations = object.organizations?.map((e) => OrganizationalEntity.fromPartial(e)) || [];
    message.individuals = object.individuals?.map((e) => OrganizationalContact.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVulnerabilityAnalysis(): VulnerabilityAnalysis {
  return {
    state: undefined,
    justification: undefined,
    response: [],
    detail: undefined,
    firstIssued: undefined,
    lastUpdated: undefined,
  };
}

export const VulnerabilityAnalysis: MessageFns<VulnerabilityAnalysis> = {
  encode(message: VulnerabilityAnalysis, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== undefined) {
      writer.uint32(8).int32(message.state);
    }
    if (message.justification !== undefined) {
      writer.uint32(16).int32(message.justification);
    }
    writer.uint32(26).fork();
    for (const v of message.response) {
      writer.int32(v);
    }
    writer.join();
    if (message.detail !== undefined) {
      writer.uint32(34).string(message.detail);
    }
    if (message.firstIssued !== undefined) {
      Timestamp.encode(toTimestamp(message.firstIssued), writer.uint32(42).fork()).join();
    }
    if (message.lastUpdated !== undefined) {
      Timestamp.encode(toTimestamp(message.lastUpdated), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityAnalysis {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityAnalysis();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.justification = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.response.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.response.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.detail = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.firstIssued = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.lastUpdated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityAnalysis {
    return {
      state: isSet(object.state) ? impactAnalysisStateFromJSON(object.state) : undefined,
      justification: isSet(object.justification)
        ? impactAnalysisJustificationFromJSON(object.justification)
        : undefined,
      response: globalThis.Array.isArray(object?.response)
        ? object.response.map((e: any) => vulnerabilityResponseFromJSON(e))
        : [],
      detail: isSet(object.detail) ? globalThis.String(object.detail) : undefined,
      firstIssued: isSet(object.firstIssued) ? fromJsonTimestamp(object.firstIssued) : undefined,
      lastUpdated: isSet(object.lastUpdated) ? fromJsonTimestamp(object.lastUpdated) : undefined,
    };
  },

  toJSON(message: VulnerabilityAnalysis): unknown {
    const obj: any = {};
    if (message.state !== undefined) {
      obj.state = impactAnalysisStateToJSON(message.state);
    }
    if (message.justification !== undefined) {
      obj.justification = impactAnalysisJustificationToJSON(message.justification);
    }
    if (message.response?.length) {
      obj.response = message.response.map((e) => vulnerabilityResponseToJSON(e));
    }
    if (message.detail !== undefined) {
      obj.detail = message.detail;
    }
    if (message.firstIssued !== undefined) {
      obj.firstIssued = message.firstIssued.toISOString();
    }
    if (message.lastUpdated !== undefined) {
      obj.lastUpdated = message.lastUpdated.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VulnerabilityAnalysis>, I>>(base?: I): VulnerabilityAnalysis {
    return VulnerabilityAnalysis.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VulnerabilityAnalysis>, I>>(object: I): VulnerabilityAnalysis {
    const message = createBaseVulnerabilityAnalysis();
    message.state = object.state ?? undefined;
    message.justification = object.justification ?? undefined;
    message.response = object.response?.map((e) => e) || [];
    message.detail = object.detail ?? undefined;
    message.firstIssued = object.firstIssued ?? undefined;
    message.lastUpdated = object.lastUpdated ?? undefined;
    return message;
  },
};

function createBaseVulnerabilityAffects(): VulnerabilityAffects {
  return { ref: "", versions: [] };
}

export const VulnerabilityAffects: MessageFns<VulnerabilityAffects> = {
  encode(message: VulnerabilityAffects, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ref !== "") {
      writer.uint32(10).string(message.ref);
    }
    for (const v of message.versions) {
      VulnerabilityAffectedVersions.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityAffects {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityAffects();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ref = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.versions.push(VulnerabilityAffectedVersions.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityAffects {
    return {
      ref: isSet(object.ref) ? globalThis.String(object.ref) : "",
      versions: globalThis.Array.isArray(object?.versions)
        ? object.versions.map((e: any) => VulnerabilityAffectedVersions.fromJSON(e))
        : [],
    };
  },

  toJSON(message: VulnerabilityAffects): unknown {
    const obj: any = {};
    if (message.ref !== "") {
      obj.ref = message.ref;
    }
    if (message.versions?.length) {
      obj.versions = message.versions.map((e) => VulnerabilityAffectedVersions.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VulnerabilityAffects>, I>>(base?: I): VulnerabilityAffects {
    return VulnerabilityAffects.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VulnerabilityAffects>, I>>(object: I): VulnerabilityAffects {
    const message = createBaseVulnerabilityAffects();
    message.ref = object.ref ?? "";
    message.versions = object.versions?.map((e) => VulnerabilityAffectedVersions.fromPartial(e)) || [];
    return message;
  },
};

function createBaseVulnerabilityAffectedVersions(): VulnerabilityAffectedVersions {
  return { version: undefined, range: undefined, status: undefined };
}

export const VulnerabilityAffectedVersions: MessageFns<VulnerabilityAffectedVersions> = {
  encode(message: VulnerabilityAffectedVersions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== undefined) {
      writer.uint32(10).string(message.version);
    }
    if (message.range !== undefined) {
      writer.uint32(18).string(message.range);
    }
    if (message.status !== undefined) {
      writer.uint32(24).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VulnerabilityAffectedVersions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVulnerabilityAffectedVersions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.range = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VulnerabilityAffectedVersions {
    return {
      version: isSet(object.version) ? globalThis.String(object.version) : undefined,
      range: isSet(object.range) ? globalThis.String(object.range) : undefined,
      status: isSet(object.status) ? vulnerabilityAffectedStatusFromJSON(object.status) : undefined,
    };
  },

  toJSON(message: VulnerabilityAffectedVersions): unknown {
    const obj: any = {};
    if (message.version !== undefined) {
      obj.version = message.version;
    }
    if (message.range !== undefined) {
      obj.range = message.range;
    }
    if (message.status !== undefined) {
      obj.status = vulnerabilityAffectedStatusToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VulnerabilityAffectedVersions>, I>>(base?: I): VulnerabilityAffectedVersions {
    return VulnerabilityAffectedVersions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VulnerabilityAffectedVersions>, I>>(
    object: I,
  ): VulnerabilityAffectedVersions {
    const message = createBaseVulnerabilityAffectedVersions();
    message.version = object.version ?? undefined;
    message.range = object.range ?? undefined;
    message.status = object.status ?? undefined;
    return message;
  },
};

function createBaseAnnotatorChoice(): AnnotatorChoice {
  return { organization: undefined, individual: undefined, component: undefined, service: undefined };
}

export const AnnotatorChoice: MessageFns<AnnotatorChoice> = {
  encode(message: AnnotatorChoice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organization !== undefined) {
      OrganizationalEntity.encode(message.organization, writer.uint32(10).fork()).join();
    }
    if (message.individual !== undefined) {
      OrganizationalContact.encode(message.individual, writer.uint32(18).fork()).join();
    }
    if (message.component !== undefined) {
      Component.encode(message.component, writer.uint32(26).fork()).join();
    }
    if (message.service !== undefined) {
      Service.encode(message.service, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnnotatorChoice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotatorChoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organization = OrganizationalEntity.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.individual = OrganizationalContact.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.component = Component.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.service = Service.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnnotatorChoice {
    return {
      organization: isSet(object.organization) ? OrganizationalEntity.fromJSON(object.organization) : undefined,
      individual: isSet(object.individual) ? OrganizationalContact.fromJSON(object.individual) : undefined,
      component: isSet(object.component) ? Component.fromJSON(object.component) : undefined,
      service: isSet(object.service) ? Service.fromJSON(object.service) : undefined,
    };
  },

  toJSON(message: AnnotatorChoice): unknown {
    const obj: any = {};
    if (message.organization !== undefined) {
      obj.organization = OrganizationalEntity.toJSON(message.organization);
    }
    if (message.individual !== undefined) {
      obj.individual = OrganizationalContact.toJSON(message.individual);
    }
    if (message.component !== undefined) {
      obj.component = Component.toJSON(message.component);
    }
    if (message.service !== undefined) {
      obj.service = Service.toJSON(message.service);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnnotatorChoice>, I>>(base?: I): AnnotatorChoice {
    return AnnotatorChoice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnnotatorChoice>, I>>(object: I): AnnotatorChoice {
    const message = createBaseAnnotatorChoice();
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? OrganizationalEntity.fromPartial(object.organization)
      : undefined;
    message.individual = (object.individual !== undefined && object.individual !== null)
      ? OrganizationalContact.fromPartial(object.individual)
      : undefined;
    message.component = (object.component !== undefined && object.component !== null)
      ? Component.fromPartial(object.component)
      : undefined;
    message.service = (object.service !== undefined && object.service !== null)
      ? Service.fromPartial(object.service)
      : undefined;
    return message;
  },
};

function createBaseAnnotation(): Annotation {
  return { bomRef: undefined, subjects: [], annotator: undefined, timestamp: undefined, text: "" };
}

export const Annotation: MessageFns<Annotation> = {
  encode(message: Annotation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== undefined) {
      writer.uint32(10).string(message.bomRef);
    }
    for (const v of message.subjects) {
      writer.uint32(18).string(v!);
    }
    if (message.annotator !== undefined) {
      AnnotatorChoice.encode(message.annotator, writer.uint32(26).fork()).join();
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(34).fork()).join();
    }
    if (message.text !== "") {
      writer.uint32(42).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Annotation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnnotation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subjects.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.annotator = AnnotatorChoice.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Annotation {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      subjects: globalThis.Array.isArray(object?.subjects) ? object.subjects.map((e: any) => globalThis.String(e)) : [],
      annotator: isSet(object.annotator) ? AnnotatorChoice.fromJSON(object.annotator) : undefined,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
    };
  },

  toJSON(message: Annotation): unknown {
    const obj: any = {};
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.subjects?.length) {
      obj.subjects = message.subjects;
    }
    if (message.annotator !== undefined) {
      obj.annotator = AnnotatorChoice.toJSON(message.annotator);
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Annotation>, I>>(base?: I): Annotation {
    return Annotation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Annotation>, I>>(object: I): Annotation {
    const message = createBaseAnnotation();
    message.bomRef = object.bomRef ?? undefined;
    message.subjects = object.subjects?.map((e) => e) || [];
    message.annotator = (object.annotator !== undefined && object.annotator !== null)
      ? AnnotatorChoice.fromPartial(object.annotator)
      : undefined;
    message.timestamp = object.timestamp ?? undefined;
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseModelCard(): ModelCard {
  return { bomRef: undefined, modelParameters: undefined, quantitativeAnalysis: undefined, considerations: undefined };
}

export const ModelCard: MessageFns<ModelCard> = {
  encode(message: ModelCard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== undefined) {
      writer.uint32(10).string(message.bomRef);
    }
    if (message.modelParameters !== undefined) {
      ModelCard_ModelParameters.encode(message.modelParameters, writer.uint32(18).fork()).join();
    }
    if (message.quantitativeAnalysis !== undefined) {
      ModelCard_QuantitativeAnalysis.encode(message.quantitativeAnalysis, writer.uint32(26).fork()).join();
    }
    if (message.considerations !== undefined) {
      ModelCard_ModelCardConsiderations.encode(message.considerations, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelCard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelParameters = ModelCard_ModelParameters.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.quantitativeAnalysis = ModelCard_QuantitativeAnalysis.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.considerations = ModelCard_ModelCardConsiderations.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelCard {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      modelParameters: isSet(object.modelParameters)
        ? ModelCard_ModelParameters.fromJSON(object.modelParameters)
        : undefined,
      quantitativeAnalysis: isSet(object.quantitativeAnalysis)
        ? ModelCard_QuantitativeAnalysis.fromJSON(object.quantitativeAnalysis)
        : undefined,
      considerations: isSet(object.considerations)
        ? ModelCard_ModelCardConsiderations.fromJSON(object.considerations)
        : undefined,
    };
  },

  toJSON(message: ModelCard): unknown {
    const obj: any = {};
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.modelParameters !== undefined) {
      obj.modelParameters = ModelCard_ModelParameters.toJSON(message.modelParameters);
    }
    if (message.quantitativeAnalysis !== undefined) {
      obj.quantitativeAnalysis = ModelCard_QuantitativeAnalysis.toJSON(message.quantitativeAnalysis);
    }
    if (message.considerations !== undefined) {
      obj.considerations = ModelCard_ModelCardConsiderations.toJSON(message.considerations);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelCard>, I>>(base?: I): ModelCard {
    return ModelCard.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelCard>, I>>(object: I): ModelCard {
    const message = createBaseModelCard();
    message.bomRef = object.bomRef ?? undefined;
    message.modelParameters = (object.modelParameters !== undefined && object.modelParameters !== null)
      ? ModelCard_ModelParameters.fromPartial(object.modelParameters)
      : undefined;
    message.quantitativeAnalysis = (object.quantitativeAnalysis !== undefined && object.quantitativeAnalysis !== null)
      ? ModelCard_QuantitativeAnalysis.fromPartial(object.quantitativeAnalysis)
      : undefined;
    message.considerations = (object.considerations !== undefined && object.considerations !== null)
      ? ModelCard_ModelCardConsiderations.fromPartial(object.considerations)
      : undefined;
    return message;
  },
};

function createBaseModelCard_ModelParameters(): ModelCard_ModelParameters {
  return {
    approach: undefined,
    task: undefined,
    architectureFamily: undefined,
    modelArchitecture: undefined,
    datasets: [],
    inputs: [],
    outputs: [],
  };
}

export const ModelCard_ModelParameters: MessageFns<ModelCard_ModelParameters> = {
  encode(message: ModelCard_ModelParameters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.approach !== undefined) {
      ModelCard_ModelParameters_Approach.encode(message.approach, writer.uint32(10).fork()).join();
    }
    if (message.task !== undefined) {
      writer.uint32(18).string(message.task);
    }
    if (message.architectureFamily !== undefined) {
      writer.uint32(26).string(message.architectureFamily);
    }
    if (message.modelArchitecture !== undefined) {
      writer.uint32(34).string(message.modelArchitecture);
    }
    for (const v of message.datasets) {
      ModelCard_ModelParameters_Datasets.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.inputs) {
      ModelCard_ModelParameters_MachineLearningInputOutputParameters.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.outputs) {
      ModelCard_ModelParameters_MachineLearningInputOutputParameters.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelCard_ModelParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelCard_ModelParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.approach = ModelCard_ModelParameters_Approach.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.task = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.architectureFamily = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.modelArchitecture = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.datasets.push(ModelCard_ModelParameters_Datasets.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.inputs.push(
            ModelCard_ModelParameters_MachineLearningInputOutputParameters.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.outputs.push(
            ModelCard_ModelParameters_MachineLearningInputOutputParameters.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelCard_ModelParameters {
    return {
      approach: isSet(object.approach) ? ModelCard_ModelParameters_Approach.fromJSON(object.approach) : undefined,
      task: isSet(object.task) ? globalThis.String(object.task) : undefined,
      architectureFamily: isSet(object.architectureFamily) ? globalThis.String(object.architectureFamily) : undefined,
      modelArchitecture: isSet(object.modelArchitecture) ? globalThis.String(object.modelArchitecture) : undefined,
      datasets: globalThis.Array.isArray(object?.datasets)
        ? object.datasets.map((e: any) => ModelCard_ModelParameters_Datasets.fromJSON(e))
        : [],
      inputs: globalThis.Array.isArray(object?.inputs)
        ? object.inputs.map((e: any) => ModelCard_ModelParameters_MachineLearningInputOutputParameters.fromJSON(e))
        : [],
      outputs: globalThis.Array.isArray(object?.outputs)
        ? object.outputs.map((e: any) => ModelCard_ModelParameters_MachineLearningInputOutputParameters.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ModelCard_ModelParameters): unknown {
    const obj: any = {};
    if (message.approach !== undefined) {
      obj.approach = ModelCard_ModelParameters_Approach.toJSON(message.approach);
    }
    if (message.task !== undefined) {
      obj.task = message.task;
    }
    if (message.architectureFamily !== undefined) {
      obj.architectureFamily = message.architectureFamily;
    }
    if (message.modelArchitecture !== undefined) {
      obj.modelArchitecture = message.modelArchitecture;
    }
    if (message.datasets?.length) {
      obj.datasets = message.datasets.map((e) => ModelCard_ModelParameters_Datasets.toJSON(e));
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => ModelCard_ModelParameters_MachineLearningInputOutputParameters.toJSON(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) =>
        ModelCard_ModelParameters_MachineLearningInputOutputParameters.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelCard_ModelParameters>, I>>(base?: I): ModelCard_ModelParameters {
    return ModelCard_ModelParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelCard_ModelParameters>, I>>(object: I): ModelCard_ModelParameters {
    const message = createBaseModelCard_ModelParameters();
    message.approach = (object.approach !== undefined && object.approach !== null)
      ? ModelCard_ModelParameters_Approach.fromPartial(object.approach)
      : undefined;
    message.task = object.task ?? undefined;
    message.architectureFamily = object.architectureFamily ?? undefined;
    message.modelArchitecture = object.modelArchitecture ?? undefined;
    message.datasets = object.datasets?.map((e) => ModelCard_ModelParameters_Datasets.fromPartial(e)) || [];
    message.inputs =
      object.inputs?.map((e) => ModelCard_ModelParameters_MachineLearningInputOutputParameters.fromPartial(e)) || [];
    message.outputs =
      object.outputs?.map((e) => ModelCard_ModelParameters_MachineLearningInputOutputParameters.fromPartial(e)) || [];
    return message;
  },
};

function createBaseModelCard_ModelParameters_Approach(): ModelCard_ModelParameters_Approach {
  return { type: undefined };
}

export const ModelCard_ModelParameters_Approach: MessageFns<ModelCard_ModelParameters_Approach> = {
  encode(message: ModelCard_ModelParameters_Approach, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== undefined) {
      writer.uint32(8).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelCard_ModelParameters_Approach {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelCard_ModelParameters_Approach();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelCard_ModelParameters_Approach {
    return { type: isSet(object.type) ? modelParameterApproachTypeFromJSON(object.type) : undefined };
  },

  toJSON(message: ModelCard_ModelParameters_Approach): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = modelParameterApproachTypeToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelCard_ModelParameters_Approach>, I>>(
    base?: I,
  ): ModelCard_ModelParameters_Approach {
    return ModelCard_ModelParameters_Approach.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelCard_ModelParameters_Approach>, I>>(
    object: I,
  ): ModelCard_ModelParameters_Approach {
    const message = createBaseModelCard_ModelParameters_Approach();
    message.type = object.type ?? undefined;
    return message;
  },
};

function createBaseModelCard_ModelParameters_Datasets(): ModelCard_ModelParameters_Datasets {
  return { dataset: undefined, ref: undefined };
}

export const ModelCard_ModelParameters_Datasets: MessageFns<ModelCard_ModelParameters_Datasets> = {
  encode(message: ModelCard_ModelParameters_Datasets, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dataset !== undefined) {
      ComponentData.encode(message.dataset, writer.uint32(10).fork()).join();
    }
    if (message.ref !== undefined) {
      writer.uint32(18).string(message.ref);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelCard_ModelParameters_Datasets {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelCard_ModelParameters_Datasets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dataset = ComponentData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ref = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelCard_ModelParameters_Datasets {
    return {
      dataset: isSet(object.dataset) ? ComponentData.fromJSON(object.dataset) : undefined,
      ref: isSet(object.ref) ? globalThis.String(object.ref) : undefined,
    };
  },

  toJSON(message: ModelCard_ModelParameters_Datasets): unknown {
    const obj: any = {};
    if (message.dataset !== undefined) {
      obj.dataset = ComponentData.toJSON(message.dataset);
    }
    if (message.ref !== undefined) {
      obj.ref = message.ref;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelCard_ModelParameters_Datasets>, I>>(
    base?: I,
  ): ModelCard_ModelParameters_Datasets {
    return ModelCard_ModelParameters_Datasets.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelCard_ModelParameters_Datasets>, I>>(
    object: I,
  ): ModelCard_ModelParameters_Datasets {
    const message = createBaseModelCard_ModelParameters_Datasets();
    message.dataset = (object.dataset !== undefined && object.dataset !== null)
      ? ComponentData.fromPartial(object.dataset)
      : undefined;
    message.ref = object.ref ?? undefined;
    return message;
  },
};

function createBaseModelCard_ModelParameters_MachineLearningInputOutputParameters(): ModelCard_ModelParameters_MachineLearningInputOutputParameters {
  return { format: undefined };
}

export const ModelCard_ModelParameters_MachineLearningInputOutputParameters: MessageFns<
  ModelCard_ModelParameters_MachineLearningInputOutputParameters
> = {
  encode(
    message: ModelCard_ModelParameters_MachineLearningInputOutputParameters,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.format !== undefined) {
      writer.uint32(10).string(message.format);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ModelCard_ModelParameters_MachineLearningInputOutputParameters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelCard_ModelParameters_MachineLearningInputOutputParameters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.format = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelCard_ModelParameters_MachineLearningInputOutputParameters {
    return { format: isSet(object.format) ? globalThis.String(object.format) : undefined };
  },

  toJSON(message: ModelCard_ModelParameters_MachineLearningInputOutputParameters): unknown {
    const obj: any = {};
    if (message.format !== undefined) {
      obj.format = message.format;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelCard_ModelParameters_MachineLearningInputOutputParameters>, I>>(
    base?: I,
  ): ModelCard_ModelParameters_MachineLearningInputOutputParameters {
    return ModelCard_ModelParameters_MachineLearningInputOutputParameters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelCard_ModelParameters_MachineLearningInputOutputParameters>, I>>(
    object: I,
  ): ModelCard_ModelParameters_MachineLearningInputOutputParameters {
    const message = createBaseModelCard_ModelParameters_MachineLearningInputOutputParameters();
    message.format = object.format ?? undefined;
    return message;
  },
};

function createBaseModelCard_QuantitativeAnalysis(): ModelCard_QuantitativeAnalysis {
  return { performanceMetrics: [], graphics: undefined };
}

export const ModelCard_QuantitativeAnalysis: MessageFns<ModelCard_QuantitativeAnalysis> = {
  encode(message: ModelCard_QuantitativeAnalysis, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.performanceMetrics) {
      ModelCard_QuantitativeAnalysis_PerformanceMetrics.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.graphics !== undefined) {
      GraphicsCollection.encode(message.graphics, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelCard_QuantitativeAnalysis {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelCard_QuantitativeAnalysis();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.performanceMetrics.push(
            ModelCard_QuantitativeAnalysis_PerformanceMetrics.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.graphics = GraphicsCollection.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelCard_QuantitativeAnalysis {
    return {
      performanceMetrics: globalThis.Array.isArray(object?.performanceMetrics)
        ? object.performanceMetrics.map((e: any) => ModelCard_QuantitativeAnalysis_PerformanceMetrics.fromJSON(e))
        : [],
      graphics: isSet(object.graphics) ? GraphicsCollection.fromJSON(object.graphics) : undefined,
    };
  },

  toJSON(message: ModelCard_QuantitativeAnalysis): unknown {
    const obj: any = {};
    if (message.performanceMetrics?.length) {
      obj.performanceMetrics = message.performanceMetrics.map((e) =>
        ModelCard_QuantitativeAnalysis_PerformanceMetrics.toJSON(e)
      );
    }
    if (message.graphics !== undefined) {
      obj.graphics = GraphicsCollection.toJSON(message.graphics);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelCard_QuantitativeAnalysis>, I>>(base?: I): ModelCard_QuantitativeAnalysis {
    return ModelCard_QuantitativeAnalysis.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelCard_QuantitativeAnalysis>, I>>(
    object: I,
  ): ModelCard_QuantitativeAnalysis {
    const message = createBaseModelCard_QuantitativeAnalysis();
    message.performanceMetrics =
      object.performanceMetrics?.map((e) => ModelCard_QuantitativeAnalysis_PerformanceMetrics.fromPartial(e)) || [];
    message.graphics = (object.graphics !== undefined && object.graphics !== null)
      ? GraphicsCollection.fromPartial(object.graphics)
      : undefined;
    return message;
  },
};

function createBaseModelCard_QuantitativeAnalysis_PerformanceMetrics(): ModelCard_QuantitativeAnalysis_PerformanceMetrics {
  return { type: undefined, value: undefined, slice: undefined, confidenceInterval: undefined };
}

export const ModelCard_QuantitativeAnalysis_PerformanceMetrics: MessageFns<
  ModelCard_QuantitativeAnalysis_PerformanceMetrics
> = {
  encode(
    message: ModelCard_QuantitativeAnalysis_PerformanceMetrics,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== undefined) {
      writer.uint32(10).string(message.type);
    }
    if (message.value !== undefined) {
      writer.uint32(18).string(message.value);
    }
    if (message.slice !== undefined) {
      writer.uint32(26).string(message.slice);
    }
    if (message.confidenceInterval !== undefined) {
      ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval.encode(
        message.confidenceInterval,
        writer.uint32(34).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelCard_QuantitativeAnalysis_PerformanceMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelCard_QuantitativeAnalysis_PerformanceMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.slice = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.confidenceInterval = ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelCard_QuantitativeAnalysis_PerformanceMetrics {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
      slice: isSet(object.slice) ? globalThis.String(object.slice) : undefined,
      confidenceInterval: isSet(object.confidenceInterval)
        ? ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval.fromJSON(object.confidenceInterval)
        : undefined,
    };
  },

  toJSON(message: ModelCard_QuantitativeAnalysis_PerformanceMetrics): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.slice !== undefined) {
      obj.slice = message.slice;
    }
    if (message.confidenceInterval !== undefined) {
      obj.confidenceInterval = ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval.toJSON(
        message.confidenceInterval,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelCard_QuantitativeAnalysis_PerformanceMetrics>, I>>(
    base?: I,
  ): ModelCard_QuantitativeAnalysis_PerformanceMetrics {
    return ModelCard_QuantitativeAnalysis_PerformanceMetrics.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelCard_QuantitativeAnalysis_PerformanceMetrics>, I>>(
    object: I,
  ): ModelCard_QuantitativeAnalysis_PerformanceMetrics {
    const message = createBaseModelCard_QuantitativeAnalysis_PerformanceMetrics();
    message.type = object.type ?? undefined;
    message.value = object.value ?? undefined;
    message.slice = object.slice ?? undefined;
    message.confidenceInterval = (object.confidenceInterval !== undefined && object.confidenceInterval !== null)
      ? ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval.fromPartial(object.confidenceInterval)
      : undefined;
    return message;
  },
};

function createBaseModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval(): ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval {
  return { lowerBound: undefined, upperBound: undefined };
}

export const ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval: MessageFns<
  ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval
> = {
  encode(
    message: ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.lowerBound !== undefined) {
      writer.uint32(10).string(message.lowerBound);
    }
    if (message.upperBound !== undefined) {
      writer.uint32(18).string(message.upperBound);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lowerBound = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.upperBound = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval {
    return {
      lowerBound: isSet(object.lowerBound) ? globalThis.String(object.lowerBound) : undefined,
      upperBound: isSet(object.upperBound) ? globalThis.String(object.upperBound) : undefined,
    };
  },

  toJSON(message: ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval): unknown {
    const obj: any = {};
    if (message.lowerBound !== undefined) {
      obj.lowerBound = message.lowerBound;
    }
    if (message.upperBound !== undefined) {
      obj.upperBound = message.upperBound;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval>, I>>(
    base?: I,
  ): ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval {
    return ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval>, I>>(
    object: I,
  ): ModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval {
    const message = createBaseModelCard_QuantitativeAnalysis_PerformanceMetrics_ConfidenceInterval();
    message.lowerBound = object.lowerBound ?? undefined;
    message.upperBound = object.upperBound ?? undefined;
    return message;
  },
};

function createBaseModelCard_ModelCardConsiderations(): ModelCard_ModelCardConsiderations {
  return {
    users: [],
    useCases: [],
    technicalLimitations: [],
    performanceTradeoffs: [],
    ethicalConsiderations: [],
    fairnessAssessments: [],
    environmentalConsiderations: undefined,
  };
}

export const ModelCard_ModelCardConsiderations: MessageFns<ModelCard_ModelCardConsiderations> = {
  encode(message: ModelCard_ModelCardConsiderations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.useCases) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.technicalLimitations) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.performanceTradeoffs) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.ethicalConsiderations) {
      ModelCard_ModelCardConsiderations_EthicalConsiderations.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.fairnessAssessments) {
      ModelCard_ModelCardConsiderations_FairnessAssessments.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.environmentalConsiderations !== undefined) {
      ModelCard_ModelCardConsiderations_EnvironmentalConsiderations.encode(
        message.environmentalConsiderations,
        writer.uint32(58).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelCard_ModelCardConsiderations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelCard_ModelCardConsiderations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.useCases.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.technicalLimitations.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.performanceTradeoffs.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ethicalConsiderations.push(
            ModelCard_ModelCardConsiderations_EthicalConsiderations.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fairnessAssessments.push(
            ModelCard_ModelCardConsiderations_FairnessAssessments.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.environmentalConsiderations = ModelCard_ModelCardConsiderations_EnvironmentalConsiderations.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelCard_ModelCardConsiderations {
    return {
      users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => globalThis.String(e)) : [],
      useCases: globalThis.Array.isArray(object?.useCases) ? object.useCases.map((e: any) => globalThis.String(e)) : [],
      technicalLimitations: globalThis.Array.isArray(object?.technicalLimitations)
        ? object.technicalLimitations.map((e: any) => globalThis.String(e))
        : [],
      performanceTradeoffs: globalThis.Array.isArray(object?.performanceTradeoffs)
        ? object.performanceTradeoffs.map((e: any) => globalThis.String(e))
        : [],
      ethicalConsiderations: globalThis.Array.isArray(object?.ethicalConsiderations)
        ? object.ethicalConsiderations.map((e: any) =>
          ModelCard_ModelCardConsiderations_EthicalConsiderations.fromJSON(e)
        )
        : [],
      fairnessAssessments: globalThis.Array.isArray(object?.fairnessAssessments)
        ? object.fairnessAssessments.map((e: any) => ModelCard_ModelCardConsiderations_FairnessAssessments.fromJSON(e))
        : [],
      environmentalConsiderations: isSet(object.environmentalConsiderations)
        ? ModelCard_ModelCardConsiderations_EnvironmentalConsiderations.fromJSON(object.environmentalConsiderations)
        : undefined,
    };
  },

  toJSON(message: ModelCard_ModelCardConsiderations): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users;
    }
    if (message.useCases?.length) {
      obj.useCases = message.useCases;
    }
    if (message.technicalLimitations?.length) {
      obj.technicalLimitations = message.technicalLimitations;
    }
    if (message.performanceTradeoffs?.length) {
      obj.performanceTradeoffs = message.performanceTradeoffs;
    }
    if (message.ethicalConsiderations?.length) {
      obj.ethicalConsiderations = message.ethicalConsiderations.map((e) =>
        ModelCard_ModelCardConsiderations_EthicalConsiderations.toJSON(e)
      );
    }
    if (message.fairnessAssessments?.length) {
      obj.fairnessAssessments = message.fairnessAssessments.map((e) =>
        ModelCard_ModelCardConsiderations_FairnessAssessments.toJSON(e)
      );
    }
    if (message.environmentalConsiderations !== undefined) {
      obj.environmentalConsiderations = ModelCard_ModelCardConsiderations_EnvironmentalConsiderations.toJSON(
        message.environmentalConsiderations,
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelCard_ModelCardConsiderations>, I>>(
    base?: I,
  ): ModelCard_ModelCardConsiderations {
    return ModelCard_ModelCardConsiderations.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelCard_ModelCardConsiderations>, I>>(
    object: I,
  ): ModelCard_ModelCardConsiderations {
    const message = createBaseModelCard_ModelCardConsiderations();
    message.users = object.users?.map((e) => e) || [];
    message.useCases = object.useCases?.map((e) => e) || [];
    message.technicalLimitations = object.technicalLimitations?.map((e) => e) || [];
    message.performanceTradeoffs = object.performanceTradeoffs?.map((e) => e) || [];
    message.ethicalConsiderations =
      object.ethicalConsiderations?.map((e) =>
        ModelCard_ModelCardConsiderations_EthicalConsiderations.fromPartial(e)
      ) || [];
    message.fairnessAssessments =
      object.fairnessAssessments?.map((e) => ModelCard_ModelCardConsiderations_FairnessAssessments.fromPartial(e)) ||
      [];
    message.environmentalConsiderations =
      (object.environmentalConsiderations !== undefined && object.environmentalConsiderations !== null)
        ? ModelCard_ModelCardConsiderations_EnvironmentalConsiderations.fromPartial(object.environmentalConsiderations)
        : undefined;
    return message;
  },
};

function createBaseModelCard_ModelCardConsiderations_EthicalConsiderations(): ModelCard_ModelCardConsiderations_EthicalConsiderations {
  return { name: undefined, mitigationStrategy: undefined };
}

export const ModelCard_ModelCardConsiderations_EthicalConsiderations: MessageFns<
  ModelCard_ModelCardConsiderations_EthicalConsiderations
> = {
  encode(
    message: ModelCard_ModelCardConsiderations_EthicalConsiderations,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.mitigationStrategy !== undefined) {
      writer.uint32(18).string(message.mitigationStrategy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelCard_ModelCardConsiderations_EthicalConsiderations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelCard_ModelCardConsiderations_EthicalConsiderations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mitigationStrategy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelCard_ModelCardConsiderations_EthicalConsiderations {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      mitigationStrategy: isSet(object.mitigationStrategy) ? globalThis.String(object.mitigationStrategy) : undefined,
    };
  },

  toJSON(message: ModelCard_ModelCardConsiderations_EthicalConsiderations): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.mitigationStrategy !== undefined) {
      obj.mitigationStrategy = message.mitigationStrategy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelCard_ModelCardConsiderations_EthicalConsiderations>, I>>(
    base?: I,
  ): ModelCard_ModelCardConsiderations_EthicalConsiderations {
    return ModelCard_ModelCardConsiderations_EthicalConsiderations.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelCard_ModelCardConsiderations_EthicalConsiderations>, I>>(
    object: I,
  ): ModelCard_ModelCardConsiderations_EthicalConsiderations {
    const message = createBaseModelCard_ModelCardConsiderations_EthicalConsiderations();
    message.name = object.name ?? undefined;
    message.mitigationStrategy = object.mitigationStrategy ?? undefined;
    return message;
  },
};

function createBaseModelCard_ModelCardConsiderations_FairnessAssessments(): ModelCard_ModelCardConsiderations_FairnessAssessments {
  return { groupAtRisk: undefined, benefits: undefined, harms: undefined, mitigationStrategy: undefined };
}

export const ModelCard_ModelCardConsiderations_FairnessAssessments: MessageFns<
  ModelCard_ModelCardConsiderations_FairnessAssessments
> = {
  encode(
    message: ModelCard_ModelCardConsiderations_FairnessAssessments,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.groupAtRisk !== undefined) {
      writer.uint32(10).string(message.groupAtRisk);
    }
    if (message.benefits !== undefined) {
      writer.uint32(18).string(message.benefits);
    }
    if (message.harms !== undefined) {
      writer.uint32(26).string(message.harms);
    }
    if (message.mitigationStrategy !== undefined) {
      writer.uint32(34).string(message.mitigationStrategy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelCard_ModelCardConsiderations_FairnessAssessments {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelCard_ModelCardConsiderations_FairnessAssessments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.groupAtRisk = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.benefits = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.harms = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mitigationStrategy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelCard_ModelCardConsiderations_FairnessAssessments {
    return {
      groupAtRisk: isSet(object.groupAtRisk) ? globalThis.String(object.groupAtRisk) : undefined,
      benefits: isSet(object.benefits) ? globalThis.String(object.benefits) : undefined,
      harms: isSet(object.harms) ? globalThis.String(object.harms) : undefined,
      mitigationStrategy: isSet(object.mitigationStrategy) ? globalThis.String(object.mitigationStrategy) : undefined,
    };
  },

  toJSON(message: ModelCard_ModelCardConsiderations_FairnessAssessments): unknown {
    const obj: any = {};
    if (message.groupAtRisk !== undefined) {
      obj.groupAtRisk = message.groupAtRisk;
    }
    if (message.benefits !== undefined) {
      obj.benefits = message.benefits;
    }
    if (message.harms !== undefined) {
      obj.harms = message.harms;
    }
    if (message.mitigationStrategy !== undefined) {
      obj.mitigationStrategy = message.mitigationStrategy;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelCard_ModelCardConsiderations_FairnessAssessments>, I>>(
    base?: I,
  ): ModelCard_ModelCardConsiderations_FairnessAssessments {
    return ModelCard_ModelCardConsiderations_FairnessAssessments.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelCard_ModelCardConsiderations_FairnessAssessments>, I>>(
    object: I,
  ): ModelCard_ModelCardConsiderations_FairnessAssessments {
    const message = createBaseModelCard_ModelCardConsiderations_FairnessAssessments();
    message.groupAtRisk = object.groupAtRisk ?? undefined;
    message.benefits = object.benefits ?? undefined;
    message.harms = object.harms ?? undefined;
    message.mitigationStrategy = object.mitigationStrategy ?? undefined;
    return message;
  },
};

function createBaseModelCard_ModelCardConsiderations_EnvironmentalConsiderations(): ModelCard_ModelCardConsiderations_EnvironmentalConsiderations {
  return { energyConsumptions: [], properties: [] };
}

export const ModelCard_ModelCardConsiderations_EnvironmentalConsiderations: MessageFns<
  ModelCard_ModelCardConsiderations_EnvironmentalConsiderations
> = {
  encode(
    message: ModelCard_ModelCardConsiderations_EnvironmentalConsiderations,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.energyConsumptions) {
      ModelCard_ModelCardConsiderations_EnergyConsumption.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ModelCard_ModelCardConsiderations_EnvironmentalConsiderations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelCard_ModelCardConsiderations_EnvironmentalConsiderations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.energyConsumptions.push(
            ModelCard_ModelCardConsiderations_EnergyConsumption.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelCard_ModelCardConsiderations_EnvironmentalConsiderations {
    return {
      energyConsumptions: globalThis.Array.isArray(object?.energyConsumptions)
        ? object.energyConsumptions.map((e: any) => ModelCard_ModelCardConsiderations_EnergyConsumption.fromJSON(e))
        : [],
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ModelCard_ModelCardConsiderations_EnvironmentalConsiderations): unknown {
    const obj: any = {};
    if (message.energyConsumptions?.length) {
      obj.energyConsumptions = message.energyConsumptions.map((e) =>
        ModelCard_ModelCardConsiderations_EnergyConsumption.toJSON(e)
      );
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelCard_ModelCardConsiderations_EnvironmentalConsiderations>, I>>(
    base?: I,
  ): ModelCard_ModelCardConsiderations_EnvironmentalConsiderations {
    return ModelCard_ModelCardConsiderations_EnvironmentalConsiderations.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelCard_ModelCardConsiderations_EnvironmentalConsiderations>, I>>(
    object: I,
  ): ModelCard_ModelCardConsiderations_EnvironmentalConsiderations {
    const message = createBaseModelCard_ModelCardConsiderations_EnvironmentalConsiderations();
    message.energyConsumptions =
      object.energyConsumptions?.map((e) => ModelCard_ModelCardConsiderations_EnergyConsumption.fromPartial(e)) || [];
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    return message;
  },
};

function createBaseModelCard_ModelCardConsiderations_EnergyConsumption(): ModelCard_ModelCardConsiderations_EnergyConsumption {
  return {
    activity: 0,
    energyProviders: [],
    activityEnergyCost: undefined,
    co2CostEquivalent: undefined,
    co2CostOffset: undefined,
    properties: [],
  };
}

export const ModelCard_ModelCardConsiderations_EnergyConsumption: MessageFns<
  ModelCard_ModelCardConsiderations_EnergyConsumption
> = {
  encode(
    message: ModelCard_ModelCardConsiderations_EnergyConsumption,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.activity !== 0) {
      writer.uint32(8).int32(message.activity);
    }
    for (const v of message.energyProviders) {
      EnergyProviderType.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.activityEnergyCost !== undefined) {
      EnergyMeasureType.encode(message.activityEnergyCost, writer.uint32(26).fork()).join();
    }
    if (message.co2CostEquivalent !== undefined) {
      CO2MeasureType.encode(message.co2CostEquivalent, writer.uint32(34).fork()).join();
    }
    if (message.co2CostOffset !== undefined) {
      CO2MeasureType.encode(message.co2CostOffset, writer.uint32(42).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelCard_ModelCardConsiderations_EnergyConsumption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelCard_ModelCardConsiderations_EnergyConsumption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.activity = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.energyProviders.push(EnergyProviderType.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.activityEnergyCost = EnergyMeasureType.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.co2CostEquivalent = CO2MeasureType.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.co2CostOffset = CO2MeasureType.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelCard_ModelCardConsiderations_EnergyConsumption {
    return {
      activity: isSet(object.activity)
        ? modelCard_ModelCardConsiderations_EnergyConsumption_ActivityTypeFromJSON(object.activity)
        : 0,
      energyProviders: globalThis.Array.isArray(object?.energyProviders)
        ? object.energyProviders.map((e: any) => EnergyProviderType.fromJSON(e))
        : [],
      activityEnergyCost: isSet(object.activityEnergyCost)
        ? EnergyMeasureType.fromJSON(object.activityEnergyCost)
        : undefined,
      co2CostEquivalent: isSet(object.co2CostEquivalent)
        ? CO2MeasureType.fromJSON(object.co2CostEquivalent)
        : undefined,
      co2CostOffset: isSet(object.co2CostOffset) ? CO2MeasureType.fromJSON(object.co2CostOffset) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ModelCard_ModelCardConsiderations_EnergyConsumption): unknown {
    const obj: any = {};
    if (message.activity !== 0) {
      obj.activity = modelCard_ModelCardConsiderations_EnergyConsumption_ActivityTypeToJSON(message.activity);
    }
    if (message.energyProviders?.length) {
      obj.energyProviders = message.energyProviders.map((e) => EnergyProviderType.toJSON(e));
    }
    if (message.activityEnergyCost !== undefined) {
      obj.activityEnergyCost = EnergyMeasureType.toJSON(message.activityEnergyCost);
    }
    if (message.co2CostEquivalent !== undefined) {
      obj.co2CostEquivalent = CO2MeasureType.toJSON(message.co2CostEquivalent);
    }
    if (message.co2CostOffset !== undefined) {
      obj.co2CostOffset = CO2MeasureType.toJSON(message.co2CostOffset);
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModelCard_ModelCardConsiderations_EnergyConsumption>, I>>(
    base?: I,
  ): ModelCard_ModelCardConsiderations_EnergyConsumption {
    return ModelCard_ModelCardConsiderations_EnergyConsumption.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModelCard_ModelCardConsiderations_EnergyConsumption>, I>>(
    object: I,
  ): ModelCard_ModelCardConsiderations_EnergyConsumption {
    const message = createBaseModelCard_ModelCardConsiderations_EnergyConsumption();
    message.activity = object.activity ?? 0;
    message.energyProviders = object.energyProviders?.map((e) => EnergyProviderType.fromPartial(e)) || [];
    message.activityEnergyCost = (object.activityEnergyCost !== undefined && object.activityEnergyCost !== null)
      ? EnergyMeasureType.fromPartial(object.activityEnergyCost)
      : undefined;
    message.co2CostEquivalent = (object.co2CostEquivalent !== undefined && object.co2CostEquivalent !== null)
      ? CO2MeasureType.fromPartial(object.co2CostEquivalent)
      : undefined;
    message.co2CostOffset = (object.co2CostOffset !== undefined && object.co2CostOffset !== null)
      ? CO2MeasureType.fromPartial(object.co2CostOffset)
      : undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEnergyProviderType(): EnergyProviderType {
  return {
    bomRef: undefined,
    description: "",
    organization: undefined,
    energySource: 0,
    energyProvided: undefined,
    externalReferences: [],
  };
}

export const EnergyProviderType: MessageFns<EnergyProviderType> = {
  encode(message: EnergyProviderType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== undefined) {
      writer.uint32(10).string(message.bomRef);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.organization !== undefined) {
      OrganizationalEntity.encode(message.organization, writer.uint32(26).fork()).join();
    }
    if (message.energySource !== 0) {
      writer.uint32(32).int32(message.energySource);
    }
    if (message.energyProvided !== undefined) {
      EnergyMeasureType.encode(message.energyProvided, writer.uint32(42).fork()).join();
    }
    for (const v of message.externalReferences) {
      ExternalReference.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnergyProviderType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnergyProviderType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.organization = OrganizationalEntity.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.energySource = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.energyProvided = EnergyMeasureType.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.externalReferences.push(ExternalReference.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnergyProviderType {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      organization: isSet(object.organization) ? OrganizationalEntity.fromJSON(object.organization) : undefined,
      energySource: isSet(object.energySource) ? energyProviderType_EnergySourceTypeFromJSON(object.energySource) : 0,
      energyProvided: isSet(object.energyProvided) ? EnergyMeasureType.fromJSON(object.energyProvided) : undefined,
      externalReferences: globalThis.Array.isArray(object?.externalReferences)
        ? object.externalReferences.map((e: any) => ExternalReference.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EnergyProviderType): unknown {
    const obj: any = {};
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.organization !== undefined) {
      obj.organization = OrganizationalEntity.toJSON(message.organization);
    }
    if (message.energySource !== 0) {
      obj.energySource = energyProviderType_EnergySourceTypeToJSON(message.energySource);
    }
    if (message.energyProvided !== undefined) {
      obj.energyProvided = EnergyMeasureType.toJSON(message.energyProvided);
    }
    if (message.externalReferences?.length) {
      obj.externalReferences = message.externalReferences.map((e) => ExternalReference.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnergyProviderType>, I>>(base?: I): EnergyProviderType {
    return EnergyProviderType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnergyProviderType>, I>>(object: I): EnergyProviderType {
    const message = createBaseEnergyProviderType();
    message.bomRef = object.bomRef ?? undefined;
    message.description = object.description ?? "";
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? OrganizationalEntity.fromPartial(object.organization)
      : undefined;
    message.energySource = object.energySource ?? 0;
    message.energyProvided = (object.energyProvided !== undefined && object.energyProvided !== null)
      ? EnergyMeasureType.fromPartial(object.energyProvided)
      : undefined;
    message.externalReferences = object.externalReferences?.map((e) => ExternalReference.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEnergyMeasureType(): EnergyMeasureType {
  return { value: 0, unit: 0 };
}

export const EnergyMeasureType: MessageFns<EnergyMeasureType> = {
  encode(message: EnergyMeasureType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(13).float(message.value);
    }
    if (message.unit !== 0) {
      writer.uint32(16).int32(message.unit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnergyMeasureType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnergyMeasureType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.value = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.unit = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnergyMeasureType {
    return {
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      unit: isSet(object.unit) ? energyMeasureType_EnergyMeasureUnitTypeFromJSON(object.unit) : 0,
    };
  },

  toJSON(message: EnergyMeasureType): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.unit !== 0) {
      obj.unit = energyMeasureType_EnergyMeasureUnitTypeToJSON(message.unit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnergyMeasureType>, I>>(base?: I): EnergyMeasureType {
    return EnergyMeasureType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnergyMeasureType>, I>>(object: I): EnergyMeasureType {
    const message = createBaseEnergyMeasureType();
    message.value = object.value ?? 0;
    message.unit = object.unit ?? 0;
    return message;
  },
};

function createBaseCO2MeasureType(): CO2MeasureType {
  return { value: 0, unit: 0 };
}

export const CO2MeasureType: MessageFns<CO2MeasureType> = {
  encode(message: CO2MeasureType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(13).float(message.value);
    }
    if (message.unit !== 0) {
      writer.uint32(16).int32(message.unit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CO2MeasureType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCO2MeasureType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 13) {
            break;
          }

          message.value = reader.float();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.unit = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CO2MeasureType {
    return {
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      unit: isSet(object.unit) ? cO2MeasureType_CO2MeasureUnitTypeFromJSON(object.unit) : 0,
    };
  },

  toJSON(message: CO2MeasureType): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = message.value;
    }
    if (message.unit !== 0) {
      obj.unit = cO2MeasureType_CO2MeasureUnitTypeToJSON(message.unit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CO2MeasureType>, I>>(base?: I): CO2MeasureType {
    return CO2MeasureType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CO2MeasureType>, I>>(object: I): CO2MeasureType {
    const message = createBaseCO2MeasureType();
    message.value = object.value ?? 0;
    message.unit = object.unit ?? 0;
    return message;
  },
};

function createBasePostalAddressType(): PostalAddressType {
  return {
    bomRef: undefined,
    country: undefined,
    region: undefined,
    locality: undefined,
    postOfficeBoxNumber: undefined,
    postalCodeue: undefined,
    streetAddress: undefined,
  };
}

export const PostalAddressType: MessageFns<PostalAddressType> = {
  encode(message: PostalAddressType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== undefined) {
      writer.uint32(10).string(message.bomRef);
    }
    if (message.country !== undefined) {
      writer.uint32(18).string(message.country);
    }
    if (message.region !== undefined) {
      writer.uint32(26).string(message.region);
    }
    if (message.locality !== undefined) {
      writer.uint32(34).string(message.locality);
    }
    if (message.postOfficeBoxNumber !== undefined) {
      writer.uint32(42).string(message.postOfficeBoxNumber);
    }
    if (message.postalCodeue !== undefined) {
      writer.uint32(50).string(message.postalCodeue);
    }
    if (message.streetAddress !== undefined) {
      writer.uint32(58).string(message.streetAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostalAddressType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostalAddressType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.country = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.locality = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.postOfficeBoxNumber = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.postalCodeue = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.streetAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PostalAddressType {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      country: isSet(object.country) ? globalThis.String(object.country) : undefined,
      region: isSet(object.region) ? globalThis.String(object.region) : undefined,
      locality: isSet(object.locality) ? globalThis.String(object.locality) : undefined,
      postOfficeBoxNumber: isSet(object.postOfficeBoxNumber)
        ? globalThis.String(object.postOfficeBoxNumber)
        : undefined,
      postalCodeue: isSet(object.postalCodeue) ? globalThis.String(object.postalCodeue) : undefined,
      streetAddress: isSet(object.streetAddress) ? globalThis.String(object.streetAddress) : undefined,
    };
  },

  toJSON(message: PostalAddressType): unknown {
    const obj: any = {};
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.country !== undefined) {
      obj.country = message.country;
    }
    if (message.region !== undefined) {
      obj.region = message.region;
    }
    if (message.locality !== undefined) {
      obj.locality = message.locality;
    }
    if (message.postOfficeBoxNumber !== undefined) {
      obj.postOfficeBoxNumber = message.postOfficeBoxNumber;
    }
    if (message.postalCodeue !== undefined) {
      obj.postalCodeue = message.postalCodeue;
    }
    if (message.streetAddress !== undefined) {
      obj.streetAddress = message.streetAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PostalAddressType>, I>>(base?: I): PostalAddressType {
    return PostalAddressType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PostalAddressType>, I>>(object: I): PostalAddressType {
    const message = createBasePostalAddressType();
    message.bomRef = object.bomRef ?? undefined;
    message.country = object.country ?? undefined;
    message.region = object.region ?? undefined;
    message.locality = object.locality ?? undefined;
    message.postOfficeBoxNumber = object.postOfficeBoxNumber ?? undefined;
    message.postalCodeue = object.postalCodeue ?? undefined;
    message.streetAddress = object.streetAddress ?? undefined;
    return message;
  },
};

function createBaseComponentData(): ComponentData {
  return {
    bomRef: undefined,
    type: 0,
    name: undefined,
    contents: undefined,
    classification: undefined,
    sensitiveData: [],
    graphics: undefined,
    description: undefined,
    governance: undefined,
  };
}

export const ComponentData: MessageFns<ComponentData> = {
  encode(message: ComponentData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== undefined) {
      writer.uint32(10).string(message.bomRef);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.contents !== undefined) {
      ComponentData_ComponentDataContents.encode(message.contents, writer.uint32(34).fork()).join();
    }
    if (message.classification !== undefined) {
      writer.uint32(42).string(message.classification);
    }
    for (const v of message.sensitiveData) {
      writer.uint32(50).string(v!);
    }
    if (message.graphics !== undefined) {
      GraphicsCollection.encode(message.graphics, writer.uint32(58).fork()).join();
    }
    if (message.description !== undefined) {
      writer.uint32(66).string(message.description);
    }
    if (message.governance !== undefined) {
      DataGovernance.encode(message.governance, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComponentData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponentData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contents = ComponentData_ComponentDataContents.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.classification = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sensitiveData.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.graphics = GraphicsCollection.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.governance = DataGovernance.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComponentData {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      type: isSet(object.type) ? componentDataTypeFromJSON(object.type) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      contents: isSet(object.contents) ? ComponentData_ComponentDataContents.fromJSON(object.contents) : undefined,
      classification: isSet(object.classification) ? globalThis.String(object.classification) : undefined,
      sensitiveData: globalThis.Array.isArray(object?.sensitiveData)
        ? object.sensitiveData.map((e: any) => globalThis.String(e))
        : [],
      graphics: isSet(object.graphics) ? GraphicsCollection.fromJSON(object.graphics) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      governance: isSet(object.governance) ? DataGovernance.fromJSON(object.governance) : undefined,
    };
  },

  toJSON(message: ComponentData): unknown {
    const obj: any = {};
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.type !== 0) {
      obj.type = componentDataTypeToJSON(message.type);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.contents !== undefined) {
      obj.contents = ComponentData_ComponentDataContents.toJSON(message.contents);
    }
    if (message.classification !== undefined) {
      obj.classification = message.classification;
    }
    if (message.sensitiveData?.length) {
      obj.sensitiveData = message.sensitiveData;
    }
    if (message.graphics !== undefined) {
      obj.graphics = GraphicsCollection.toJSON(message.graphics);
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.governance !== undefined) {
      obj.governance = DataGovernance.toJSON(message.governance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComponentData>, I>>(base?: I): ComponentData {
    return ComponentData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComponentData>, I>>(object: I): ComponentData {
    const message = createBaseComponentData();
    message.bomRef = object.bomRef ?? undefined;
    message.type = object.type ?? 0;
    message.name = object.name ?? undefined;
    message.contents = (object.contents !== undefined && object.contents !== null)
      ? ComponentData_ComponentDataContents.fromPartial(object.contents)
      : undefined;
    message.classification = object.classification ?? undefined;
    message.sensitiveData = object.sensitiveData?.map((e) => e) || [];
    message.graphics = (object.graphics !== undefined && object.graphics !== null)
      ? GraphicsCollection.fromPartial(object.graphics)
      : undefined;
    message.description = object.description ?? undefined;
    message.governance = (object.governance !== undefined && object.governance !== null)
      ? DataGovernance.fromPartial(object.governance)
      : undefined;
    return message;
  },
};

function createBaseComponentData_ComponentDataContents(): ComponentData_ComponentDataContents {
  return { attachment: undefined, url: undefined, properties: [] };
}

export const ComponentData_ComponentDataContents: MessageFns<ComponentData_ComponentDataContents> = {
  encode(message: ComponentData_ComponentDataContents, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attachment !== undefined) {
      AttachedText.encode(message.attachment, writer.uint32(10).fork()).join();
    }
    if (message.url !== undefined) {
      writer.uint32(18).string(message.url);
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComponentData_ComponentDataContents {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComponentData_ComponentDataContents();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attachment = AttachedText.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComponentData_ComponentDataContents {
    return {
      attachment: isSet(object.attachment) ? AttachedText.fromJSON(object.attachment) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ComponentData_ComponentDataContents): unknown {
    const obj: any = {};
    if (message.attachment !== undefined) {
      obj.attachment = AttachedText.toJSON(message.attachment);
    }
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ComponentData_ComponentDataContents>, I>>(
    base?: I,
  ): ComponentData_ComponentDataContents {
    return ComponentData_ComponentDataContents.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ComponentData_ComponentDataContents>, I>>(
    object: I,
  ): ComponentData_ComponentDataContents {
    const message = createBaseComponentData_ComponentDataContents();
    message.attachment = (object.attachment !== undefined && object.attachment !== null)
      ? AttachedText.fromPartial(object.attachment)
      : undefined;
    message.url = object.url ?? undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDataGovernance(): DataGovernance {
  return { custodians: [], stewards: [], owners: [] };
}

export const DataGovernance: MessageFns<DataGovernance> = {
  encode(message: DataGovernance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.custodians) {
      DataGovernance_DataGovernanceResponsibleParty.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.stewards) {
      DataGovernance_DataGovernanceResponsibleParty.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.owners) {
      DataGovernance_DataGovernanceResponsibleParty.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataGovernance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataGovernance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.custodians.push(DataGovernance_DataGovernanceResponsibleParty.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stewards.push(DataGovernance_DataGovernanceResponsibleParty.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.owners.push(DataGovernance_DataGovernanceResponsibleParty.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataGovernance {
    return {
      custodians: globalThis.Array.isArray(object?.custodians)
        ? object.custodians.map((e: any) => DataGovernance_DataGovernanceResponsibleParty.fromJSON(e))
        : [],
      stewards: globalThis.Array.isArray(object?.stewards)
        ? object.stewards.map((e: any) => DataGovernance_DataGovernanceResponsibleParty.fromJSON(e))
        : [],
      owners: globalThis.Array.isArray(object?.owners)
        ? object.owners.map((e: any) => DataGovernance_DataGovernanceResponsibleParty.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DataGovernance): unknown {
    const obj: any = {};
    if (message.custodians?.length) {
      obj.custodians = message.custodians.map((e) => DataGovernance_DataGovernanceResponsibleParty.toJSON(e));
    }
    if (message.stewards?.length) {
      obj.stewards = message.stewards.map((e) => DataGovernance_DataGovernanceResponsibleParty.toJSON(e));
    }
    if (message.owners?.length) {
      obj.owners = message.owners.map((e) => DataGovernance_DataGovernanceResponsibleParty.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataGovernance>, I>>(base?: I): DataGovernance {
    return DataGovernance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataGovernance>, I>>(object: I): DataGovernance {
    const message = createBaseDataGovernance();
    message.custodians = object.custodians?.map((e) => DataGovernance_DataGovernanceResponsibleParty.fromPartial(e)) ||
      [];
    message.stewards = object.stewards?.map((e) => DataGovernance_DataGovernanceResponsibleParty.fromPartial(e)) || [];
    message.owners = object.owners?.map((e) => DataGovernance_DataGovernanceResponsibleParty.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDataGovernance_DataGovernanceResponsibleParty(): DataGovernance_DataGovernanceResponsibleParty {
  return { organization: undefined, contact: undefined };
}

export const DataGovernance_DataGovernanceResponsibleParty: MessageFns<DataGovernance_DataGovernanceResponsibleParty> =
  {
    encode(
      message: DataGovernance_DataGovernanceResponsibleParty,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.organization !== undefined) {
        OrganizationalEntity.encode(message.organization, writer.uint32(10).fork()).join();
      }
      if (message.contact !== undefined) {
        OrganizationalContact.encode(message.contact, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): DataGovernance_DataGovernanceResponsibleParty {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseDataGovernance_DataGovernanceResponsibleParty();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.organization = OrganizationalEntity.decode(reader, reader.uint32());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.contact = OrganizationalContact.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): DataGovernance_DataGovernanceResponsibleParty {
      return {
        organization: isSet(object.organization) ? OrganizationalEntity.fromJSON(object.organization) : undefined,
        contact: isSet(object.contact) ? OrganizationalContact.fromJSON(object.contact) : undefined,
      };
    },

    toJSON(message: DataGovernance_DataGovernanceResponsibleParty): unknown {
      const obj: any = {};
      if (message.organization !== undefined) {
        obj.organization = OrganizationalEntity.toJSON(message.organization);
      }
      if (message.contact !== undefined) {
        obj.contact = OrganizationalContact.toJSON(message.contact);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<DataGovernance_DataGovernanceResponsibleParty>, I>>(
      base?: I,
    ): DataGovernance_DataGovernanceResponsibleParty {
      return DataGovernance_DataGovernanceResponsibleParty.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<DataGovernance_DataGovernanceResponsibleParty>, I>>(
      object: I,
    ): DataGovernance_DataGovernanceResponsibleParty {
      const message = createBaseDataGovernance_DataGovernanceResponsibleParty();
      message.organization = (object.organization !== undefined && object.organization !== null)
        ? OrganizationalEntity.fromPartial(object.organization)
        : undefined;
      message.contact = (object.contact !== undefined && object.contact !== null)
        ? OrganizationalContact.fromPartial(object.contact)
        : undefined;
      return message;
    },
  };

function createBaseGraphicsCollection(): GraphicsCollection {
  return { description: undefined, graphic: [] };
}

export const GraphicsCollection: MessageFns<GraphicsCollection> = {
  encode(message: GraphicsCollection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== undefined) {
      writer.uint32(10).string(message.description);
    }
    for (const v of message.graphic) {
      GraphicsCollection_Graphic.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GraphicsCollection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGraphicsCollection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.graphic.push(GraphicsCollection_Graphic.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GraphicsCollection {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      graphic: globalThis.Array.isArray(object?.graphic)
        ? object.graphic.map((e: any) => GraphicsCollection_Graphic.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GraphicsCollection): unknown {
    const obj: any = {};
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.graphic?.length) {
      obj.graphic = message.graphic.map((e) => GraphicsCollection_Graphic.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GraphicsCollection>, I>>(base?: I): GraphicsCollection {
    return GraphicsCollection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GraphicsCollection>, I>>(object: I): GraphicsCollection {
    const message = createBaseGraphicsCollection();
    message.description = object.description ?? undefined;
    message.graphic = object.graphic?.map((e) => GraphicsCollection_Graphic.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGraphicsCollection_Graphic(): GraphicsCollection_Graphic {
  return { name: undefined, image: undefined };
}

export const GraphicsCollection_Graphic: MessageFns<GraphicsCollection_Graphic> = {
  encode(message: GraphicsCollection_Graphic, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.image !== undefined) {
      AttachedText.encode(message.image, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GraphicsCollection_Graphic {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGraphicsCollection_Graphic();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.image = AttachedText.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GraphicsCollection_Graphic {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      image: isSet(object.image) ? AttachedText.fromJSON(object.image) : undefined,
    };
  },

  toJSON(message: GraphicsCollection_Graphic): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.image !== undefined) {
      obj.image = AttachedText.toJSON(message.image);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GraphicsCollection_Graphic>, I>>(base?: I): GraphicsCollection_Graphic {
    return GraphicsCollection_Graphic.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GraphicsCollection_Graphic>, I>>(object: I): GraphicsCollection_Graphic {
    const message = createBaseGraphicsCollection_Graphic();
    message.name = object.name ?? undefined;
    message.image = (object.image !== undefined && object.image !== null)
      ? AttachedText.fromPartial(object.image)
      : undefined;
    return message;
  },
};

function createBaseFormula(): Formula {
  return { bomRef: undefined, components: [], services: [], workflows: [], properties: [] };
}

export const Formula: MessageFns<Formula> = {
  encode(message: Formula, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== undefined) {
      writer.uint32(10).string(message.bomRef);
    }
    for (const v of message.components) {
      Component.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.services) {
      Service.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.workflows) {
      Workflow.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Formula {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFormula();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.components.push(Component.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.services.push(Service.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workflows.push(Workflow.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Formula {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => Component.fromJSON(e))
        : [],
      services: globalThis.Array.isArray(object?.services) ? object.services.map((e: any) => Service.fromJSON(e)) : [],
      workflows: globalThis.Array.isArray(object?.workflows)
        ? object.workflows.map((e: any) => Workflow.fromJSON(e))
        : [],
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Formula): unknown {
    const obj: any = {};
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => Component.toJSON(e));
    }
    if (message.services?.length) {
      obj.services = message.services.map((e) => Service.toJSON(e));
    }
    if (message.workflows?.length) {
      obj.workflows = message.workflows.map((e) => Workflow.toJSON(e));
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Formula>, I>>(base?: I): Formula {
    return Formula.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Formula>, I>>(object: I): Formula {
    const message = createBaseFormula();
    message.bomRef = object.bomRef ?? undefined;
    message.components = object.components?.map((e) => Component.fromPartial(e)) || [];
    message.services = object.services?.map((e) => Service.fromPartial(e)) || [];
    message.workflows = object.workflows?.map((e) => Workflow.fromPartial(e)) || [];
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorkflow(): Workflow {
  return {
    bomRef: "",
    uid: "",
    name: undefined,
    description: undefined,
    properties: [],
    resourceReferences: [],
    tasks: [],
    taskDependencies: [],
    taskTypes: [],
    trigger: undefined,
    steps: [],
    inputs: [],
    outputs: [],
    timeStart: undefined,
    timeEnd: undefined,
    workspaces: [],
    runtimeTopology: [],
  };
}

export const Workflow: MessageFns<Workflow> = {
  encode(message: Workflow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== "") {
      writer.uint32(10).string(message.bomRef);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.resourceReferences) {
      ResourceReferenceChoice.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.tasks) {
      Task.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.taskDependencies) {
      Dependency.encode(v!, writer.uint32(66).fork()).join();
    }
    writer.uint32(74).fork();
    for (const v of message.taskTypes) {
      writer.int32(v);
    }
    writer.join();
    if (message.trigger !== undefined) {
      Trigger.encode(message.trigger, writer.uint32(82).fork()).join();
    }
    for (const v of message.steps) {
      Step.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.inputs) {
      InputType.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.outputs) {
      OutputType.encode(v!, writer.uint32(106).fork()).join();
    }
    if (message.timeStart !== undefined) {
      Timestamp.encode(toTimestamp(message.timeStart), writer.uint32(114).fork()).join();
    }
    if (message.timeEnd !== undefined) {
      Timestamp.encode(toTimestamp(message.timeEnd), writer.uint32(122).fork()).join();
    }
    for (const v of message.workspaces) {
      Workspace.encode(v!, writer.uint32(130).fork()).join();
    }
    for (const v of message.runtimeTopology) {
      Dependency.encode(v!, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workflow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.resourceReferences.push(ResourceReferenceChoice.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.tasks.push(Task.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.taskDependencies.push(Dependency.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag === 72) {
            message.taskTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.taskTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.trigger = Trigger.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.steps.push(Step.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.inputs.push(InputType.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.outputs.push(OutputType.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.timeStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.timeEnd = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.workspaces.push(Workspace.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.runtimeTopology.push(Dependency.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workflow {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
      resourceReferences: globalThis.Array.isArray(object?.resourceReferences)
        ? object.resourceReferences.map((e: any) => ResourceReferenceChoice.fromJSON(e))
        : [],
      tasks: globalThis.Array.isArray(object?.tasks) ? object.tasks.map((e: any) => Task.fromJSON(e)) : [],
      taskDependencies: globalThis.Array.isArray(object?.taskDependencies)
        ? object.taskDependencies.map((e: any) => Dependency.fromJSON(e))
        : [],
      taskTypes: globalThis.Array.isArray(object?.taskTypes)
        ? object.taskTypes.map((e: any) => taskTypeFromJSON(e))
        : [],
      trigger: isSet(object.trigger) ? Trigger.fromJSON(object.trigger) : undefined,
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => Step.fromJSON(e)) : [],
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => InputType.fromJSON(e)) : [],
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e: any) => OutputType.fromJSON(e)) : [],
      timeStart: isSet(object.timeStart) ? fromJsonTimestamp(object.timeStart) : undefined,
      timeEnd: isSet(object.timeEnd) ? fromJsonTimestamp(object.timeEnd) : undefined,
      workspaces: globalThis.Array.isArray(object?.workspaces)
        ? object.workspaces.map((e: any) => Workspace.fromJSON(e))
        : [],
      runtimeTopology: globalThis.Array.isArray(object?.runtimeTopology)
        ? object.runtimeTopology.map((e: any) => Dependency.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Workflow): unknown {
    const obj: any = {};
    if (message.bomRef !== "") {
      obj.bomRef = message.bomRef;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    if (message.resourceReferences?.length) {
      obj.resourceReferences = message.resourceReferences.map((e) => ResourceReferenceChoice.toJSON(e));
    }
    if (message.tasks?.length) {
      obj.tasks = message.tasks.map((e) => Task.toJSON(e));
    }
    if (message.taskDependencies?.length) {
      obj.taskDependencies = message.taskDependencies.map((e) => Dependency.toJSON(e));
    }
    if (message.taskTypes?.length) {
      obj.taskTypes = message.taskTypes.map((e) => taskTypeToJSON(e));
    }
    if (message.trigger !== undefined) {
      obj.trigger = Trigger.toJSON(message.trigger);
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => Step.toJSON(e));
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => InputType.toJSON(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => OutputType.toJSON(e));
    }
    if (message.timeStart !== undefined) {
      obj.timeStart = message.timeStart.toISOString();
    }
    if (message.timeEnd !== undefined) {
      obj.timeEnd = message.timeEnd.toISOString();
    }
    if (message.workspaces?.length) {
      obj.workspaces = message.workspaces.map((e) => Workspace.toJSON(e));
    }
    if (message.runtimeTopology?.length) {
      obj.runtimeTopology = message.runtimeTopology.map((e) => Dependency.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Workflow>, I>>(base?: I): Workflow {
    return Workflow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Workflow>, I>>(object: I): Workflow {
    const message = createBaseWorkflow();
    message.bomRef = object.bomRef ?? "";
    message.uid = object.uid ?? "";
    message.name = object.name ?? undefined;
    message.description = object.description ?? undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    message.resourceReferences = object.resourceReferences?.map((e) => ResourceReferenceChoice.fromPartial(e)) || [];
    message.tasks = object.tasks?.map((e) => Task.fromPartial(e)) || [];
    message.taskDependencies = object.taskDependencies?.map((e) => Dependency.fromPartial(e)) || [];
    message.taskTypes = object.taskTypes?.map((e) => e) || [];
    message.trigger = (object.trigger !== undefined && object.trigger !== null)
      ? Trigger.fromPartial(object.trigger)
      : undefined;
    message.steps = object.steps?.map((e) => Step.fromPartial(e)) || [];
    message.inputs = object.inputs?.map((e) => InputType.fromPartial(e)) || [];
    message.outputs = object.outputs?.map((e) => OutputType.fromPartial(e)) || [];
    message.timeStart = object.timeStart ?? undefined;
    message.timeEnd = object.timeEnd ?? undefined;
    message.workspaces = object.workspaces?.map((e) => Workspace.fromPartial(e)) || [];
    message.runtimeTopology = object.runtimeTopology?.map((e) => Dependency.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTask(): Task {
  return {
    bomRef: "",
    uid: "",
    name: undefined,
    description: undefined,
    properties: [],
    resourceReferences: [],
    taskTypes: [],
    trigger: undefined,
    steps: [],
    inputs: [],
    outputs: [],
    timeStart: undefined,
    timeEnd: undefined,
    workspaces: [],
    runtimeTopology: [],
  };
}

export const Task: MessageFns<Task> = {
  encode(message: Task, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== "") {
      writer.uint32(10).string(message.bomRef);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.resourceReferences) {
      ResourceReferenceChoice.encode(v!, writer.uint32(50).fork()).join();
    }
    writer.uint32(58).fork();
    for (const v of message.taskTypes) {
      writer.int32(v);
    }
    writer.join();
    if (message.trigger !== undefined) {
      Trigger.encode(message.trigger, writer.uint32(66).fork()).join();
    }
    for (const v of message.steps) {
      Step.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.inputs) {
      InputType.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.outputs) {
      OutputType.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.timeStart !== undefined) {
      Timestamp.encode(toTimestamp(message.timeStart), writer.uint32(114).fork()).join();
    }
    if (message.timeEnd !== undefined) {
      Timestamp.encode(toTimestamp(message.timeEnd), writer.uint32(122).fork()).join();
    }
    for (const v of message.workspaces) {
      Workspace.encode(v!, writer.uint32(130).fork()).join();
    }
    for (const v of message.runtimeTopology) {
      Dependency.encode(v!, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Task {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTask();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.resourceReferences.push(ResourceReferenceChoice.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.taskTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.taskTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.trigger = Trigger.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.steps.push(Step.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.inputs.push(InputType.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.outputs.push(OutputType.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.timeStart = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.timeEnd = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.workspaces.push(Workspace.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.runtimeTopology.push(Dependency.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Task {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
      resourceReferences: globalThis.Array.isArray(object?.resourceReferences)
        ? object.resourceReferences.map((e: any) => ResourceReferenceChoice.fromJSON(e))
        : [],
      taskTypes: globalThis.Array.isArray(object?.taskTypes)
        ? object.taskTypes.map((e: any) => taskTypeFromJSON(e))
        : [],
      trigger: isSet(object.trigger) ? Trigger.fromJSON(object.trigger) : undefined,
      steps: globalThis.Array.isArray(object?.steps) ? object.steps.map((e: any) => Step.fromJSON(e)) : [],
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => InputType.fromJSON(e)) : [],
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e: any) => OutputType.fromJSON(e)) : [],
      timeStart: isSet(object.timeStart) ? fromJsonTimestamp(object.timeStart) : undefined,
      timeEnd: isSet(object.timeEnd) ? fromJsonTimestamp(object.timeEnd) : undefined,
      workspaces: globalThis.Array.isArray(object?.workspaces)
        ? object.workspaces.map((e: any) => Workspace.fromJSON(e))
        : [],
      runtimeTopology: globalThis.Array.isArray(object?.runtimeTopology)
        ? object.runtimeTopology.map((e: any) => Dependency.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Task): unknown {
    const obj: any = {};
    if (message.bomRef !== "") {
      obj.bomRef = message.bomRef;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    if (message.resourceReferences?.length) {
      obj.resourceReferences = message.resourceReferences.map((e) => ResourceReferenceChoice.toJSON(e));
    }
    if (message.taskTypes?.length) {
      obj.taskTypes = message.taskTypes.map((e) => taskTypeToJSON(e));
    }
    if (message.trigger !== undefined) {
      obj.trigger = Trigger.toJSON(message.trigger);
    }
    if (message.steps?.length) {
      obj.steps = message.steps.map((e) => Step.toJSON(e));
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => InputType.toJSON(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => OutputType.toJSON(e));
    }
    if (message.timeStart !== undefined) {
      obj.timeStart = message.timeStart.toISOString();
    }
    if (message.timeEnd !== undefined) {
      obj.timeEnd = message.timeEnd.toISOString();
    }
    if (message.workspaces?.length) {
      obj.workspaces = message.workspaces.map((e) => Workspace.toJSON(e));
    }
    if (message.runtimeTopology?.length) {
      obj.runtimeTopology = message.runtimeTopology.map((e) => Dependency.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Task>, I>>(base?: I): Task {
    return Task.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Task>, I>>(object: I): Task {
    const message = createBaseTask();
    message.bomRef = object.bomRef ?? "";
    message.uid = object.uid ?? "";
    message.name = object.name ?? undefined;
    message.description = object.description ?? undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    message.resourceReferences = object.resourceReferences?.map((e) => ResourceReferenceChoice.fromPartial(e)) || [];
    message.taskTypes = object.taskTypes?.map((e) => e) || [];
    message.trigger = (object.trigger !== undefined && object.trigger !== null)
      ? Trigger.fromPartial(object.trigger)
      : undefined;
    message.steps = object.steps?.map((e) => Step.fromPartial(e)) || [];
    message.inputs = object.inputs?.map((e) => InputType.fromPartial(e)) || [];
    message.outputs = object.outputs?.map((e) => OutputType.fromPartial(e)) || [];
    message.timeStart = object.timeStart ?? undefined;
    message.timeEnd = object.timeEnd ?? undefined;
    message.workspaces = object.workspaces?.map((e) => Workspace.fromPartial(e)) || [];
    message.runtimeTopology = object.runtimeTopology?.map((e) => Dependency.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStep(): Step {
  return { name: undefined, description: undefined, commands: [], properties: [] };
}

export const Step: MessageFns<Step> = {
  encode(message: Step, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(18).string(message.description);
    }
    for (const v of message.commands) {
      Command.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Step {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStep();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.commands.push(Command.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Step {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      commands: globalThis.Array.isArray(object?.commands) ? object.commands.map((e: any) => Command.fromJSON(e)) : [],
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Step): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.commands?.length) {
      obj.commands = message.commands.map((e) => Command.toJSON(e));
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Step>, I>>(base?: I): Step {
    return Step.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Step>, I>>(object: I): Step {
    const message = createBaseStep();
    message.name = object.name ?? undefined;
    message.description = object.description ?? undefined;
    message.commands = object.commands?.map((e) => Command.fromPartial(e)) || [];
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCommand(): Command {
  return { executed: undefined, properties: [] };
}

export const Command: MessageFns<Command> = {
  encode(message: Command, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.executed !== undefined) {
      writer.uint32(10).string(message.executed);
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Command {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.executed = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Command {
    return {
      executed: isSet(object.executed) ? globalThis.String(object.executed) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Command): unknown {
    const obj: any = {};
    if (message.executed !== undefined) {
      obj.executed = message.executed;
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Command>, I>>(base?: I): Command {
    return Command.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Command>, I>>(object: I): Command {
    const message = createBaseCommand();
    message.executed = object.executed ?? undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorkspace(): Workspace {
  return {
    bomRef: "",
    uid: "",
    name: undefined,
    aliases: [],
    description: undefined,
    properties: [],
    resourceReferences: [],
    accessMode: undefined,
    mountPath: undefined,
    managedDataType: undefined,
    volumeRequest: undefined,
    volume: undefined,
  };
}

export const Workspace: MessageFns<Workspace> = {
  encode(message: Workspace, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== "") {
      writer.uint32(10).string(message.bomRef);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    for (const v of message.aliases) {
      writer.uint32(34).string(v!);
    }
    if (message.description !== undefined) {
      writer.uint32(42).string(message.description);
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.resourceReferences) {
      ResourceReferenceChoice.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.accessMode !== undefined) {
      writer.uint32(64).int32(message.accessMode);
    }
    if (message.mountPath !== undefined) {
      writer.uint32(74).string(message.mountPath);
    }
    if (message.managedDataType !== undefined) {
      writer.uint32(82).string(message.managedDataType);
    }
    if (message.volumeRequest !== undefined) {
      writer.uint32(90).string(message.volumeRequest);
    }
    if (message.volume !== undefined) {
      Volume.encode(message.volume, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Workspace {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkspace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.aliases.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.resourceReferences.push(ResourceReferenceChoice.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.accessMode = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.mountPath = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.managedDataType = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.volumeRequest = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.volume = Volume.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Workspace {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      aliases: globalThis.Array.isArray(object?.aliases) ? object.aliases.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
      resourceReferences: globalThis.Array.isArray(object?.resourceReferences)
        ? object.resourceReferences.map((e: any) => ResourceReferenceChoice.fromJSON(e))
        : [],
      accessMode: isSet(object.accessMode) ? workspace_AccessModeFromJSON(object.accessMode) : undefined,
      mountPath: isSet(object.mountPath) ? globalThis.String(object.mountPath) : undefined,
      managedDataType: isSet(object.managedDataType) ? globalThis.String(object.managedDataType) : undefined,
      volumeRequest: isSet(object.volumeRequest) ? globalThis.String(object.volumeRequest) : undefined,
      volume: isSet(object.volume) ? Volume.fromJSON(object.volume) : undefined,
    };
  },

  toJSON(message: Workspace): unknown {
    const obj: any = {};
    if (message.bomRef !== "") {
      obj.bomRef = message.bomRef;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.aliases?.length) {
      obj.aliases = message.aliases;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    if (message.resourceReferences?.length) {
      obj.resourceReferences = message.resourceReferences.map((e) => ResourceReferenceChoice.toJSON(e));
    }
    if (message.accessMode !== undefined) {
      obj.accessMode = workspace_AccessModeToJSON(message.accessMode);
    }
    if (message.mountPath !== undefined) {
      obj.mountPath = message.mountPath;
    }
    if (message.managedDataType !== undefined) {
      obj.managedDataType = message.managedDataType;
    }
    if (message.volumeRequest !== undefined) {
      obj.volumeRequest = message.volumeRequest;
    }
    if (message.volume !== undefined) {
      obj.volume = Volume.toJSON(message.volume);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Workspace>, I>>(base?: I): Workspace {
    return Workspace.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Workspace>, I>>(object: I): Workspace {
    const message = createBaseWorkspace();
    message.bomRef = object.bomRef ?? "";
    message.uid = object.uid ?? "";
    message.name = object.name ?? undefined;
    message.aliases = object.aliases?.map((e) => e) || [];
    message.description = object.description ?? undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    message.resourceReferences = object.resourceReferences?.map((e) => ResourceReferenceChoice.fromPartial(e)) || [];
    message.accessMode = object.accessMode ?? undefined;
    message.mountPath = object.mountPath ?? undefined;
    message.managedDataType = object.managedDataType ?? undefined;
    message.volumeRequest = object.volumeRequest ?? undefined;
    message.volume = (object.volume !== undefined && object.volume !== null)
      ? Volume.fromPartial(object.volume)
      : undefined;
    return message;
  },
};

function createBaseVolume(): Volume {
  return {
    uid: undefined,
    name: undefined,
    mode: undefined,
    path: undefined,
    sizeAllocated: undefined,
    persistent: undefined,
    remote: undefined,
    properties: [],
  };
}

export const Volume: MessageFns<Volume> = {
  encode(message: Volume, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== undefined) {
      writer.uint32(10).string(message.uid);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.mode !== undefined) {
      writer.uint32(24).int32(message.mode);
    }
    if (message.path !== undefined) {
      writer.uint32(34).string(message.path);
    }
    if (message.sizeAllocated !== undefined) {
      writer.uint32(42).string(message.sizeAllocated);
    }
    if (message.persistent !== undefined) {
      writer.uint32(48).bool(message.persistent);
    }
    if (message.remote !== undefined) {
      writer.uint32(56).bool(message.remote);
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Volume {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVolume();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sizeAllocated = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.persistent = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.remote = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Volume {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      mode: isSet(object.mode) ? volume_VolumeModeFromJSON(object.mode) : undefined,
      path: isSet(object.path) ? globalThis.String(object.path) : undefined,
      sizeAllocated: isSet(object.sizeAllocated) ? globalThis.String(object.sizeAllocated) : undefined,
      persistent: isSet(object.persistent) ? globalThis.Boolean(object.persistent) : undefined,
      remote: isSet(object.remote) ? globalThis.Boolean(object.remote) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Volume): unknown {
    const obj: any = {};
    if (message.uid !== undefined) {
      obj.uid = message.uid;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.mode !== undefined) {
      obj.mode = volume_VolumeModeToJSON(message.mode);
    }
    if (message.path !== undefined) {
      obj.path = message.path;
    }
    if (message.sizeAllocated !== undefined) {
      obj.sizeAllocated = message.sizeAllocated;
    }
    if (message.persistent !== undefined) {
      obj.persistent = message.persistent;
    }
    if (message.remote !== undefined) {
      obj.remote = message.remote;
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Volume>, I>>(base?: I): Volume {
    return Volume.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Volume>, I>>(object: I): Volume {
    const message = createBaseVolume();
    message.uid = object.uid ?? undefined;
    message.name = object.name ?? undefined;
    message.mode = object.mode ?? undefined;
    message.path = object.path ?? undefined;
    message.sizeAllocated = object.sizeAllocated ?? undefined;
    message.persistent = object.persistent ?? undefined;
    message.remote = object.remote ?? undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTrigger(): Trigger {
  return {
    bomRef: "",
    uid: "",
    name: undefined,
    description: undefined,
    properties: [],
    resourceReferences: [],
    type: 0,
    event: undefined,
    conditions: [],
    timeActivated: undefined,
    inputs: [],
    outputs: [],
  };
}

export const Trigger: MessageFns<Trigger> = {
  encode(message: Trigger, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== "") {
      writer.uint32(10).string(message.bomRef);
    }
    if (message.uid !== "") {
      writer.uint32(18).string(message.uid);
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.resourceReferences) {
      ResourceReferenceChoice.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(56).int32(message.type);
    }
    if (message.event !== undefined) {
      Event.encode(message.event, writer.uint32(66).fork()).join();
    }
    for (const v of message.conditions) {
      Condition.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.timeActivated !== undefined) {
      Timestamp.encode(toTimestamp(message.timeActivated), writer.uint32(82).fork()).join();
    }
    for (const v of message.inputs) {
      InputType.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.outputs) {
      OutputType.encode(v!, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trigger {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrigger();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.resourceReferences.push(ResourceReferenceChoice.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.event = Event.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.conditions.push(Condition.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.timeActivated = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.inputs.push(InputType.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.outputs.push(OutputType.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trigger {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : "",
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
      resourceReferences: globalThis.Array.isArray(object?.resourceReferences)
        ? object.resourceReferences.map((e: any) => ResourceReferenceChoice.fromJSON(e))
        : [],
      type: isSet(object.type) ? trigger_TriggerTypeFromJSON(object.type) : 0,
      event: isSet(object.event) ? Event.fromJSON(object.event) : undefined,
      conditions: globalThis.Array.isArray(object?.conditions)
        ? object.conditions.map((e: any) => Condition.fromJSON(e))
        : [],
      timeActivated: isSet(object.timeActivated) ? fromJsonTimestamp(object.timeActivated) : undefined,
      inputs: globalThis.Array.isArray(object?.inputs) ? object.inputs.map((e: any) => InputType.fromJSON(e)) : [],
      outputs: globalThis.Array.isArray(object?.outputs) ? object.outputs.map((e: any) => OutputType.fromJSON(e)) : [],
    };
  },

  toJSON(message: Trigger): unknown {
    const obj: any = {};
    if (message.bomRef !== "") {
      obj.bomRef = message.bomRef;
    }
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    if (message.resourceReferences?.length) {
      obj.resourceReferences = message.resourceReferences.map((e) => ResourceReferenceChoice.toJSON(e));
    }
    if (message.type !== 0) {
      obj.type = trigger_TriggerTypeToJSON(message.type);
    }
    if (message.event !== undefined) {
      obj.event = Event.toJSON(message.event);
    }
    if (message.conditions?.length) {
      obj.conditions = message.conditions.map((e) => Condition.toJSON(e));
    }
    if (message.timeActivated !== undefined) {
      obj.timeActivated = message.timeActivated.toISOString();
    }
    if (message.inputs?.length) {
      obj.inputs = message.inputs.map((e) => InputType.toJSON(e));
    }
    if (message.outputs?.length) {
      obj.outputs = message.outputs.map((e) => OutputType.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trigger>, I>>(base?: I): Trigger {
    return Trigger.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trigger>, I>>(object: I): Trigger {
    const message = createBaseTrigger();
    message.bomRef = object.bomRef ?? "";
    message.uid = object.uid ?? "";
    message.name = object.name ?? undefined;
    message.description = object.description ?? undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    message.resourceReferences = object.resourceReferences?.map((e) => ResourceReferenceChoice.fromPartial(e)) || [];
    message.type = object.type ?? 0;
    message.event = (object.event !== undefined && object.event !== null) ? Event.fromPartial(object.event) : undefined;
    message.conditions = object.conditions?.map((e) => Condition.fromPartial(e)) || [];
    message.timeActivated = object.timeActivated ?? undefined;
    message.inputs = object.inputs?.map((e) => InputType.fromPartial(e)) || [];
    message.outputs = object.outputs?.map((e) => OutputType.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEvent(): Event {
  return {
    uid: undefined,
    description: undefined,
    timeReceived: undefined,
    data: undefined,
    source: undefined,
    target: undefined,
    properties: [],
  };
}

export const Event: MessageFns<Event> = {
  encode(message: Event, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== undefined) {
      writer.uint32(10).string(message.uid);
    }
    if (message.description !== undefined) {
      writer.uint32(18).string(message.description);
    }
    if (message.timeReceived !== undefined) {
      Timestamp.encode(toTimestamp(message.timeReceived), writer.uint32(26).fork()).join();
    }
    if (message.data !== undefined) {
      AttachedText.encode(message.data, writer.uint32(34).fork()).join();
    }
    if (message.source !== undefined) {
      ResourceReferenceChoice.encode(message.source, writer.uint32(42).fork()).join();
    }
    if (message.target !== undefined) {
      ResourceReferenceChoice.encode(message.target, writer.uint32(50).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Event {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timeReceived = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data = AttachedText.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.source = ResourceReferenceChoice.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.target = ResourceReferenceChoice.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Event {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      timeReceived: isSet(object.timeReceived) ? fromJsonTimestamp(object.timeReceived) : undefined,
      data: isSet(object.data) ? AttachedText.fromJSON(object.data) : undefined,
      source: isSet(object.source) ? ResourceReferenceChoice.fromJSON(object.source) : undefined,
      target: isSet(object.target) ? ResourceReferenceChoice.fromJSON(object.target) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Event): unknown {
    const obj: any = {};
    if (message.uid !== undefined) {
      obj.uid = message.uid;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.timeReceived !== undefined) {
      obj.timeReceived = message.timeReceived.toISOString();
    }
    if (message.data !== undefined) {
      obj.data = AttachedText.toJSON(message.data);
    }
    if (message.source !== undefined) {
      obj.source = ResourceReferenceChoice.toJSON(message.source);
    }
    if (message.target !== undefined) {
      obj.target = ResourceReferenceChoice.toJSON(message.target);
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Event>, I>>(base?: I): Event {
    return Event.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Event>, I>>(object: I): Event {
    const message = createBaseEvent();
    message.uid = object.uid ?? undefined;
    message.description = object.description ?? undefined;
    message.timeReceived = object.timeReceived ?? undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? AttachedText.fromPartial(object.data)
      : undefined;
    message.source = (object.source !== undefined && object.source !== null)
      ? ResourceReferenceChoice.fromPartial(object.source)
      : undefined;
    message.target = (object.target !== undefined && object.target !== null)
      ? ResourceReferenceChoice.fromPartial(object.target)
      : undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInputType(): InputType {
  return {
    source: undefined,
    target: undefined,
    resource: undefined,
    parameters: [],
    environmentVars: [],
    data: undefined,
    properties: [],
  };
}

export const InputType: MessageFns<InputType> = {
  encode(message: InputType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      ResourceReferenceChoice.encode(message.source, writer.uint32(10).fork()).join();
    }
    if (message.target !== undefined) {
      ResourceReferenceChoice.encode(message.target, writer.uint32(18).fork()).join();
    }
    if (message.resource !== undefined) {
      ResourceReferenceChoice.encode(message.resource, writer.uint32(26).fork()).join();
    }
    for (const v of message.parameters) {
      Parameter.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.environmentVars) {
      EnvironmentVars.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.data !== undefined) {
      AttachedText.encode(message.data, writer.uint32(50).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InputType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInputType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = ResourceReferenceChoice.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.target = ResourceReferenceChoice.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resource = ResourceReferenceChoice.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parameters.push(Parameter.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.environmentVars.push(EnvironmentVars.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.data = AttachedText.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InputType {
    return {
      source: isSet(object.source) ? ResourceReferenceChoice.fromJSON(object.source) : undefined,
      target: isSet(object.target) ? ResourceReferenceChoice.fromJSON(object.target) : undefined,
      resource: isSet(object.resource) ? ResourceReferenceChoice.fromJSON(object.resource) : undefined,
      parameters: globalThis.Array.isArray(object?.parameters)
        ? object.parameters.map((e: any) => Parameter.fromJSON(e))
        : [],
      environmentVars: globalThis.Array.isArray(object?.environmentVars)
        ? object.environmentVars.map((e: any) => EnvironmentVars.fromJSON(e))
        : [],
      data: isSet(object.data) ? AttachedText.fromJSON(object.data) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
    };
  },

  toJSON(message: InputType): unknown {
    const obj: any = {};
    if (message.source !== undefined) {
      obj.source = ResourceReferenceChoice.toJSON(message.source);
    }
    if (message.target !== undefined) {
      obj.target = ResourceReferenceChoice.toJSON(message.target);
    }
    if (message.resource !== undefined) {
      obj.resource = ResourceReferenceChoice.toJSON(message.resource);
    }
    if (message.parameters?.length) {
      obj.parameters = message.parameters.map((e) => Parameter.toJSON(e));
    }
    if (message.environmentVars?.length) {
      obj.environmentVars = message.environmentVars.map((e) => EnvironmentVars.toJSON(e));
    }
    if (message.data !== undefined) {
      obj.data = AttachedText.toJSON(message.data);
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InputType>, I>>(base?: I): InputType {
    return InputType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InputType>, I>>(object: I): InputType {
    const message = createBaseInputType();
    message.source = (object.source !== undefined && object.source !== null)
      ? ResourceReferenceChoice.fromPartial(object.source)
      : undefined;
    message.target = (object.target !== undefined && object.target !== null)
      ? ResourceReferenceChoice.fromPartial(object.target)
      : undefined;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? ResourceReferenceChoice.fromPartial(object.resource)
      : undefined;
    message.parameters = object.parameters?.map((e) => Parameter.fromPartial(e)) || [];
    message.environmentVars = object.environmentVars?.map((e) => EnvironmentVars.fromPartial(e)) || [];
    message.data = (object.data !== undefined && object.data !== null)
      ? AttachedText.fromPartial(object.data)
      : undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOutputType(): OutputType {
  return {
    type: undefined,
    source: undefined,
    target: undefined,
    resource: undefined,
    data: undefined,
    environmentVars: [],
    properties: [],
  };
}

export const OutputType: MessageFns<OutputType> = {
  encode(message: OutputType, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== undefined) {
      writer.uint32(8).int32(message.type);
    }
    if (message.source !== undefined) {
      ResourceReferenceChoice.encode(message.source, writer.uint32(18).fork()).join();
    }
    if (message.target !== undefined) {
      ResourceReferenceChoice.encode(message.target, writer.uint32(26).fork()).join();
    }
    if (message.resource !== undefined) {
      ResourceReferenceChoice.encode(message.resource, writer.uint32(34).fork()).join();
    }
    if (message.data !== undefined) {
      AttachedText.encode(message.data, writer.uint32(42).fork()).join();
    }
    for (const v of message.environmentVars) {
      EnvironmentVars.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OutputType {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutputType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.source = ResourceReferenceChoice.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.target = ResourceReferenceChoice.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resource = ResourceReferenceChoice.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.data = AttachedText.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.environmentVars.push(EnvironmentVars.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OutputType {
    return {
      type: isSet(object.type) ? outputType_OutputTypeTypeFromJSON(object.type) : undefined,
      source: isSet(object.source) ? ResourceReferenceChoice.fromJSON(object.source) : undefined,
      target: isSet(object.target) ? ResourceReferenceChoice.fromJSON(object.target) : undefined,
      resource: isSet(object.resource) ? ResourceReferenceChoice.fromJSON(object.resource) : undefined,
      data: isSet(object.data) ? AttachedText.fromJSON(object.data) : undefined,
      environmentVars: globalThis.Array.isArray(object?.environmentVars)
        ? object.environmentVars.map((e: any) => EnvironmentVars.fromJSON(e))
        : [],
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OutputType): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = outputType_OutputTypeTypeToJSON(message.type);
    }
    if (message.source !== undefined) {
      obj.source = ResourceReferenceChoice.toJSON(message.source);
    }
    if (message.target !== undefined) {
      obj.target = ResourceReferenceChoice.toJSON(message.target);
    }
    if (message.resource !== undefined) {
      obj.resource = ResourceReferenceChoice.toJSON(message.resource);
    }
    if (message.data !== undefined) {
      obj.data = AttachedText.toJSON(message.data);
    }
    if (message.environmentVars?.length) {
      obj.environmentVars = message.environmentVars.map((e) => EnvironmentVars.toJSON(e));
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OutputType>, I>>(base?: I): OutputType {
    return OutputType.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OutputType>, I>>(object: I): OutputType {
    const message = createBaseOutputType();
    message.type = object.type ?? undefined;
    message.source = (object.source !== undefined && object.source !== null)
      ? ResourceReferenceChoice.fromPartial(object.source)
      : undefined;
    message.target = (object.target !== undefined && object.target !== null)
      ? ResourceReferenceChoice.fromPartial(object.target)
      : undefined;
    message.resource = (object.resource !== undefined && object.resource !== null)
      ? ResourceReferenceChoice.fromPartial(object.resource)
      : undefined;
    message.data = (object.data !== undefined && object.data !== null)
      ? AttachedText.fromPartial(object.data)
      : undefined;
    message.environmentVars = object.environmentVars?.map((e) => EnvironmentVars.fromPartial(e)) || [];
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResourceReferenceChoice(): ResourceReferenceChoice {
  return { ref: undefined, externalReference: undefined };
}

export const ResourceReferenceChoice: MessageFns<ResourceReferenceChoice> = {
  encode(message: ResourceReferenceChoice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ref !== undefined) {
      writer.uint32(10).string(message.ref);
    }
    if (message.externalReference !== undefined) {
      ExternalReference.encode(message.externalReference, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceReferenceChoice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceReferenceChoice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ref = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.externalReference = ExternalReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceReferenceChoice {
    return {
      ref: isSet(object.ref) ? globalThis.String(object.ref) : undefined,
      externalReference: isSet(object.externalReference)
        ? ExternalReference.fromJSON(object.externalReference)
        : undefined,
    };
  },

  toJSON(message: ResourceReferenceChoice): unknown {
    const obj: any = {};
    if (message.ref !== undefined) {
      obj.ref = message.ref;
    }
    if (message.externalReference !== undefined) {
      obj.externalReference = ExternalReference.toJSON(message.externalReference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResourceReferenceChoice>, I>>(base?: I): ResourceReferenceChoice {
    return ResourceReferenceChoice.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResourceReferenceChoice>, I>>(object: I): ResourceReferenceChoice {
    const message = createBaseResourceReferenceChoice();
    message.ref = object.ref ?? undefined;
    message.externalReference = (object.externalReference !== undefined && object.externalReference !== null)
      ? ExternalReference.fromPartial(object.externalReference)
      : undefined;
    return message;
  },
};

function createBaseCondition(): Condition {
  return { description: undefined, expression: undefined, properties: [] };
}

export const Condition: MessageFns<Condition> = {
  encode(message: Condition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== undefined) {
      writer.uint32(10).string(message.description);
    }
    if (message.expression !== undefined) {
      writer.uint32(18).string(message.expression);
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Condition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expression = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Condition {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      expression: isSet(object.expression) ? globalThis.String(object.expression) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Condition): unknown {
    const obj: any = {};
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.expression !== undefined) {
      obj.expression = message.expression;
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Condition>, I>>(base?: I): Condition {
    return Condition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Condition>, I>>(object: I): Condition {
    const message = createBaseCondition();
    message.description = object.description ?? undefined;
    message.expression = object.expression ?? undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    return message;
  },
};

function createBaseParameter(): Parameter {
  return { name: undefined, value: undefined, dataType: undefined };
}

export const Parameter: MessageFns<Parameter> = {
  encode(message: Parameter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      writer.uint32(18).string(message.value);
    }
    if (message.dataType !== undefined) {
      writer.uint32(26).string(message.dataType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Parameter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dataType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Parameter {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
      dataType: isSet(object.dataType) ? globalThis.String(object.dataType) : undefined,
    };
  },

  toJSON(message: Parameter): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.dataType !== undefined) {
      obj.dataType = message.dataType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Parameter>, I>>(base?: I): Parameter {
    return Parameter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Parameter>, I>>(object: I): Parameter {
    const message = createBaseParameter();
    message.name = object.name ?? undefined;
    message.value = object.value ?? undefined;
    message.dataType = object.dataType ?? undefined;
    return message;
  },
};

function createBaseEnvironmentVars(): EnvironmentVars {
  return { property: undefined, value: undefined };
}

export const EnvironmentVars: MessageFns<EnvironmentVars> = {
  encode(message: EnvironmentVars, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.property !== undefined) {
      Property.encode(message.property, writer.uint32(10).fork()).join();
    }
    if (message.value !== undefined) {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnvironmentVars {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvironmentVars();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.property = Property.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnvironmentVars {
    return {
      property: isSet(object.property) ? Property.fromJSON(object.property) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
    };
  },

  toJSON(message: EnvironmentVars): unknown {
    const obj: any = {};
    if (message.property !== undefined) {
      obj.property = Property.toJSON(message.property);
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnvironmentVars>, I>>(base?: I): EnvironmentVars {
    return EnvironmentVars.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnvironmentVars>, I>>(object: I): EnvironmentVars {
    const message = createBaseEnvironmentVars();
    message.property = (object.property !== undefined && object.property !== null)
      ? Property.fromPartial(object.property)
      : undefined;
    message.value = object.value ?? undefined;
    return message;
  },
};

function createBaseDeclarations(): Declarations {
  return { assessors: [], attestations: [], claims: [], evidence: [], targets: undefined, affirmation: undefined };
}

export const Declarations: MessageFns<Declarations> = {
  encode(message: Declarations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.assessors) {
      Declarations_Assessor.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.attestations) {
      Declarations_Attestation.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.claims) {
      Declarations_Claim.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.evidence) {
      Declarations_Evidence.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.targets !== undefined) {
      Declarations_Targets.encode(message.targets, writer.uint32(42).fork()).join();
    }
    if (message.affirmation !== undefined) {
      Declarations_Affirmation.encode(message.affirmation, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Declarations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclarations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assessors.push(Declarations_Assessor.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.attestations.push(Declarations_Attestation.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.claims.push(Declarations_Claim.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.evidence.push(Declarations_Evidence.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.targets = Declarations_Targets.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.affirmation = Declarations_Affirmation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Declarations {
    return {
      assessors: globalThis.Array.isArray(object?.assessors)
        ? object.assessors.map((e: any) => Declarations_Assessor.fromJSON(e))
        : [],
      attestations: globalThis.Array.isArray(object?.attestations)
        ? object.attestations.map((e: any) => Declarations_Attestation.fromJSON(e))
        : [],
      claims: globalThis.Array.isArray(object?.claims)
        ? object.claims.map((e: any) => Declarations_Claim.fromJSON(e))
        : [],
      evidence: globalThis.Array.isArray(object?.evidence)
        ? object.evidence.map((e: any) => Declarations_Evidence.fromJSON(e))
        : [],
      targets: isSet(object.targets) ? Declarations_Targets.fromJSON(object.targets) : undefined,
      affirmation: isSet(object.affirmation) ? Declarations_Affirmation.fromJSON(object.affirmation) : undefined,
    };
  },

  toJSON(message: Declarations): unknown {
    const obj: any = {};
    if (message.assessors?.length) {
      obj.assessors = message.assessors.map((e) => Declarations_Assessor.toJSON(e));
    }
    if (message.attestations?.length) {
      obj.attestations = message.attestations.map((e) => Declarations_Attestation.toJSON(e));
    }
    if (message.claims?.length) {
      obj.claims = message.claims.map((e) => Declarations_Claim.toJSON(e));
    }
    if (message.evidence?.length) {
      obj.evidence = message.evidence.map((e) => Declarations_Evidence.toJSON(e));
    }
    if (message.targets !== undefined) {
      obj.targets = Declarations_Targets.toJSON(message.targets);
    }
    if (message.affirmation !== undefined) {
      obj.affirmation = Declarations_Affirmation.toJSON(message.affirmation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Declarations>, I>>(base?: I): Declarations {
    return Declarations.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Declarations>, I>>(object: I): Declarations {
    const message = createBaseDeclarations();
    message.assessors = object.assessors?.map((e) => Declarations_Assessor.fromPartial(e)) || [];
    message.attestations = object.attestations?.map((e) => Declarations_Attestation.fromPartial(e)) || [];
    message.claims = object.claims?.map((e) => Declarations_Claim.fromPartial(e)) || [];
    message.evidence = object.evidence?.map((e) => Declarations_Evidence.fromPartial(e)) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Declarations_Targets.fromPartial(object.targets)
      : undefined;
    message.affirmation = (object.affirmation !== undefined && object.affirmation !== null)
      ? Declarations_Affirmation.fromPartial(object.affirmation)
      : undefined;
    return message;
  },
};

function createBaseDeclarations_Assessor(): Declarations_Assessor {
  return { bomRef: undefined, thirdParty: undefined, organization: undefined };
}

export const Declarations_Assessor: MessageFns<Declarations_Assessor> = {
  encode(message: Declarations_Assessor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== undefined) {
      writer.uint32(10).string(message.bomRef);
    }
    if (message.thirdParty !== undefined) {
      writer.uint32(16).bool(message.thirdParty);
    }
    if (message.organization !== undefined) {
      OrganizationalEntity.encode(message.organization, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Declarations_Assessor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclarations_Assessor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.thirdParty = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.organization = OrganizationalEntity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Declarations_Assessor {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      thirdParty: isSet(object.thirdParty) ? globalThis.Boolean(object.thirdParty) : undefined,
      organization: isSet(object.organization) ? OrganizationalEntity.fromJSON(object.organization) : undefined,
    };
  },

  toJSON(message: Declarations_Assessor): unknown {
    const obj: any = {};
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.thirdParty !== undefined) {
      obj.thirdParty = message.thirdParty;
    }
    if (message.organization !== undefined) {
      obj.organization = OrganizationalEntity.toJSON(message.organization);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Declarations_Assessor>, I>>(base?: I): Declarations_Assessor {
    return Declarations_Assessor.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Declarations_Assessor>, I>>(object: I): Declarations_Assessor {
    const message = createBaseDeclarations_Assessor();
    message.bomRef = object.bomRef ?? undefined;
    message.thirdParty = object.thirdParty ?? undefined;
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? OrganizationalEntity.fromPartial(object.organization)
      : undefined;
    return message;
  },
};

function createBaseDeclarations_Attestation(): Declarations_Attestation {
  return { summary: undefined, assessor: undefined, map: [] };
}

export const Declarations_Attestation: MessageFns<Declarations_Attestation> = {
  encode(message: Declarations_Attestation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.summary !== undefined) {
      writer.uint32(10).string(message.summary);
    }
    if (message.assessor !== undefined) {
      writer.uint32(18).string(message.assessor);
    }
    for (const v of message.map) {
      Declarations_Attestation_AttestationMap.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Declarations_Attestation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclarations_Attestation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.assessor = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.map.push(Declarations_Attestation_AttestationMap.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Declarations_Attestation {
    return {
      summary: isSet(object.summary) ? globalThis.String(object.summary) : undefined,
      assessor: isSet(object.assessor) ? globalThis.String(object.assessor) : undefined,
      map: globalThis.Array.isArray(object?.map)
        ? object.map.map((e: any) => Declarations_Attestation_AttestationMap.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Declarations_Attestation): unknown {
    const obj: any = {};
    if (message.summary !== undefined) {
      obj.summary = message.summary;
    }
    if (message.assessor !== undefined) {
      obj.assessor = message.assessor;
    }
    if (message.map?.length) {
      obj.map = message.map.map((e) => Declarations_Attestation_AttestationMap.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Declarations_Attestation>, I>>(base?: I): Declarations_Attestation {
    return Declarations_Attestation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Declarations_Attestation>, I>>(object: I): Declarations_Attestation {
    const message = createBaseDeclarations_Attestation();
    message.summary = object.summary ?? undefined;
    message.assessor = object.assessor ?? undefined;
    message.map = object.map?.map((e) => Declarations_Attestation_AttestationMap.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeclarations_Attestation_AttestationMap(): Declarations_Attestation_AttestationMap {
  return { requirement: undefined, claims: [], counterClaims: [], conformance: undefined, confidence: undefined };
}

export const Declarations_Attestation_AttestationMap: MessageFns<Declarations_Attestation_AttestationMap> = {
  encode(message: Declarations_Attestation_AttestationMap, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requirement !== undefined) {
      writer.uint32(10).string(message.requirement);
    }
    for (const v of message.claims) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.counterClaims) {
      writer.uint32(26).string(v!);
    }
    if (message.conformance !== undefined) {
      Declarations_Attestation_AttestationMap_AttestationConformance.encode(
        message.conformance,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.confidence !== undefined) {
      Declarations_Attestation_AttestationMap_AttestationConfidence.encode(message.confidence, writer.uint32(42).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Declarations_Attestation_AttestationMap {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclarations_Attestation_AttestationMap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requirement = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.claims.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.counterClaims.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.conformance = Declarations_Attestation_AttestationMap_AttestationConformance.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.confidence = Declarations_Attestation_AttestationMap_AttestationConfidence.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Declarations_Attestation_AttestationMap {
    return {
      requirement: isSet(object.requirement) ? globalThis.String(object.requirement) : undefined,
      claims: globalThis.Array.isArray(object?.claims) ? object.claims.map((e: any) => globalThis.String(e)) : [],
      counterClaims: globalThis.Array.isArray(object?.counterClaims)
        ? object.counterClaims.map((e: any) => globalThis.String(e))
        : [],
      conformance: isSet(object.conformance)
        ? Declarations_Attestation_AttestationMap_AttestationConformance.fromJSON(object.conformance)
        : undefined,
      confidence: isSet(object.confidence)
        ? Declarations_Attestation_AttestationMap_AttestationConfidence.fromJSON(object.confidence)
        : undefined,
    };
  },

  toJSON(message: Declarations_Attestation_AttestationMap): unknown {
    const obj: any = {};
    if (message.requirement !== undefined) {
      obj.requirement = message.requirement;
    }
    if (message.claims?.length) {
      obj.claims = message.claims;
    }
    if (message.counterClaims?.length) {
      obj.counterClaims = message.counterClaims;
    }
    if (message.conformance !== undefined) {
      obj.conformance = Declarations_Attestation_AttestationMap_AttestationConformance.toJSON(message.conformance);
    }
    if (message.confidence !== undefined) {
      obj.confidence = Declarations_Attestation_AttestationMap_AttestationConfidence.toJSON(message.confidence);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Declarations_Attestation_AttestationMap>, I>>(
    base?: I,
  ): Declarations_Attestation_AttestationMap {
    return Declarations_Attestation_AttestationMap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Declarations_Attestation_AttestationMap>, I>>(
    object: I,
  ): Declarations_Attestation_AttestationMap {
    const message = createBaseDeclarations_Attestation_AttestationMap();
    message.requirement = object.requirement ?? undefined;
    message.claims = object.claims?.map((e) => e) || [];
    message.counterClaims = object.counterClaims?.map((e) => e) || [];
    message.conformance = (object.conformance !== undefined && object.conformance !== null)
      ? Declarations_Attestation_AttestationMap_AttestationConformance.fromPartial(object.conformance)
      : undefined;
    message.confidence = (object.confidence !== undefined && object.confidence !== null)
      ? Declarations_Attestation_AttestationMap_AttestationConfidence.fromPartial(object.confidence)
      : undefined;
    return message;
  },
};

function createBaseDeclarations_Attestation_AttestationMap_AttestationConformance(): Declarations_Attestation_AttestationMap_AttestationConformance {
  return { score: undefined, rationale: undefined, mitigationStrategies: [] };
}

export const Declarations_Attestation_AttestationMap_AttestationConformance: MessageFns<
  Declarations_Attestation_AttestationMap_AttestationConformance
> = {
  encode(
    message: Declarations_Attestation_AttestationMap_AttestationConformance,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(9).double(message.score);
    }
    if (message.rationale !== undefined) {
      writer.uint32(18).string(message.rationale);
    }
    for (const v of message.mitigationStrategies) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Declarations_Attestation_AttestationMap_AttestationConformance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclarations_Attestation_AttestationMap_AttestationConformance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.score = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rationale = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mitigationStrategies.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Declarations_Attestation_AttestationMap_AttestationConformance {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      rationale: isSet(object.rationale) ? globalThis.String(object.rationale) : undefined,
      mitigationStrategies: globalThis.Array.isArray(object?.mitigationStrategies)
        ? object.mitigationStrategies.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Declarations_Attestation_AttestationMap_AttestationConformance): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.rationale !== undefined) {
      obj.rationale = message.rationale;
    }
    if (message.mitigationStrategies?.length) {
      obj.mitigationStrategies = message.mitigationStrategies;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Declarations_Attestation_AttestationMap_AttestationConformance>, I>>(
    base?: I,
  ): Declarations_Attestation_AttestationMap_AttestationConformance {
    return Declarations_Attestation_AttestationMap_AttestationConformance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Declarations_Attestation_AttestationMap_AttestationConformance>, I>>(
    object: I,
  ): Declarations_Attestation_AttestationMap_AttestationConformance {
    const message = createBaseDeclarations_Attestation_AttestationMap_AttestationConformance();
    message.score = object.score ?? undefined;
    message.rationale = object.rationale ?? undefined;
    message.mitigationStrategies = object.mitigationStrategies?.map((e) => e) || [];
    return message;
  },
};

function createBaseDeclarations_Attestation_AttestationMap_AttestationConfidence(): Declarations_Attestation_AttestationMap_AttestationConfidence {
  return { score: undefined, rationale: undefined };
}

export const Declarations_Attestation_AttestationMap_AttestationConfidence: MessageFns<
  Declarations_Attestation_AttestationMap_AttestationConfidence
> = {
  encode(
    message: Declarations_Attestation_AttestationMap_AttestationConfidence,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.score !== undefined) {
      writer.uint32(9).double(message.score);
    }
    if (message.rationale !== undefined) {
      writer.uint32(18).string(message.rationale);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Declarations_Attestation_AttestationMap_AttestationConfidence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclarations_Attestation_AttestationMap_AttestationConfidence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.score = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rationale = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Declarations_Attestation_AttestationMap_AttestationConfidence {
    return {
      score: isSet(object.score) ? globalThis.Number(object.score) : undefined,
      rationale: isSet(object.rationale) ? globalThis.String(object.rationale) : undefined,
    };
  },

  toJSON(message: Declarations_Attestation_AttestationMap_AttestationConfidence): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = message.score;
    }
    if (message.rationale !== undefined) {
      obj.rationale = message.rationale;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Declarations_Attestation_AttestationMap_AttestationConfidence>, I>>(
    base?: I,
  ): Declarations_Attestation_AttestationMap_AttestationConfidence {
    return Declarations_Attestation_AttestationMap_AttestationConfidence.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Declarations_Attestation_AttestationMap_AttestationConfidence>, I>>(
    object: I,
  ): Declarations_Attestation_AttestationMap_AttestationConfidence {
    const message = createBaseDeclarations_Attestation_AttestationMap_AttestationConfidence();
    message.score = object.score ?? undefined;
    message.rationale = object.rationale ?? undefined;
    return message;
  },
};

function createBaseDeclarations_Claim(): Declarations_Claim {
  return {
    bomRef: undefined,
    target: undefined,
    predicate: undefined,
    mitigationStrategies: [],
    reasoning: undefined,
    evidence: [],
    counterEvidence: [],
    externalReferences: [],
  };
}

export const Declarations_Claim: MessageFns<Declarations_Claim> = {
  encode(message: Declarations_Claim, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== undefined) {
      writer.uint32(10).string(message.bomRef);
    }
    if (message.target !== undefined) {
      writer.uint32(18).string(message.target);
    }
    if (message.predicate !== undefined) {
      writer.uint32(26).string(message.predicate);
    }
    for (const v of message.mitigationStrategies) {
      writer.uint32(34).string(v!);
    }
    if (message.reasoning !== undefined) {
      writer.uint32(42).string(message.reasoning);
    }
    for (const v of message.evidence) {
      writer.uint32(50).string(v!);
    }
    for (const v of message.counterEvidence) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.externalReferences) {
      ExternalReference.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Declarations_Claim {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclarations_Claim();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.target = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.predicate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mitigationStrategies.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reasoning = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.evidence.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.counterEvidence.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.externalReferences.push(ExternalReference.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Declarations_Claim {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      target: isSet(object.target) ? globalThis.String(object.target) : undefined,
      predicate: isSet(object.predicate) ? globalThis.String(object.predicate) : undefined,
      mitigationStrategies: globalThis.Array.isArray(object?.mitigationStrategies)
        ? object.mitigationStrategies.map((e: any) => globalThis.String(e))
        : [],
      reasoning: isSet(object.reasoning) ? globalThis.String(object.reasoning) : undefined,
      evidence: globalThis.Array.isArray(object?.evidence) ? object.evidence.map((e: any) => globalThis.String(e)) : [],
      counterEvidence: globalThis.Array.isArray(object?.counterEvidence)
        ? object.counterEvidence.map((e: any) => globalThis.String(e))
        : [],
      externalReferences: globalThis.Array.isArray(object?.externalReferences)
        ? object.externalReferences.map((e: any) => ExternalReference.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Declarations_Claim): unknown {
    const obj: any = {};
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.target !== undefined) {
      obj.target = message.target;
    }
    if (message.predicate !== undefined) {
      obj.predicate = message.predicate;
    }
    if (message.mitigationStrategies?.length) {
      obj.mitigationStrategies = message.mitigationStrategies;
    }
    if (message.reasoning !== undefined) {
      obj.reasoning = message.reasoning;
    }
    if (message.evidence?.length) {
      obj.evidence = message.evidence;
    }
    if (message.counterEvidence?.length) {
      obj.counterEvidence = message.counterEvidence;
    }
    if (message.externalReferences?.length) {
      obj.externalReferences = message.externalReferences.map((e) => ExternalReference.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Declarations_Claim>, I>>(base?: I): Declarations_Claim {
    return Declarations_Claim.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Declarations_Claim>, I>>(object: I): Declarations_Claim {
    const message = createBaseDeclarations_Claim();
    message.bomRef = object.bomRef ?? undefined;
    message.target = object.target ?? undefined;
    message.predicate = object.predicate ?? undefined;
    message.mitigationStrategies = object.mitigationStrategies?.map((e) => e) || [];
    message.reasoning = object.reasoning ?? undefined;
    message.evidence = object.evidence?.map((e) => e) || [];
    message.counterEvidence = object.counterEvidence?.map((e) => e) || [];
    message.externalReferences = object.externalReferences?.map((e) => ExternalReference.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeclarations_Evidence(): Declarations_Evidence {
  return {
    bomRef: undefined,
    propertyName: undefined,
    description: undefined,
    data: [],
    created: undefined,
    expires: undefined,
    author: undefined,
    reviewer: undefined,
  };
}

export const Declarations_Evidence: MessageFns<Declarations_Evidence> = {
  encode(message: Declarations_Evidence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== undefined) {
      writer.uint32(10).string(message.bomRef);
    }
    if (message.propertyName !== undefined) {
      writer.uint32(18).string(message.propertyName);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    for (const v of message.data) {
      Declarations_Evidence_Data.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.created !== undefined) {
      Timestamp.encode(toTimestamp(message.created), writer.uint32(42).fork()).join();
    }
    if (message.expires !== undefined) {
      Timestamp.encode(toTimestamp(message.expires), writer.uint32(50).fork()).join();
    }
    if (message.author !== undefined) {
      OrganizationalContact.encode(message.author, writer.uint32(58).fork()).join();
    }
    if (message.reviewer !== undefined) {
      OrganizationalContact.encode(message.reviewer, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Declarations_Evidence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclarations_Evidence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.propertyName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.data.push(Declarations_Evidence_Data.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.created = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expires = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.author = OrganizationalContact.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.reviewer = OrganizationalContact.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Declarations_Evidence {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      propertyName: isSet(object.propertyName) ? globalThis.String(object.propertyName) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      data: globalThis.Array.isArray(object?.data)
        ? object.data.map((e: any) => Declarations_Evidence_Data.fromJSON(e))
        : [],
      created: isSet(object.created) ? fromJsonTimestamp(object.created) : undefined,
      expires: isSet(object.expires) ? fromJsonTimestamp(object.expires) : undefined,
      author: isSet(object.author) ? OrganizationalContact.fromJSON(object.author) : undefined,
      reviewer: isSet(object.reviewer) ? OrganizationalContact.fromJSON(object.reviewer) : undefined,
    };
  },

  toJSON(message: Declarations_Evidence): unknown {
    const obj: any = {};
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.propertyName !== undefined) {
      obj.propertyName = message.propertyName;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.data?.length) {
      obj.data = message.data.map((e) => Declarations_Evidence_Data.toJSON(e));
    }
    if (message.created !== undefined) {
      obj.created = message.created.toISOString();
    }
    if (message.expires !== undefined) {
      obj.expires = message.expires.toISOString();
    }
    if (message.author !== undefined) {
      obj.author = OrganizationalContact.toJSON(message.author);
    }
    if (message.reviewer !== undefined) {
      obj.reviewer = OrganizationalContact.toJSON(message.reviewer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Declarations_Evidence>, I>>(base?: I): Declarations_Evidence {
    return Declarations_Evidence.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Declarations_Evidence>, I>>(object: I): Declarations_Evidence {
    const message = createBaseDeclarations_Evidence();
    message.bomRef = object.bomRef ?? undefined;
    message.propertyName = object.propertyName ?? undefined;
    message.description = object.description ?? undefined;
    message.data = object.data?.map((e) => Declarations_Evidence_Data.fromPartial(e)) || [];
    message.created = object.created ?? undefined;
    message.expires = object.expires ?? undefined;
    message.author = (object.author !== undefined && object.author !== null)
      ? OrganizationalContact.fromPartial(object.author)
      : undefined;
    message.reviewer = (object.reviewer !== undefined && object.reviewer !== null)
      ? OrganizationalContact.fromPartial(object.reviewer)
      : undefined;
    return message;
  },
};

function createBaseDeclarations_Evidence_Data(): Declarations_Evidence_Data {
  return { name: undefined, contents: undefined, classification: undefined, sensitiveData: [], governance: undefined };
}

export const Declarations_Evidence_Data: MessageFns<Declarations_Evidence_Data> = {
  encode(message: Declarations_Evidence_Data, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.contents !== undefined) {
      Declarations_Evidence_Data_Contents.encode(message.contents, writer.uint32(18).fork()).join();
    }
    if (message.classification !== undefined) {
      writer.uint32(26).string(message.classification);
    }
    for (const v of message.sensitiveData) {
      writer.uint32(34).string(v!);
    }
    if (message.governance !== undefined) {
      DataGovernance.encode(message.governance, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Declarations_Evidence_Data {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclarations_Evidence_Data();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contents = Declarations_Evidence_Data_Contents.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.classification = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sensitiveData.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.governance = DataGovernance.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Declarations_Evidence_Data {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      contents: isSet(object.contents) ? Declarations_Evidence_Data_Contents.fromJSON(object.contents) : undefined,
      classification: isSet(object.classification) ? globalThis.String(object.classification) : undefined,
      sensitiveData: globalThis.Array.isArray(object?.sensitiveData)
        ? object.sensitiveData.map((e: any) => globalThis.String(e))
        : [],
      governance: isSet(object.governance) ? DataGovernance.fromJSON(object.governance) : undefined,
    };
  },

  toJSON(message: Declarations_Evidence_Data): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.contents !== undefined) {
      obj.contents = Declarations_Evidence_Data_Contents.toJSON(message.contents);
    }
    if (message.classification !== undefined) {
      obj.classification = message.classification;
    }
    if (message.sensitiveData?.length) {
      obj.sensitiveData = message.sensitiveData;
    }
    if (message.governance !== undefined) {
      obj.governance = DataGovernance.toJSON(message.governance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Declarations_Evidence_Data>, I>>(base?: I): Declarations_Evidence_Data {
    return Declarations_Evidence_Data.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Declarations_Evidence_Data>, I>>(object: I): Declarations_Evidence_Data {
    const message = createBaseDeclarations_Evidence_Data();
    message.name = object.name ?? undefined;
    message.contents = (object.contents !== undefined && object.contents !== null)
      ? Declarations_Evidence_Data_Contents.fromPartial(object.contents)
      : undefined;
    message.classification = object.classification ?? undefined;
    message.sensitiveData = object.sensitiveData?.map((e) => e) || [];
    message.governance = (object.governance !== undefined && object.governance !== null)
      ? DataGovernance.fromPartial(object.governance)
      : undefined;
    return message;
  },
};

function createBaseDeclarations_Evidence_Data_Contents(): Declarations_Evidence_Data_Contents {
  return { attachment: undefined, url: undefined };
}

export const Declarations_Evidence_Data_Contents: MessageFns<Declarations_Evidence_Data_Contents> = {
  encode(message: Declarations_Evidence_Data_Contents, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.attachment !== undefined) {
      AttachedText.encode(message.attachment, writer.uint32(10).fork()).join();
    }
    if (message.url !== undefined) {
      writer.uint32(18).string(message.url);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Declarations_Evidence_Data_Contents {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclarations_Evidence_Data_Contents();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.attachment = AttachedText.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Declarations_Evidence_Data_Contents {
    return {
      attachment: isSet(object.attachment) ? AttachedText.fromJSON(object.attachment) : undefined,
      url: isSet(object.url) ? globalThis.String(object.url) : undefined,
    };
  },

  toJSON(message: Declarations_Evidence_Data_Contents): unknown {
    const obj: any = {};
    if (message.attachment !== undefined) {
      obj.attachment = AttachedText.toJSON(message.attachment);
    }
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Declarations_Evidence_Data_Contents>, I>>(
    base?: I,
  ): Declarations_Evidence_Data_Contents {
    return Declarations_Evidence_Data_Contents.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Declarations_Evidence_Data_Contents>, I>>(
    object: I,
  ): Declarations_Evidence_Data_Contents {
    const message = createBaseDeclarations_Evidence_Data_Contents();
    message.attachment = (object.attachment !== undefined && object.attachment !== null)
      ? AttachedText.fromPartial(object.attachment)
      : undefined;
    message.url = object.url ?? undefined;
    return message;
  },
};

function createBaseDeclarations_Targets(): Declarations_Targets {
  return { organizations: [], components: [], services: [] };
}

export const Declarations_Targets: MessageFns<Declarations_Targets> = {
  encode(message: Declarations_Targets, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.organizations) {
      OrganizationalEntity.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.components) {
      Component.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.services) {
      Service.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Declarations_Targets {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclarations_Targets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organizations.push(OrganizationalEntity.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.components.push(Component.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.services.push(Service.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Declarations_Targets {
    return {
      organizations: globalThis.Array.isArray(object?.organizations)
        ? object.organizations.map((e: any) => OrganizationalEntity.fromJSON(e))
        : [],
      components: globalThis.Array.isArray(object?.components)
        ? object.components.map((e: any) => Component.fromJSON(e))
        : [],
      services: globalThis.Array.isArray(object?.services) ? object.services.map((e: any) => Service.fromJSON(e)) : [],
    };
  },

  toJSON(message: Declarations_Targets): unknown {
    const obj: any = {};
    if (message.organizations?.length) {
      obj.organizations = message.organizations.map((e) => OrganizationalEntity.toJSON(e));
    }
    if (message.components?.length) {
      obj.components = message.components.map((e) => Component.toJSON(e));
    }
    if (message.services?.length) {
      obj.services = message.services.map((e) => Service.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Declarations_Targets>, I>>(base?: I): Declarations_Targets {
    return Declarations_Targets.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Declarations_Targets>, I>>(object: I): Declarations_Targets {
    const message = createBaseDeclarations_Targets();
    message.organizations = object.organizations?.map((e) => OrganizationalEntity.fromPartial(e)) || [];
    message.components = object.components?.map((e) => Component.fromPartial(e)) || [];
    message.services = object.services?.map((e) => Service.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeclarations_Affirmation(): Declarations_Affirmation {
  return { statement: undefined, signatories: [] };
}

export const Declarations_Affirmation: MessageFns<Declarations_Affirmation> = {
  encode(message: Declarations_Affirmation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.statement !== undefined) {
      writer.uint32(10).string(message.statement);
    }
    for (const v of message.signatories) {
      Declarations_Affirmation_Signatory.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Declarations_Affirmation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclarations_Affirmation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statement = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.signatories.push(Declarations_Affirmation_Signatory.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Declarations_Affirmation {
    return {
      statement: isSet(object.statement) ? globalThis.String(object.statement) : undefined,
      signatories: globalThis.Array.isArray(object?.signatories)
        ? object.signatories.map((e: any) => Declarations_Affirmation_Signatory.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Declarations_Affirmation): unknown {
    const obj: any = {};
    if (message.statement !== undefined) {
      obj.statement = message.statement;
    }
    if (message.signatories?.length) {
      obj.signatories = message.signatories.map((e) => Declarations_Affirmation_Signatory.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Declarations_Affirmation>, I>>(base?: I): Declarations_Affirmation {
    return Declarations_Affirmation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Declarations_Affirmation>, I>>(object: I): Declarations_Affirmation {
    const message = createBaseDeclarations_Affirmation();
    message.statement = object.statement ?? undefined;
    message.signatories = object.signatories?.map((e) => Declarations_Affirmation_Signatory.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeclarations_Affirmation_Signatory(): Declarations_Affirmation_Signatory {
  return { name: undefined, role: undefined, organization: undefined, externalReference: undefined };
}

export const Declarations_Affirmation_Signatory: MessageFns<Declarations_Affirmation_Signatory> = {
  encode(message: Declarations_Affirmation_Signatory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.role !== undefined) {
      writer.uint32(18).string(message.role);
    }
    if (message.organization !== undefined) {
      OrganizationalEntity.encode(message.organization, writer.uint32(26).fork()).join();
    }
    if (message.externalReference !== undefined) {
      ExternalReference.encode(message.externalReference, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Declarations_Affirmation_Signatory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeclarations_Affirmation_Signatory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.organization = OrganizationalEntity.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.externalReference = ExternalReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Declarations_Affirmation_Signatory {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      role: isSet(object.role) ? globalThis.String(object.role) : undefined,
      organization: isSet(object.organization) ? OrganizationalEntity.fromJSON(object.organization) : undefined,
      externalReference: isSet(object.externalReference)
        ? ExternalReference.fromJSON(object.externalReference)
        : undefined,
    };
  },

  toJSON(message: Declarations_Affirmation_Signatory): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.role !== undefined) {
      obj.role = message.role;
    }
    if (message.organization !== undefined) {
      obj.organization = OrganizationalEntity.toJSON(message.organization);
    }
    if (message.externalReference !== undefined) {
      obj.externalReference = ExternalReference.toJSON(message.externalReference);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Declarations_Affirmation_Signatory>, I>>(
    base?: I,
  ): Declarations_Affirmation_Signatory {
    return Declarations_Affirmation_Signatory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Declarations_Affirmation_Signatory>, I>>(
    object: I,
  ): Declarations_Affirmation_Signatory {
    const message = createBaseDeclarations_Affirmation_Signatory();
    message.name = object.name ?? undefined;
    message.role = object.role ?? undefined;
    message.organization = (object.organization !== undefined && object.organization !== null)
      ? OrganizationalEntity.fromPartial(object.organization)
      : undefined;
    message.externalReference = (object.externalReference !== undefined && object.externalReference !== null)
      ? ExternalReference.fromPartial(object.externalReference)
      : undefined;
    return message;
  },
};

function createBaseDefinition(): Definition {
  return { standards: [] };
}

export const Definition: MessageFns<Definition> = {
  encode(message: Definition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.standards) {
      Definition_Standard.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Definition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.standards.push(Definition_Standard.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Definition {
    return {
      standards: globalThis.Array.isArray(object?.standards)
        ? object.standards.map((e: any) => Definition_Standard.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Definition): unknown {
    const obj: any = {};
    if (message.standards?.length) {
      obj.standards = message.standards.map((e) => Definition_Standard.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Definition>, I>>(base?: I): Definition {
    return Definition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Definition>, I>>(object: I): Definition {
    const message = createBaseDefinition();
    message.standards = object.standards?.map((e) => Definition_Standard.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDefinition_Standard(): Definition_Standard {
  return {
    bomRef: undefined,
    name: undefined,
    version: undefined,
    description: undefined,
    owner: undefined,
    requirements: [],
    levels: [],
    externalReferences: [],
  };
}

export const Definition_Standard: MessageFns<Definition_Standard> = {
  encode(message: Definition_Standard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== undefined) {
      writer.uint32(10).string(message.bomRef);
    }
    if (message.name !== undefined) {
      writer.uint32(18).string(message.name);
    }
    if (message.version !== undefined) {
      writer.uint32(26).string(message.version);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    if (message.owner !== undefined) {
      writer.uint32(42).string(message.owner);
    }
    for (const v of message.requirements) {
      Definition_Standard_Requirement.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.levels) {
      Definition_Standard_Level.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.externalReferences) {
      ExternalReference.encode(v!, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Definition_Standard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefinition_Standard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.requirements.push(Definition_Standard_Requirement.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.levels.push(Definition_Standard_Level.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.externalReferences.push(ExternalReference.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Definition_Standard {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      owner: isSet(object.owner) ? globalThis.String(object.owner) : undefined,
      requirements: globalThis.Array.isArray(object?.requirements)
        ? object.requirements.map((e: any) => Definition_Standard_Requirement.fromJSON(e))
        : [],
      levels: globalThis.Array.isArray(object?.levels)
        ? object.levels.map((e: any) => Definition_Standard_Level.fromJSON(e))
        : [],
      externalReferences: globalThis.Array.isArray(object?.externalReferences)
        ? object.externalReferences.map((e: any) => ExternalReference.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Definition_Standard): unknown {
    const obj: any = {};
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.version !== undefined) {
      obj.version = message.version;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.owner !== undefined) {
      obj.owner = message.owner;
    }
    if (message.requirements?.length) {
      obj.requirements = message.requirements.map((e) => Definition_Standard_Requirement.toJSON(e));
    }
    if (message.levels?.length) {
      obj.levels = message.levels.map((e) => Definition_Standard_Level.toJSON(e));
    }
    if (message.externalReferences?.length) {
      obj.externalReferences = message.externalReferences.map((e) => ExternalReference.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Definition_Standard>, I>>(base?: I): Definition_Standard {
    return Definition_Standard.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Definition_Standard>, I>>(object: I): Definition_Standard {
    const message = createBaseDefinition_Standard();
    message.bomRef = object.bomRef ?? undefined;
    message.name = object.name ?? undefined;
    message.version = object.version ?? undefined;
    message.description = object.description ?? undefined;
    message.owner = object.owner ?? undefined;
    message.requirements = object.requirements?.map((e) => Definition_Standard_Requirement.fromPartial(e)) || [];
    message.levels = object.levels?.map((e) => Definition_Standard_Level.fromPartial(e)) || [];
    message.externalReferences = object.externalReferences?.map((e) => ExternalReference.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDefinition_Standard_Requirement(): Definition_Standard_Requirement {
  return {
    bomRef: undefined,
    identifier: undefined,
    title: undefined,
    text: undefined,
    descriptions: [],
    openCre: [],
    parent: undefined,
    properties: [],
    externalReferences: [],
  };
}

export const Definition_Standard_Requirement: MessageFns<Definition_Standard_Requirement> = {
  encode(message: Definition_Standard_Requirement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== undefined) {
      writer.uint32(10).string(message.bomRef);
    }
    if (message.identifier !== undefined) {
      writer.uint32(18).string(message.identifier);
    }
    if (message.title !== undefined) {
      writer.uint32(26).string(message.title);
    }
    if (message.text !== undefined) {
      writer.uint32(34).string(message.text);
    }
    for (const v of message.descriptions) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.openCre) {
      writer.uint32(50).string(v!);
    }
    if (message.parent !== undefined) {
      writer.uint32(58).string(message.parent);
    }
    for (const v of message.properties) {
      Property.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.externalReferences) {
      ExternalReference.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Definition_Standard_Requirement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefinition_Standard_Requirement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.descriptions.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.openCre.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.parent = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.properties.push(Property.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.externalReferences.push(ExternalReference.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Definition_Standard_Requirement {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : undefined,
      text: isSet(object.text) ? globalThis.String(object.text) : undefined,
      descriptions: globalThis.Array.isArray(object?.descriptions)
        ? object.descriptions.map((e: any) => globalThis.String(e))
        : [],
      openCre: globalThis.Array.isArray(object?.openCre) ? object.openCre.map((e: any) => globalThis.String(e)) : [],
      parent: isSet(object.parent) ? globalThis.String(object.parent) : undefined,
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => Property.fromJSON(e))
        : [],
      externalReferences: globalThis.Array.isArray(object?.externalReferences)
        ? object.externalReferences.map((e: any) => ExternalReference.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Definition_Standard_Requirement): unknown {
    const obj: any = {};
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.identifier !== undefined) {
      obj.identifier = message.identifier;
    }
    if (message.title !== undefined) {
      obj.title = message.title;
    }
    if (message.text !== undefined) {
      obj.text = message.text;
    }
    if (message.descriptions?.length) {
      obj.descriptions = message.descriptions;
    }
    if (message.openCre?.length) {
      obj.openCre = message.openCre;
    }
    if (message.parent !== undefined) {
      obj.parent = message.parent;
    }
    if (message.properties?.length) {
      obj.properties = message.properties.map((e) => Property.toJSON(e));
    }
    if (message.externalReferences?.length) {
      obj.externalReferences = message.externalReferences.map((e) => ExternalReference.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Definition_Standard_Requirement>, I>>(base?: I): Definition_Standard_Requirement {
    return Definition_Standard_Requirement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Definition_Standard_Requirement>, I>>(
    object: I,
  ): Definition_Standard_Requirement {
    const message = createBaseDefinition_Standard_Requirement();
    message.bomRef = object.bomRef ?? undefined;
    message.identifier = object.identifier ?? undefined;
    message.title = object.title ?? undefined;
    message.text = object.text ?? undefined;
    message.descriptions = object.descriptions?.map((e) => e) || [];
    message.openCre = object.openCre?.map((e) => e) || [];
    message.parent = object.parent ?? undefined;
    message.properties = object.properties?.map((e) => Property.fromPartial(e)) || [];
    message.externalReferences = object.externalReferences?.map((e) => ExternalReference.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDefinition_Standard_Level(): Definition_Standard_Level {
  return { bomRef: undefined, identifier: undefined, title: undefined, description: undefined, requirements: [] };
}

export const Definition_Standard_Level: MessageFns<Definition_Standard_Level> = {
  encode(message: Definition_Standard_Level, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bomRef !== undefined) {
      writer.uint32(10).string(message.bomRef);
    }
    if (message.identifier !== undefined) {
      writer.uint32(18).string(message.identifier);
    }
    if (message.title !== undefined) {
      writer.uint32(26).string(message.title);
    }
    if (message.description !== undefined) {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.requirements) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Definition_Standard_Level {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefinition_Standard_Level();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bomRef = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identifier = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requirements.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Definition_Standard_Level {
    return {
      bomRef: isSet(object.bomRef) ? globalThis.String(object.bomRef) : undefined,
      identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : undefined,
      title: isSet(object.title) ? globalThis.String(object.title) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      requirements: globalThis.Array.isArray(object?.requirements)
        ? object.requirements.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Definition_Standard_Level): unknown {
    const obj: any = {};
    if (message.bomRef !== undefined) {
      obj.bomRef = message.bomRef;
    }
    if (message.identifier !== undefined) {
      obj.identifier = message.identifier;
    }
    if (message.title !== undefined) {
      obj.title = message.title;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.requirements?.length) {
      obj.requirements = message.requirements;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Definition_Standard_Level>, I>>(base?: I): Definition_Standard_Level {
    return Definition_Standard_Level.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Definition_Standard_Level>, I>>(object: I): Definition_Standard_Level {
    const message = createBaseDefinition_Standard_Level();
    message.bomRef = object.bomRef ?? undefined;
    message.identifier = object.identifier ?? undefined;
    message.title = object.title ?? undefined;
    message.description = object.description ?? undefined;
    message.requirements = object.requirements?.map((e) => e) || [];
    return message;
  },
};

function createBaseCryptoProperties(): CryptoProperties {
  return {
    assetType: 0,
    algorithmProperties: undefined,
    certificateProperties: undefined,
    relatedCryptoMaterialProperties: undefined,
    protocolProperties: undefined,
    oid: undefined,
  };
}

export const CryptoProperties: MessageFns<CryptoProperties> = {
  encode(message: CryptoProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetType !== 0) {
      writer.uint32(8).int32(message.assetType);
    }
    if (message.algorithmProperties !== undefined) {
      CryptoProperties_AlgorithmProperties.encode(message.algorithmProperties, writer.uint32(18).fork()).join();
    }
    if (message.certificateProperties !== undefined) {
      CryptoProperties_CertificateProperties.encode(message.certificateProperties, writer.uint32(26).fork()).join();
    }
    if (message.relatedCryptoMaterialProperties !== undefined) {
      CryptoProperties_RelatedCryptoMaterialProperties.encode(
        message.relatedCryptoMaterialProperties,
        writer.uint32(34).fork(),
      ).join();
    }
    if (message.protocolProperties !== undefined) {
      CryptoProperties_ProtocolProperties.encode(message.protocolProperties, writer.uint32(42).fork()).join();
    }
    if (message.oid !== undefined) {
      writer.uint32(50).string(message.oid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CryptoProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.assetType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.algorithmProperties = CryptoProperties_AlgorithmProperties.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.certificateProperties = CryptoProperties_CertificateProperties.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.relatedCryptoMaterialProperties = CryptoProperties_RelatedCryptoMaterialProperties.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.protocolProperties = CryptoProperties_ProtocolProperties.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.oid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoProperties {
    return {
      assetType: isSet(object.assetType) ? cryptoProperties_CryptoAssetTypeFromJSON(object.assetType) : 0,
      algorithmProperties: isSet(object.algorithmProperties)
        ? CryptoProperties_AlgorithmProperties.fromJSON(object.algorithmProperties)
        : undefined,
      certificateProperties: isSet(object.certificateProperties)
        ? CryptoProperties_CertificateProperties.fromJSON(object.certificateProperties)
        : undefined,
      relatedCryptoMaterialProperties: isSet(object.relatedCryptoMaterialProperties)
        ? CryptoProperties_RelatedCryptoMaterialProperties.fromJSON(object.relatedCryptoMaterialProperties)
        : undefined,
      protocolProperties: isSet(object.protocolProperties)
        ? CryptoProperties_ProtocolProperties.fromJSON(object.protocolProperties)
        : undefined,
      oid: isSet(object.oid) ? globalThis.String(object.oid) : undefined,
    };
  },

  toJSON(message: CryptoProperties): unknown {
    const obj: any = {};
    if (message.assetType !== 0) {
      obj.assetType = cryptoProperties_CryptoAssetTypeToJSON(message.assetType);
    }
    if (message.algorithmProperties !== undefined) {
      obj.algorithmProperties = CryptoProperties_AlgorithmProperties.toJSON(message.algorithmProperties);
    }
    if (message.certificateProperties !== undefined) {
      obj.certificateProperties = CryptoProperties_CertificateProperties.toJSON(message.certificateProperties);
    }
    if (message.relatedCryptoMaterialProperties !== undefined) {
      obj.relatedCryptoMaterialProperties = CryptoProperties_RelatedCryptoMaterialProperties.toJSON(
        message.relatedCryptoMaterialProperties,
      );
    }
    if (message.protocolProperties !== undefined) {
      obj.protocolProperties = CryptoProperties_ProtocolProperties.toJSON(message.protocolProperties);
    }
    if (message.oid !== undefined) {
      obj.oid = message.oid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CryptoProperties>, I>>(base?: I): CryptoProperties {
    return CryptoProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CryptoProperties>, I>>(object: I): CryptoProperties {
    const message = createBaseCryptoProperties();
    message.assetType = object.assetType ?? 0;
    message.algorithmProperties = (object.algorithmProperties !== undefined && object.algorithmProperties !== null)
      ? CryptoProperties_AlgorithmProperties.fromPartial(object.algorithmProperties)
      : undefined;
    message.certificateProperties =
      (object.certificateProperties !== undefined && object.certificateProperties !== null)
        ? CryptoProperties_CertificateProperties.fromPartial(object.certificateProperties)
        : undefined;
    message.relatedCryptoMaterialProperties =
      (object.relatedCryptoMaterialProperties !== undefined && object.relatedCryptoMaterialProperties !== null)
        ? CryptoProperties_RelatedCryptoMaterialProperties.fromPartial(object.relatedCryptoMaterialProperties)
        : undefined;
    message.protocolProperties = (object.protocolProperties !== undefined && object.protocolProperties !== null)
      ? CryptoProperties_ProtocolProperties.fromPartial(object.protocolProperties)
      : undefined;
    message.oid = object.oid ?? undefined;
    return message;
  },
};

function createBaseCryptoProperties_AlgorithmProperties(): CryptoProperties_AlgorithmProperties {
  return {
    primitive: undefined,
    parameterSetIdentifier: undefined,
    curve: undefined,
    executionEnvironment: undefined,
    implementationPlatform: undefined,
    certificationLevel: [],
    mode: undefined,
    padding: undefined,
    cryptoFunctions: [],
    classicalSecurityLevel: undefined,
    nistQuantumSecurityLevel: undefined,
  };
}

export const CryptoProperties_AlgorithmProperties: MessageFns<CryptoProperties_AlgorithmProperties> = {
  encode(message: CryptoProperties_AlgorithmProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.primitive !== undefined) {
      writer.uint32(8).int32(message.primitive);
    }
    if (message.parameterSetIdentifier !== undefined) {
      writer.uint32(18).string(message.parameterSetIdentifier);
    }
    if (message.curve !== undefined) {
      writer.uint32(26).string(message.curve);
    }
    if (message.executionEnvironment !== undefined) {
      writer.uint32(32).int32(message.executionEnvironment);
    }
    if (message.implementationPlatform !== undefined) {
      writer.uint32(40).int32(message.implementationPlatform);
    }
    for (const v of message.certificationLevel) {
      writer.uint32(50).string(v!);
    }
    if (message.mode !== undefined) {
      writer.uint32(56).int32(message.mode);
    }
    if (message.padding !== undefined) {
      writer.uint32(64).int32(message.padding);
    }
    writer.uint32(74).fork();
    for (const v of message.cryptoFunctions) {
      writer.int32(v);
    }
    writer.join();
    if (message.classicalSecurityLevel !== undefined) {
      writer.uint32(80).int32(message.classicalSecurityLevel);
    }
    if (message.nistQuantumSecurityLevel !== undefined) {
      writer.uint32(88).int32(message.nistQuantumSecurityLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CryptoProperties_AlgorithmProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoProperties_AlgorithmProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.primitive = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parameterSetIdentifier = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.curve = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.executionEnvironment = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.implementationPlatform = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.certificationLevel.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.padding = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag === 72) {
            message.cryptoFunctions.push(reader.int32() as any);

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.cryptoFunctions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.classicalSecurityLevel = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.nistQuantumSecurityLevel = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoProperties_AlgorithmProperties {
    return {
      primitive: isSet(object.primitive)
        ? cryptoProperties_AlgorithmProperties_CryptoPrimitiveFromJSON(object.primitive)
        : undefined,
      parameterSetIdentifier: isSet(object.parameterSetIdentifier)
        ? globalThis.String(object.parameterSetIdentifier)
        : undefined,
      curve: isSet(object.curve) ? globalThis.String(object.curve) : undefined,
      executionEnvironment: isSet(object.executionEnvironment)
        ? cryptoProperties_AlgorithmProperties_CryptoExecutionEnvironmentFromJSON(object.executionEnvironment)
        : undefined,
      implementationPlatform: isSet(object.implementationPlatform)
        ? cryptoProperties_AlgorithmProperties_CryptoImplementationPlatformFromJSON(object.implementationPlatform)
        : undefined,
      certificationLevel: globalThis.Array.isArray(object?.certificationLevel)
        ? object.certificationLevel.map((e: any) => globalThis.String(e))
        : [],
      mode: isSet(object.mode)
        ? cryptoProperties_AlgorithmProperties_CryptoAlgorithmModeFromJSON(object.mode)
        : undefined,
      padding: isSet(object.padding)
        ? cryptoProperties_AlgorithmProperties_CryptoAlgorithmPaddingFromJSON(object.padding)
        : undefined,
      cryptoFunctions: globalThis.Array.isArray(object?.cryptoFunctions)
        ? object.cryptoFunctions.map((e: any) =>
          cryptoProperties_AlgorithmProperties_CryptoAlgorithmFunctionFromJSON(e)
        )
        : [],
      classicalSecurityLevel: isSet(object.classicalSecurityLevel)
        ? globalThis.Number(object.classicalSecurityLevel)
        : undefined,
      nistQuantumSecurityLevel: isSet(object.nistQuantumSecurityLevel)
        ? globalThis.Number(object.nistQuantumSecurityLevel)
        : undefined,
    };
  },

  toJSON(message: CryptoProperties_AlgorithmProperties): unknown {
    const obj: any = {};
    if (message.primitive !== undefined) {
      obj.primitive = cryptoProperties_AlgorithmProperties_CryptoPrimitiveToJSON(message.primitive);
    }
    if (message.parameterSetIdentifier !== undefined) {
      obj.parameterSetIdentifier = message.parameterSetIdentifier;
    }
    if (message.curve !== undefined) {
      obj.curve = message.curve;
    }
    if (message.executionEnvironment !== undefined) {
      obj.executionEnvironment = cryptoProperties_AlgorithmProperties_CryptoExecutionEnvironmentToJSON(
        message.executionEnvironment,
      );
    }
    if (message.implementationPlatform !== undefined) {
      obj.implementationPlatform = cryptoProperties_AlgorithmProperties_CryptoImplementationPlatformToJSON(
        message.implementationPlatform,
      );
    }
    if (message.certificationLevel?.length) {
      obj.certificationLevel = message.certificationLevel;
    }
    if (message.mode !== undefined) {
      obj.mode = cryptoProperties_AlgorithmProperties_CryptoAlgorithmModeToJSON(message.mode);
    }
    if (message.padding !== undefined) {
      obj.padding = cryptoProperties_AlgorithmProperties_CryptoAlgorithmPaddingToJSON(message.padding);
    }
    if (message.cryptoFunctions?.length) {
      obj.cryptoFunctions = message.cryptoFunctions.map((e) =>
        cryptoProperties_AlgorithmProperties_CryptoAlgorithmFunctionToJSON(e)
      );
    }
    if (message.classicalSecurityLevel !== undefined) {
      obj.classicalSecurityLevel = Math.round(message.classicalSecurityLevel);
    }
    if (message.nistQuantumSecurityLevel !== undefined) {
      obj.nistQuantumSecurityLevel = Math.round(message.nistQuantumSecurityLevel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CryptoProperties_AlgorithmProperties>, I>>(
    base?: I,
  ): CryptoProperties_AlgorithmProperties {
    return CryptoProperties_AlgorithmProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CryptoProperties_AlgorithmProperties>, I>>(
    object: I,
  ): CryptoProperties_AlgorithmProperties {
    const message = createBaseCryptoProperties_AlgorithmProperties();
    message.primitive = object.primitive ?? undefined;
    message.parameterSetIdentifier = object.parameterSetIdentifier ?? undefined;
    message.curve = object.curve ?? undefined;
    message.executionEnvironment = object.executionEnvironment ?? undefined;
    message.implementationPlatform = object.implementationPlatform ?? undefined;
    message.certificationLevel = object.certificationLevel?.map((e) => e) || [];
    message.mode = object.mode ?? undefined;
    message.padding = object.padding ?? undefined;
    message.cryptoFunctions = object.cryptoFunctions?.map((e) => e) || [];
    message.classicalSecurityLevel = object.classicalSecurityLevel ?? undefined;
    message.nistQuantumSecurityLevel = object.nistQuantumSecurityLevel ?? undefined;
    return message;
  },
};

function createBaseCryptoProperties_CertificateProperties(): CryptoProperties_CertificateProperties {
  return {
    subjectName: undefined,
    issuerName: undefined,
    notValidBefore: undefined,
    notValidAfter: undefined,
    signatureAlgorithmRef: undefined,
    subjectPublicKeyRef: undefined,
    certificateFormat: undefined,
    certificateExtension: undefined,
  };
}

export const CryptoProperties_CertificateProperties: MessageFns<CryptoProperties_CertificateProperties> = {
  encode(message: CryptoProperties_CertificateProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subjectName !== undefined) {
      writer.uint32(10).string(message.subjectName);
    }
    if (message.issuerName !== undefined) {
      writer.uint32(18).string(message.issuerName);
    }
    if (message.notValidBefore !== undefined) {
      Timestamp.encode(toTimestamp(message.notValidBefore), writer.uint32(26).fork()).join();
    }
    if (message.notValidAfter !== undefined) {
      Timestamp.encode(toTimestamp(message.notValidAfter), writer.uint32(34).fork()).join();
    }
    if (message.signatureAlgorithmRef !== undefined) {
      writer.uint32(42).string(message.signatureAlgorithmRef);
    }
    if (message.subjectPublicKeyRef !== undefined) {
      writer.uint32(50).string(message.subjectPublicKeyRef);
    }
    if (message.certificateFormat !== undefined) {
      writer.uint32(58).string(message.certificateFormat);
    }
    if (message.certificateExtension !== undefined) {
      writer.uint32(66).string(message.certificateExtension);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CryptoProperties_CertificateProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoProperties_CertificateProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subjectName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.issuerName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.notValidBefore = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.notValidAfter = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signatureAlgorithmRef = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.subjectPublicKeyRef = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.certificateFormat = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.certificateExtension = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoProperties_CertificateProperties {
    return {
      subjectName: isSet(object.subjectName) ? globalThis.String(object.subjectName) : undefined,
      issuerName: isSet(object.issuerName) ? globalThis.String(object.issuerName) : undefined,
      notValidBefore: isSet(object.notValidBefore) ? fromJsonTimestamp(object.notValidBefore) : undefined,
      notValidAfter: isSet(object.notValidAfter) ? fromJsonTimestamp(object.notValidAfter) : undefined,
      signatureAlgorithmRef: isSet(object.signatureAlgorithmRef)
        ? globalThis.String(object.signatureAlgorithmRef)
        : undefined,
      subjectPublicKeyRef: isSet(object.subjectPublicKeyRef)
        ? globalThis.String(object.subjectPublicKeyRef)
        : undefined,
      certificateFormat: isSet(object.certificateFormat) ? globalThis.String(object.certificateFormat) : undefined,
      certificateExtension: isSet(object.certificateExtension)
        ? globalThis.String(object.certificateExtension)
        : undefined,
    };
  },

  toJSON(message: CryptoProperties_CertificateProperties): unknown {
    const obj: any = {};
    if (message.subjectName !== undefined) {
      obj.subjectName = message.subjectName;
    }
    if (message.issuerName !== undefined) {
      obj.issuerName = message.issuerName;
    }
    if (message.notValidBefore !== undefined) {
      obj.notValidBefore = message.notValidBefore.toISOString();
    }
    if (message.notValidAfter !== undefined) {
      obj.notValidAfter = message.notValidAfter.toISOString();
    }
    if (message.signatureAlgorithmRef !== undefined) {
      obj.signatureAlgorithmRef = message.signatureAlgorithmRef;
    }
    if (message.subjectPublicKeyRef !== undefined) {
      obj.subjectPublicKeyRef = message.subjectPublicKeyRef;
    }
    if (message.certificateFormat !== undefined) {
      obj.certificateFormat = message.certificateFormat;
    }
    if (message.certificateExtension !== undefined) {
      obj.certificateExtension = message.certificateExtension;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CryptoProperties_CertificateProperties>, I>>(
    base?: I,
  ): CryptoProperties_CertificateProperties {
    return CryptoProperties_CertificateProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CryptoProperties_CertificateProperties>, I>>(
    object: I,
  ): CryptoProperties_CertificateProperties {
    const message = createBaseCryptoProperties_CertificateProperties();
    message.subjectName = object.subjectName ?? undefined;
    message.issuerName = object.issuerName ?? undefined;
    message.notValidBefore = object.notValidBefore ?? undefined;
    message.notValidAfter = object.notValidAfter ?? undefined;
    message.signatureAlgorithmRef = object.signatureAlgorithmRef ?? undefined;
    message.subjectPublicKeyRef = object.subjectPublicKeyRef ?? undefined;
    message.certificateFormat = object.certificateFormat ?? undefined;
    message.certificateExtension = object.certificateExtension ?? undefined;
    return message;
  },
};

function createBaseCryptoProperties_RelatedCryptoMaterialProperties(): CryptoProperties_RelatedCryptoMaterialProperties {
  return {
    type: undefined,
    id: undefined,
    state: undefined,
    algorithmRef: undefined,
    creationDate: undefined,
    activationDate: undefined,
    updateDate: undefined,
    expirationDate: undefined,
    value: undefined,
    size: undefined,
    format: undefined,
    securedBy: undefined,
  };
}

export const CryptoProperties_RelatedCryptoMaterialProperties: MessageFns<
  CryptoProperties_RelatedCryptoMaterialProperties
> = {
  encode(
    message: CryptoProperties_RelatedCryptoMaterialProperties,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.type !== undefined) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== undefined) {
      writer.uint32(18).string(message.id);
    }
    if (message.state !== undefined) {
      writer.uint32(24).int32(message.state);
    }
    if (message.algorithmRef !== undefined) {
      writer.uint32(34).string(message.algorithmRef);
    }
    if (message.creationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.creationDate), writer.uint32(42).fork()).join();
    }
    if (message.activationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.activationDate), writer.uint32(50).fork()).join();
    }
    if (message.updateDate !== undefined) {
      Timestamp.encode(toTimestamp(message.updateDate), writer.uint32(58).fork()).join();
    }
    if (message.expirationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.expirationDate), writer.uint32(66).fork()).join();
    }
    if (message.value !== undefined) {
      writer.uint32(74).string(message.value);
    }
    if (message.size !== undefined) {
      writer.uint32(80).int64(message.size);
    }
    if (message.format !== undefined) {
      writer.uint32(90).string(message.format);
    }
    if (message.securedBy !== undefined) {
      CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy.encode(
        message.securedBy,
        writer.uint32(98).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CryptoProperties_RelatedCryptoMaterialProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoProperties_RelatedCryptoMaterialProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.algorithmRef = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.creationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.activationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updateDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.expirationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.value = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.size = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.format = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.securedBy = CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoProperties_RelatedCryptoMaterialProperties {
    return {
      type: isSet(object.type)
        ? cryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedTypeFromJSON(object.type)
        : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : undefined,
      state: isSet(object.state)
        ? cryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedStateFromJSON(object.state)
        : undefined,
      algorithmRef: isSet(object.algorithmRef) ? globalThis.String(object.algorithmRef) : undefined,
      creationDate: isSet(object.creationDate) ? fromJsonTimestamp(object.creationDate) : undefined,
      activationDate: isSet(object.activationDate) ? fromJsonTimestamp(object.activationDate) : undefined,
      updateDate: isSet(object.updateDate) ? fromJsonTimestamp(object.updateDate) : undefined,
      expirationDate: isSet(object.expirationDate) ? fromJsonTimestamp(object.expirationDate) : undefined,
      value: isSet(object.value) ? globalThis.String(object.value) : undefined,
      size: isSet(object.size) ? globalThis.String(object.size) : undefined,
      format: isSet(object.format) ? globalThis.String(object.format) : undefined,
      securedBy: isSet(object.securedBy)
        ? CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy.fromJSON(object.securedBy)
        : undefined,
    };
  },

  toJSON(message: CryptoProperties_RelatedCryptoMaterialProperties): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = cryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedTypeToJSON(message.type);
    }
    if (message.id !== undefined) {
      obj.id = message.id;
    }
    if (message.state !== undefined) {
      obj.state = cryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedStateToJSON(message.state);
    }
    if (message.algorithmRef !== undefined) {
      obj.algorithmRef = message.algorithmRef;
    }
    if (message.creationDate !== undefined) {
      obj.creationDate = message.creationDate.toISOString();
    }
    if (message.activationDate !== undefined) {
      obj.activationDate = message.activationDate.toISOString();
    }
    if (message.updateDate !== undefined) {
      obj.updateDate = message.updateDate.toISOString();
    }
    if (message.expirationDate !== undefined) {
      obj.expirationDate = message.expirationDate.toISOString();
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    if (message.size !== undefined) {
      obj.size = message.size;
    }
    if (message.format !== undefined) {
      obj.format = message.format;
    }
    if (message.securedBy !== undefined) {
      obj.securedBy = CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy.toJSON(message.securedBy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CryptoProperties_RelatedCryptoMaterialProperties>, I>>(
    base?: I,
  ): CryptoProperties_RelatedCryptoMaterialProperties {
    return CryptoProperties_RelatedCryptoMaterialProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CryptoProperties_RelatedCryptoMaterialProperties>, I>>(
    object: I,
  ): CryptoProperties_RelatedCryptoMaterialProperties {
    const message = createBaseCryptoProperties_RelatedCryptoMaterialProperties();
    message.type = object.type ?? undefined;
    message.id = object.id ?? undefined;
    message.state = object.state ?? undefined;
    message.algorithmRef = object.algorithmRef ?? undefined;
    message.creationDate = object.creationDate ?? undefined;
    message.activationDate = object.activationDate ?? undefined;
    message.updateDate = object.updateDate ?? undefined;
    message.expirationDate = object.expirationDate ?? undefined;
    message.value = object.value ?? undefined;
    message.size = object.size ?? undefined;
    message.format = object.format ?? undefined;
    message.securedBy = (object.securedBy !== undefined && object.securedBy !== null)
      ? CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy.fromPartial(object.securedBy)
      : undefined;
    return message;
  },
};

function createBaseCryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy(): CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy {
  return { mechanism: undefined, algorithmRef: undefined };
}

export const CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy: MessageFns<
  CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy
> = {
  encode(
    message: CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.mechanism !== undefined) {
      writer.uint32(10).string(message.mechanism);
    }
    if (message.algorithmRef !== undefined) {
      writer.uint32(18).string(message.algorithmRef);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mechanism = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.algorithmRef = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy {
    return {
      mechanism: isSet(object.mechanism) ? globalThis.String(object.mechanism) : undefined,
      algorithmRef: isSet(object.algorithmRef) ? globalThis.String(object.algorithmRef) : undefined,
    };
  },

  toJSON(message: CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy): unknown {
    const obj: any = {};
    if (message.mechanism !== undefined) {
      obj.mechanism = message.mechanism;
    }
    if (message.algorithmRef !== undefined) {
      obj.algorithmRef = message.algorithmRef;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy>, I>>(
    base?: I,
  ): CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy {
    return CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy>, I>>(
    object: I,
  ): CryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy {
    const message = createBaseCryptoProperties_RelatedCryptoMaterialProperties_CryptoRelatedSecuredBy();
    message.mechanism = object.mechanism ?? undefined;
    message.algorithmRef = object.algorithmRef ?? undefined;
    return message;
  },
};

function createBaseCryptoProperties_ProtocolProperties(): CryptoProperties_ProtocolProperties {
  return { type: undefined, version: undefined, cipherSuites: [], ikev2TransformTypes: undefined, cryptoRef: [] };
}

export const CryptoProperties_ProtocolProperties: MessageFns<CryptoProperties_ProtocolProperties> = {
  encode(message: CryptoProperties_ProtocolProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== undefined) {
      writer.uint32(8).int32(message.type);
    }
    if (message.version !== undefined) {
      writer.uint32(18).string(message.version);
    }
    for (const v of message.cipherSuites) {
      CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.ikev2TransformTypes !== undefined) {
      CryptoProperties_ProtocolProperties_Ikev2TransformTypes.encode(
        message.ikev2TransformTypes,
        writer.uint32(34).fork(),
      ).join();
    }
    for (const v of message.cryptoRef) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CryptoProperties_ProtocolProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoProperties_ProtocolProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cipherSuites.push(
            CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ikev2TransformTypes = CryptoProperties_ProtocolProperties_Ikev2TransformTypes.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.cryptoRef.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoProperties_ProtocolProperties {
    return {
      type: isSet(object.type)
        ? cryptoProperties_ProtocolProperties_CryptoProtocolTypeFromJSON(object.type)
        : undefined,
      version: isSet(object.version) ? globalThis.String(object.version) : undefined,
      cipherSuites: globalThis.Array.isArray(object?.cipherSuites)
        ? object.cipherSuites.map((e: any) => CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite.fromJSON(e))
        : [],
      ikev2TransformTypes: isSet(object.ikev2TransformTypes)
        ? CryptoProperties_ProtocolProperties_Ikev2TransformTypes.fromJSON(object.ikev2TransformTypes)
        : undefined,
      cryptoRef: globalThis.Array.isArray(object?.cryptoRef)
        ? object.cryptoRef.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CryptoProperties_ProtocolProperties): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = cryptoProperties_ProtocolProperties_CryptoProtocolTypeToJSON(message.type);
    }
    if (message.version !== undefined) {
      obj.version = message.version;
    }
    if (message.cipherSuites?.length) {
      obj.cipherSuites = message.cipherSuites.map((e) =>
        CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite.toJSON(e)
      );
    }
    if (message.ikev2TransformTypes !== undefined) {
      obj.ikev2TransformTypes = CryptoProperties_ProtocolProperties_Ikev2TransformTypes.toJSON(
        message.ikev2TransformTypes,
      );
    }
    if (message.cryptoRef?.length) {
      obj.cryptoRef = message.cryptoRef;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CryptoProperties_ProtocolProperties>, I>>(
    base?: I,
  ): CryptoProperties_ProtocolProperties {
    return CryptoProperties_ProtocolProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CryptoProperties_ProtocolProperties>, I>>(
    object: I,
  ): CryptoProperties_ProtocolProperties {
    const message = createBaseCryptoProperties_ProtocolProperties();
    message.type = object.type ?? undefined;
    message.version = object.version ?? undefined;
    message.cipherSuites =
      object.cipherSuites?.map((e) => CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite.fromPartial(e)) ||
      [];
    message.ikev2TransformTypes = (object.ikev2TransformTypes !== undefined && object.ikev2TransformTypes !== null)
      ? CryptoProperties_ProtocolProperties_Ikev2TransformTypes.fromPartial(object.ikev2TransformTypes)
      : undefined;
    message.cryptoRef = object.cryptoRef?.map((e) => e) || [];
    return message;
  },
};

function createBaseCryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite(): CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite {
  return { name: undefined, algorithms: [], identifiers: [] };
}

export const CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite: MessageFns<
  CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite
> = {
  encode(
    message: CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.algorithms) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.identifiers) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.algorithms.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.identifiers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      algorithms: globalThis.Array.isArray(object?.algorithms)
        ? object.algorithms.map((e: any) => globalThis.String(e))
        : [],
      identifiers: globalThis.Array.isArray(object?.identifiers)
        ? object.identifiers.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.algorithms?.length) {
      obj.algorithms = message.algorithms;
    }
    if (message.identifiers?.length) {
      obj.identifiers = message.identifiers;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite>, I>>(
    base?: I,
  ): CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite {
    return CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite>, I>>(
    object: I,
  ): CryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite {
    const message = createBaseCryptoProperties_ProtocolProperties_CryptoProtocolCipherSuite();
    message.name = object.name ?? undefined;
    message.algorithms = object.algorithms?.map((e) => e) || [];
    message.identifiers = object.identifiers?.map((e) => e) || [];
    return message;
  },
};

function createBaseCryptoProperties_ProtocolProperties_Ikev2TransformTypes(): CryptoProperties_ProtocolProperties_Ikev2TransformTypes {
  return { encr: [], prf: [], integ: [], ke: [], esn: undefined, auth: [] };
}

export const CryptoProperties_ProtocolProperties_Ikev2TransformTypes: MessageFns<
  CryptoProperties_ProtocolProperties_Ikev2TransformTypes
> = {
  encode(
    message: CryptoProperties_ProtocolProperties_Ikev2TransformTypes,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.encr) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.prf) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.integ) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.ke) {
      writer.uint32(34).string(v!);
    }
    if (message.esn !== undefined) {
      writer.uint32(40).bool(message.esn);
    }
    for (const v of message.auth) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CryptoProperties_ProtocolProperties_Ikev2TransformTypes {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCryptoProperties_ProtocolProperties_Ikev2TransformTypes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.encr.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prf.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.integ.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ke.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.esn = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.auth.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CryptoProperties_ProtocolProperties_Ikev2TransformTypes {
    return {
      encr: globalThis.Array.isArray(object?.encr) ? object.encr.map((e: any) => globalThis.String(e)) : [],
      prf: globalThis.Array.isArray(object?.prf) ? object.prf.map((e: any) => globalThis.String(e)) : [],
      integ: globalThis.Array.isArray(object?.integ) ? object.integ.map((e: any) => globalThis.String(e)) : [],
      ke: globalThis.Array.isArray(object?.ke) ? object.ke.map((e: any) => globalThis.String(e)) : [],
      esn: isSet(object.esn) ? globalThis.Boolean(object.esn) : undefined,
      auth: globalThis.Array.isArray(object?.auth) ? object.auth.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CryptoProperties_ProtocolProperties_Ikev2TransformTypes): unknown {
    const obj: any = {};
    if (message.encr?.length) {
      obj.encr = message.encr;
    }
    if (message.prf?.length) {
      obj.prf = message.prf;
    }
    if (message.integ?.length) {
      obj.integ = message.integ;
    }
    if (message.ke?.length) {
      obj.ke = message.ke;
    }
    if (message.esn !== undefined) {
      obj.esn = message.esn;
    }
    if (message.auth?.length) {
      obj.auth = message.auth;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CryptoProperties_ProtocolProperties_Ikev2TransformTypes>, I>>(
    base?: I,
  ): CryptoProperties_ProtocolProperties_Ikev2TransformTypes {
    return CryptoProperties_ProtocolProperties_Ikev2TransformTypes.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CryptoProperties_ProtocolProperties_Ikev2TransformTypes>, I>>(
    object: I,
  ): CryptoProperties_ProtocolProperties_Ikev2TransformTypes {
    const message = createBaseCryptoProperties_ProtocolProperties_Ikev2TransformTypes();
    message.encr = object.encr?.map((e) => e) || [];
    message.prf = object.prf?.map((e) => e) || [];
    message.integ = object.integ?.map((e) => e) || [];
    message.ke = object.ke?.map((e) => e) || [];
    message.esn = object.esn ?? undefined;
    message.auth = object.auth?.map((e) => e) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
